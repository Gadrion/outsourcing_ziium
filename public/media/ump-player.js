/*******************************************************************************
 * Copyright (c) 2018 Hanwha Techwin Co., Ltd.
 * Licensed to the Hanwha Techwin Software Foundation under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * Total Plugin-Free Web Browser Viewer Framework 
 * http://www.hanwhatechwin.com
 *
 * Security Solution Development Division / Web Software Development Team
 *
 * Summary: ump-player
 * Description: UMP Framework 3.1.2.0021
 * @file ump-player_3.1.2.0021.js
 * @version 3.1.2.0021
 * @since 16-04-2019
 * @author by Youngho Kim (young.ho.kim@hanwha.com), 
 *              by Yongsoo Ko (yongsoo.ko@hanwha.com), 
 *              by Miju Park (miju462.park@hanwha.com), 
 *              by Sweungwon Cheung (sw.cheung@hanwha.com), 
 *              by Jongchan Park (jden.park@hanwha.com), 
 */ 
var CryptoJS=CryptoJS||function(s,p){var m={},l=m.lib={},n=function(){},r=l.Base={extend:function(b){n.prototype=this;var h=new n;b&&h.mixIn(b);h.hasOwnProperty("init")||(h.init=function(){h.$super.init.apply(this,arguments)});h.init.prototype=h;h.$super=this;return h},create:function(){var b=this.extend();b.init.apply(b,arguments);return b},init:function(){},mixIn:function(b){for(var h in b)b.hasOwnProperty(h)&&(this[h]=b[h]);b.hasOwnProperty("toString")&&(this.toString=b.toString)},clone:function(){return this.init.prototype.extend(this)}},
q=l.WordArray=r.extend({init:function(b,h){b=this.words=b||[];this.sigBytes=h!=p?h:4*b.length},toString:function(b){return(b||t).stringify(this)},concat:function(b){var h=this.words,a=b.words,j=this.sigBytes;b=b.sigBytes;this.clamp();if(j%4)for(var g=0;g<b;g++)h[j+g>>>2]|=(a[g>>>2]>>>24-8*(g%4)&255)<<24-8*((j+g)%4);else if(65535<a.length)for(g=0;g<b;g+=4)h[j+g>>>2]=a[g>>>2];else h.push.apply(h,a);this.sigBytes+=b;return this},clamp:function(){var b=this.words,h=this.sigBytes;b[h>>>2]&=4294967295<<
32-8*(h%4);b.length=s.ceil(h/4)},clone:function(){var b=r.clone.call(this);b.words=this.words.slice(0);return b},random:function(b){for(var h=[],a=0;a<b;a+=4)h.push(4294967296*s.random()|0);return new q.init(h,b)}}),v=m.enc={},t=v.Hex={stringify:function(b){var a=b.words;b=b.sigBytes;for(var g=[],j=0;j<b;j++){var k=a[j>>>2]>>>24-8*(j%4)&255;g.push((k>>>4).toString(16));g.push((k&15).toString(16))}return g.join("")},parse:function(b){for(var a=b.length,g=[],j=0;j<a;j+=2)g[j>>>3]|=parseInt(b.substr(j,
2),16)<<24-4*(j%8);return new q.init(g,a/2)}},a=v.Latin1={stringify:function(b){var a=b.words;b=b.sigBytes;for(var g=[],j=0;j<b;j++)g.push(String.fromCharCode(a[j>>>2]>>>24-8*(j%4)&255));return g.join("")},parse:function(b){for(var a=b.length,g=[],j=0;j<a;j++)g[j>>>2]|=(b.charCodeAt(j)&255)<<24-8*(j%4);return new q.init(g,a)}},u=v.Utf8={stringify:function(b){try{return decodeURIComponent(escape(a.stringify(b)))}catch(g){throw Error("Malformed UTF-8 data");}},parse:function(b){return a.parse(unescape(encodeURIComponent(b)))}},
g=l.BufferedBlockAlgorithm=r.extend({reset:function(){this._data=new q.init;this._nDataBytes=0},_append:function(b){"string"==typeof b&&(b=u.parse(b));this._data.concat(b);this._nDataBytes+=b.sigBytes},_process:function(b){var a=this._data,g=a.words,j=a.sigBytes,k=this.blockSize,m=j/(4*k),m=b?s.ceil(m):s.max((m|0)-this._minBufferSize,0);b=m*k;j=s.min(4*b,j);if(b){for(var l=0;l<b;l+=k)this._doProcessBlock(g,l);l=g.splice(0,b);a.sigBytes-=j}return new q.init(l,j)},clone:function(){var b=r.clone.call(this);
b._data=this._data.clone();return b},_minBufferSize:0});l.Hasher=g.extend({cfg:r.extend(),init:function(b){this.cfg=this.cfg.extend(b);this.reset()},reset:function(){g.reset.call(this);this._doReset()},update:function(b){this._append(b);this._process();return this},finalize:function(b){b&&this._append(b);return this._doFinalize()},blockSize:16,_createHelper:function(b){return function(a,g){return(new b.init(g)).finalize(a)}},_createHmacHelper:function(b){return function(a,g){return(new k.HMAC.init(b,
g)).finalize(a)}}});var k=m.algo={};return m}(Math);
(function(s){function p(a,k,b,h,l,j,m){a=a+(k&b|~k&h)+l+m;return(a<<j|a>>>32-j)+k}function m(a,k,b,h,l,j,m){a=a+(k&h|b&~h)+l+m;return(a<<j|a>>>32-j)+k}function l(a,k,b,h,l,j,m){a=a+(k^b^h)+l+m;return(a<<j|a>>>32-j)+k}function n(a,k,b,h,l,j,m){a=a+(b^(k|~h))+l+m;return(a<<j|a>>>32-j)+k}for(var r=CryptoJS,q=r.lib,v=q.WordArray,t=q.Hasher,q=r.algo,a=[],u=0;64>u;u++)a[u]=4294967296*s.abs(s.sin(u+1))|0;q=q.MD5=t.extend({_doReset:function(){this._hash=new v.init([1732584193,4023233417,2562383102,271733878])},
_doProcessBlock:function(g,k){for(var b=0;16>b;b++){var h=k+b,w=g[h];g[h]=(w<<8|w>>>24)&16711935|(w<<24|w>>>8)&4278255360}var b=this._hash.words,h=g[k+0],w=g[k+1],j=g[k+2],q=g[k+3],r=g[k+4],s=g[k+5],t=g[k+6],u=g[k+7],v=g[k+8],x=g[k+9],y=g[k+10],z=g[k+11],A=g[k+12],B=g[k+13],C=g[k+14],D=g[k+15],c=b[0],d=b[1],e=b[2],f=b[3],c=p(c,d,e,f,h,7,a[0]),f=p(f,c,d,e,w,12,a[1]),e=p(e,f,c,d,j,17,a[2]),d=p(d,e,f,c,q,22,a[3]),c=p(c,d,e,f,r,7,a[4]),f=p(f,c,d,e,s,12,a[5]),e=p(e,f,c,d,t,17,a[6]),d=p(d,e,f,c,u,22,a[7]),
c=p(c,d,e,f,v,7,a[8]),f=p(f,c,d,e,x,12,a[9]),e=p(e,f,c,d,y,17,a[10]),d=p(d,e,f,c,z,22,a[11]),c=p(c,d,e,f,A,7,a[12]),f=p(f,c,d,e,B,12,a[13]),e=p(e,f,c,d,C,17,a[14]),d=p(d,e,f,c,D,22,a[15]),c=m(c,d,e,f,w,5,a[16]),f=m(f,c,d,e,t,9,a[17]),e=m(e,f,c,d,z,14,a[18]),d=m(d,e,f,c,h,20,a[19]),c=m(c,d,e,f,s,5,a[20]),f=m(f,c,d,e,y,9,a[21]),e=m(e,f,c,d,D,14,a[22]),d=m(d,e,f,c,r,20,a[23]),c=m(c,d,e,f,x,5,a[24]),f=m(f,c,d,e,C,9,a[25]),e=m(e,f,c,d,q,14,a[26]),d=m(d,e,f,c,v,20,a[27]),c=m(c,d,e,f,B,5,a[28]),f=m(f,c,
d,e,j,9,a[29]),e=m(e,f,c,d,u,14,a[30]),d=m(d,e,f,c,A,20,a[31]),c=l(c,d,e,f,s,4,a[32]),f=l(f,c,d,e,v,11,a[33]),e=l(e,f,c,d,z,16,a[34]),d=l(d,e,f,c,C,23,a[35]),c=l(c,d,e,f,w,4,a[36]),f=l(f,c,d,e,r,11,a[37]),e=l(e,f,c,d,u,16,a[38]),d=l(d,e,f,c,y,23,a[39]),c=l(c,d,e,f,B,4,a[40]),f=l(f,c,d,e,h,11,a[41]),e=l(e,f,c,d,q,16,a[42]),d=l(d,e,f,c,t,23,a[43]),c=l(c,d,e,f,x,4,a[44]),f=l(f,c,d,e,A,11,a[45]),e=l(e,f,c,d,D,16,a[46]),d=l(d,e,f,c,j,23,a[47]),c=n(c,d,e,f,h,6,a[48]),f=n(f,c,d,e,u,10,a[49]),e=n(e,f,c,d,
C,15,a[50]),d=n(d,e,f,c,s,21,a[51]),c=n(c,d,e,f,A,6,a[52]),f=n(f,c,d,e,q,10,a[53]),e=n(e,f,c,d,y,15,a[54]),d=n(d,e,f,c,w,21,a[55]),c=n(c,d,e,f,v,6,a[56]),f=n(f,c,d,e,D,10,a[57]),e=n(e,f,c,d,t,15,a[58]),d=n(d,e,f,c,B,21,a[59]),c=n(c,d,e,f,r,6,a[60]),f=n(f,c,d,e,z,10,a[61]),e=n(e,f,c,d,j,15,a[62]),d=n(d,e,f,c,x,21,a[63]);b[0]=b[0]+c|0;b[1]=b[1]+d|0;b[2]=b[2]+e|0;b[3]=b[3]+f|0},_doFinalize:function(){var a=this._data,k=a.words,b=8*this._nDataBytes,h=8*a.sigBytes;k[h>>>5]|=128<<24-h%32;var l=s.floor(b/
4294967296);k[(h+64>>>9<<4)+15]=(l<<8|l>>>24)&16711935|(l<<24|l>>>8)&4278255360;k[(h+64>>>9<<4)+14]=(b<<8|b>>>24)&16711935|(b<<24|b>>>8)&4278255360;a.sigBytes=4*(k.length+1);this._process();a=this._hash;k=a.words;for(b=0;4>b;b++)h=k[b],k[b]=(h<<8|h>>>24)&16711935|(h<<24|h>>>8)&4278255360;return a},clone:function(){var a=t.clone.call(this);a._hash=this._hash.clone();return a}});r.MD5=t._createHelper(q);r.HmacMD5=t._createHmacHelper(q)})(Math);

eval(function(p,a,c,k,e,r){e=function(c){return(c<a?'':e(parseInt(c/a)))+((c=c%a)>35?String.fromCharCode(c+29):c.toString(36))};if(!''.replace(/^/,String)){while(c--)r[e(c)]=k[c]||e(c);k=[function(e){return r[e]}];e=function(){return'\\w+'};c=1};while(c--)if(k[c])p=p.replace(new RegExp('\\b'+e(c)+'\\b','g'),k[c]);return p}('9 17={3i:\'0.1.3\',16:1e-6};l v(){}v.23={e:l(i){8(i<1||i>7.4.q)?w:7.4[i-1]},2R:l(){8 7.4.q},1u:l(){8 F.1x(7.2u(7))},24:l(a){9 n=7.4.q;9 V=a.4||a;o(n!=V.q){8 1L}J{o(F.13(7.4[n-1]-V[n-1])>17.16){8 1L}}H(--n);8 2x},1q:l(){8 v.u(7.4)},1b:l(a){9 b=[];7.28(l(x,i){b.19(a(x,i))});8 v.u(b)},28:l(a){9 n=7.4.q,k=n,i;J{i=k-n;a(7.4[i],i+1)}H(--n)},2q:l(){9 r=7.1u();o(r===0){8 7.1q()}8 7.1b(l(x){8 x/r})},1C:l(a){9 V=a.4||a;9 n=7.4.q,k=n,i;o(n!=V.q){8 w}9 b=0,1D=0,1F=0;7.28(l(x,i){b+=x*V[i-1];1D+=x*x;1F+=V[i-1]*V[i-1]});1D=F.1x(1D);1F=F.1x(1F);o(1D*1F===0){8 w}9 c=b/(1D*1F);o(c<-1){c=-1}o(c>1){c=1}8 F.37(c)},1m:l(a){9 b=7.1C(a);8(b===w)?w:(b<=17.16)},34:l(a){9 b=7.1C(a);8(b===w)?w:(F.13(b-F.1A)<=17.16)},2k:l(a){9 b=7.2u(a);8(b===w)?w:(F.13(b)<=17.16)},2j:l(a){9 V=a.4||a;o(7.4.q!=V.q){8 w}8 7.1b(l(x,i){8 x+V[i-1]})},2C:l(a){9 V=a.4||a;o(7.4.q!=V.q){8 w}8 7.1b(l(x,i){8 x-V[i-1]})},22:l(k){8 7.1b(l(x){8 x*k})},x:l(k){8 7.22(k)},2u:l(a){9 V=a.4||a;9 i,2g=0,n=7.4.q;o(n!=V.q){8 w}J{2g+=7.4[n-1]*V[n-1]}H(--n);8 2g},2f:l(a){9 B=a.4||a;o(7.4.q!=3||B.q!=3){8 w}9 A=7.4;8 v.u([(A[1]*B[2])-(A[2]*B[1]),(A[2]*B[0])-(A[0]*B[2]),(A[0]*B[1])-(A[1]*B[0])])},2A:l(){9 m=0,n=7.4.q,k=n,i;J{i=k-n;o(F.13(7.4[i])>F.13(m)){m=7.4[i]}}H(--n);8 m},2Z:l(x){9 a=w,n=7.4.q,k=n,i;J{i=k-n;o(a===w&&7.4[i]==x){a=i+1}}H(--n);8 a},3g:l(){8 S.2X(7.4)},2d:l(){8 7.1b(l(x){8 F.2d(x)})},2V:l(x){8 7.1b(l(y){8(F.13(y-x)<=17.16)?x:y})},1o:l(a){o(a.K){8 a.1o(7)}9 V=a.4||a;o(V.q!=7.4.q){8 w}9 b=0,2b;7.28(l(x,i){2b=x-V[i-1];b+=2b*2b});8 F.1x(b)},3a:l(a){8 a.1h(7)},2T:l(a){8 a.1h(7)},1V:l(t,a){9 V,R,x,y,z;2S(7.4.q){27 2:V=a.4||a;o(V.q!=2){8 w}R=S.1R(t).4;x=7.4[0]-V[0];y=7.4[1]-V[1];8 v.u([V[0]+R[0][0]*x+R[0][1]*y,V[1]+R[1][0]*x+R[1][1]*y]);1I;27 3:o(!a.U){8 w}9 C=a.1r(7).4;R=S.1R(t,a.U).4;x=7.4[0]-C[0];y=7.4[1]-C[1];z=7.4[2]-C[2];8 v.u([C[0]+R[0][0]*x+R[0][1]*y+R[0][2]*z,C[1]+R[1][0]*x+R[1][1]*y+R[1][2]*z,C[2]+R[2][0]*x+R[2][1]*y+R[2][2]*z]);1I;2P:8 w}},1t:l(a){o(a.K){9 P=7.4.2O();9 C=a.1r(P).4;8 v.u([C[0]+(C[0]-P[0]),C[1]+(C[1]-P[1]),C[2]+(C[2]-(P[2]||0))])}1d{9 Q=a.4||a;o(7.4.q!=Q.q){8 w}8 7.1b(l(x,i){8 Q[i-1]+(Q[i-1]-x)})}},1N:l(){9 V=7.1q();2S(V.4.q){27 3:1I;27 2:V.4.19(0);1I;2P:8 w}8 V},2n:l(){8\'[\'+7.4.2K(\', \')+\']\'},26:l(a){7.4=(a.4||a).2O();8 7}};v.u=l(a){9 V=25 v();8 V.26(a)};v.i=v.u([1,0,0]);v.j=v.u([0,1,0]);v.k=v.u([0,0,1]);v.2J=l(n){9 a=[];J{a.19(F.2F())}H(--n);8 v.u(a)};v.1j=l(n){9 a=[];J{a.19(0)}H(--n);8 v.u(a)};l S(){}S.23={e:l(i,j){o(i<1||i>7.4.q||j<1||j>7.4[0].q){8 w}8 7.4[i-1][j-1]},33:l(i){o(i>7.4.q){8 w}8 v.u(7.4[i-1])},2E:l(j){o(j>7.4[0].q){8 w}9 a=[],n=7.4.q,k=n,i;J{i=k-n;a.19(7.4[i][j-1])}H(--n);8 v.u(a)},2R:l(){8{2D:7.4.q,1p:7.4[0].q}},2D:l(){8 7.4.q},1p:l(){8 7.4[0].q},24:l(a){9 M=a.4||a;o(1g(M[0][0])==\'1f\'){M=S.u(M).4}o(7.4.q!=M.q||7.4[0].q!=M[0].q){8 1L}9 b=7.4.q,15=b,i,G,10=7.4[0].q,j;J{i=15-b;G=10;J{j=10-G;o(F.13(7.4[i][j]-M[i][j])>17.16){8 1L}}H(--G)}H(--b);8 2x},1q:l(){8 S.u(7.4)},1b:l(a){9 b=[],12=7.4.q,15=12,i,G,10=7.4[0].q,j;J{i=15-12;G=10;b[i]=[];J{j=10-G;b[i][j]=a(7.4[i][j],i+1,j+1)}H(--G)}H(--12);8 S.u(b)},2i:l(a){9 M=a.4||a;o(1g(M[0][0])==\'1f\'){M=S.u(M).4}8(7.4.q==M.q&&7.4[0].q==M[0].q)},2j:l(a){9 M=a.4||a;o(1g(M[0][0])==\'1f\'){M=S.u(M).4}o(!7.2i(M)){8 w}8 7.1b(l(x,i,j){8 x+M[i-1][j-1]})},2C:l(a){9 M=a.4||a;o(1g(M[0][0])==\'1f\'){M=S.u(M).4}o(!7.2i(M)){8 w}8 7.1b(l(x,i,j){8 x-M[i-1][j-1]})},2B:l(a){9 M=a.4||a;o(1g(M[0][0])==\'1f\'){M=S.u(M).4}8(7.4[0].q==M.q)},22:l(a){o(!a.4){8 7.1b(l(x){8 x*a})}9 b=a.1u?2x:1L;9 M=a.4||a;o(1g(M[0][0])==\'1f\'){M=S.u(M).4}o(!7.2B(M)){8 w}9 d=7.4.q,15=d,i,G,10=M[0].q,j;9 e=7.4[0].q,4=[],21,20,c;J{i=15-d;4[i]=[];G=10;J{j=10-G;21=0;20=e;J{c=e-20;21+=7.4[i][c]*M[c][j]}H(--20);4[i][j]=21}H(--G)}H(--d);9 M=S.u(4);8 b?M.2E(1):M},x:l(a){8 7.22(a)},32:l(a,b,c,d){9 e=[],12=c,i,G,j;9 f=7.4.q,1p=7.4[0].q;J{i=c-12;e[i]=[];G=d;J{j=d-G;e[i][j]=7.4[(a+i-1)%f][(b+j-1)%1p]}H(--G)}H(--12);8 S.u(e)},31:l(){9 a=7.4.q,1p=7.4[0].q;9 b=[],12=1p,i,G,j;J{i=1p-12;b[i]=[];G=a;J{j=a-G;b[i][j]=7.4[j][i]}H(--G)}H(--12);8 S.u(b)},1y:l(){8(7.4.q==7.4[0].q)},2A:l(){9 m=0,12=7.4.q,15=12,i,G,10=7.4[0].q,j;J{i=15-12;G=10;J{j=10-G;o(F.13(7.4[i][j])>F.13(m)){m=7.4[i][j]}}H(--G)}H(--12);8 m},2Z:l(x){9 a=w,12=7.4.q,15=12,i,G,10=7.4[0].q,j;J{i=15-12;G=10;J{j=10-G;o(7.4[i][j]==x){8{i:i+1,j:j+1}}}H(--G)}H(--12);8 w},30:l(){o(!7.1y){8 w}9 a=[],n=7.4.q,k=n,i;J{i=k-n;a.19(7.4[i][i])}H(--n);8 v.u(a)},1K:l(){9 M=7.1q(),1c;9 n=7.4.q,k=n,i,1s,1n=7.4[0].q,p;J{i=k-n;o(M.4[i][i]==0){2e(j=i+1;j<k;j++){o(M.4[j][i]!=0){1c=[];1s=1n;J{p=1n-1s;1c.19(M.4[i][p]+M.4[j][p])}H(--1s);M.4[i]=1c;1I}}}o(M.4[i][i]!=0){2e(j=i+1;j<k;j++){9 a=M.4[j][i]/M.4[i][i];1c=[];1s=1n;J{p=1n-1s;1c.19(p<=i?0:M.4[j][p]-M.4[i][p]*a)}H(--1s);M.4[j]=1c}}}H(--n);8 M},3h:l(){8 7.1K()},2z:l(){o(!7.1y()){8 w}9 M=7.1K();9 a=M.4[0][0],n=M.4.q-1,k=n,i;J{i=k-n+1;a=a*M.4[i][i]}H(--n);8 a},3f:l(){8 7.2z()},2y:l(){8(7.1y()&&7.2z()===0)},2Y:l(){o(!7.1y()){8 w}9 a=7.4[0][0],n=7.4.q-1,k=n,i;J{i=k-n+1;a+=7.4[i][i]}H(--n);8 a},3e:l(){8 7.2Y()},1Y:l(){9 M=7.1K(),1Y=0;9 a=7.4.q,15=a,i,G,10=7.4[0].q,j;J{i=15-a;G=10;J{j=10-G;o(F.13(M.4[i][j])>17.16){1Y++;1I}}H(--G)}H(--a);8 1Y},3d:l(){8 7.1Y()},2W:l(a){9 M=a.4||a;o(1g(M[0][0])==\'1f\'){M=S.u(M).4}9 T=7.1q(),1p=T.4[0].q;9 b=T.4.q,15=b,i,G,10=M[0].q,j;o(b!=M.q){8 w}J{i=15-b;G=10;J{j=10-G;T.4[i][1p+j]=M[i][j]}H(--G)}H(--b);8 T},2w:l(){o(!7.1y()||7.2y()){8 w}9 a=7.4.q,15=a,i,j;9 M=7.2W(S.I(a)).1K();9 b,1n=M.4[0].q,p,1c,2v;9 c=[],2c;J{i=a-1;1c=[];b=1n;c[i]=[];2v=M.4[i][i];J{p=1n-b;2c=M.4[i][p]/2v;1c.19(2c);o(p>=15){c[i].19(2c)}}H(--b);M.4[i]=1c;2e(j=0;j<i;j++){1c=[];b=1n;J{p=1n-b;1c.19(M.4[j][p]-M.4[i][p]*M.4[j][i])}H(--b);M.4[j]=1c}}H(--a);8 S.u(c)},3c:l(){8 7.2w()},2d:l(){8 7.1b(l(x){8 F.2d(x)})},2V:l(x){8 7.1b(l(p){8(F.13(p-x)<=17.16)?x:p})},2n:l(){9 a=[];9 n=7.4.q,k=n,i;J{i=k-n;a.19(v.u(7.4[i]).2n())}H(--n);8 a.2K(\'\\n\')},26:l(a){9 i,4=a.4||a;o(1g(4[0][0])!=\'1f\'){9 b=4.q,15=b,G,10,j;7.4=[];J{i=15-b;G=4[i].q;10=G;7.4[i]=[];J{j=10-G;7.4[i][j]=4[i][j]}H(--G)}H(--b);8 7}9 n=4.q,k=n;7.4=[];J{i=k-n;7.4.19([4[i]])}H(--n);8 7}};S.u=l(a){9 M=25 S();8 M.26(a)};S.I=l(n){9 a=[],k=n,i,G,j;J{i=k-n;a[i]=[];G=k;J{j=k-G;a[i][j]=(i==j)?1:0}H(--G)}H(--n);8 S.u(a)};S.2X=l(a){9 n=a.q,k=n,i;9 M=S.I(n);J{i=k-n;M.4[i][i]=a[i]}H(--n);8 M};S.1R=l(b,a){o(!a){8 S.u([[F.1H(b),-F.1G(b)],[F.1G(b),F.1H(b)]])}9 d=a.1q();o(d.4.q!=3){8 w}9 e=d.1u();9 x=d.4[0]/e,y=d.4[1]/e,z=d.4[2]/e;9 s=F.1G(b),c=F.1H(b),t=1-c;8 S.u([[t*x*x+c,t*x*y-s*z,t*x*z+s*y],[t*x*y+s*z,t*y*y+c,t*y*z-s*x],[t*x*z-s*y,t*y*z+s*x,t*z*z+c]])};S.3b=l(t){9 c=F.1H(t),s=F.1G(t);8 S.u([[1,0,0],[0,c,-s],[0,s,c]])};S.39=l(t){9 c=F.1H(t),s=F.1G(t);8 S.u([[c,0,s],[0,1,0],[-s,0,c]])};S.38=l(t){9 c=F.1H(t),s=F.1G(t);8 S.u([[c,-s,0],[s,c,0],[0,0,1]])};S.2J=l(n,m){8 S.1j(n,m).1b(l(){8 F.2F()})};S.1j=l(n,m){9 a=[],12=n,i,G,j;J{i=n-12;a[i]=[];G=m;J{j=m-G;a[i][j]=0}H(--G)}H(--12);8 S.u(a)};l 14(){}14.23={24:l(a){8(7.1m(a)&&7.1h(a.K))},1q:l(){8 14.u(7.K,7.U)},2U:l(a){9 V=a.4||a;8 14.u([7.K.4[0]+V[0],7.K.4[1]+V[1],7.K.4[2]+(V[2]||0)],7.U)},1m:l(a){o(a.W){8 a.1m(7)}9 b=7.U.1C(a.U);8(F.13(b)<=17.16||F.13(b-F.1A)<=17.16)},1o:l(a){o(a.W){8 a.1o(7)}o(a.U){o(7.1m(a)){8 7.1o(a.K)}9 N=7.U.2f(a.U).2q().4;9 A=7.K.4,B=a.K.4;8 F.13((A[0]-B[0])*N[0]+(A[1]-B[1])*N[1]+(A[2]-B[2])*N[2])}1d{9 P=a.4||a;9 A=7.K.4,D=7.U.4;9 b=P[0]-A[0],2a=P[1]-A[1],29=(P[2]||0)-A[2];9 c=F.1x(b*b+2a*2a+29*29);o(c===0)8 0;9 d=(b*D[0]+2a*D[1]+29*D[2])/c;9 e=1-d*d;8 F.13(c*F.1x(e<0?0:e))}},1h:l(a){9 b=7.1o(a);8(b!==w&&b<=17.16)},2T:l(a){8 a.1h(7)},1v:l(a){o(a.W){8 a.1v(7)}8(!7.1m(a)&&7.1o(a)<=17.16)},1U:l(a){o(a.W){8 a.1U(7)}o(!7.1v(a)){8 w}9 P=7.K.4,X=7.U.4,Q=a.K.4,Y=a.U.4;9 b=X[0],1z=X[1],1B=X[2],1T=Y[0],1S=Y[1],1M=Y[2];9 c=P[0]-Q[0],2s=P[1]-Q[1],2r=P[2]-Q[2];9 d=-b*c-1z*2s-1B*2r;9 e=1T*c+1S*2s+1M*2r;9 f=b*b+1z*1z+1B*1B;9 g=1T*1T+1S*1S+1M*1M;9 h=b*1T+1z*1S+1B*1M;9 k=(d*g/f+h*e)/(g-h*h);8 v.u([P[0]+k*b,P[1]+k*1z,P[2]+k*1B])},1r:l(a){o(a.U){o(7.1v(a)){8 7.1U(a)}o(7.1m(a)){8 w}9 D=7.U.4,E=a.U.4;9 b=D[0],1l=D[1],1k=D[2],1P=E[0],1O=E[1],1Q=E[2];9 x=(1k*1P-b*1Q),y=(b*1O-1l*1P),z=(1l*1Q-1k*1O);9 N=v.u([x*1Q-y*1O,y*1P-z*1Q,z*1O-x*1P]);9 P=11.u(a.K,N);8 P.1U(7)}1d{9 P=a.4||a;o(7.1h(P)){8 v.u(P)}9 A=7.K.4,D=7.U.4;9 b=D[0],1l=D[1],1k=D[2],1w=A[0],18=A[1],1a=A[2];9 x=b*(P[1]-18)-1l*(P[0]-1w),y=1l*((P[2]||0)-1a)-1k*(P[1]-18),z=1k*(P[0]-1w)-b*((P[2]||0)-1a);9 V=v.u([1l*x-1k*z,1k*y-b*x,b*z-1l*y]);9 k=7.1o(P)/V.1u();8 v.u([P[0]+V.4[0]*k,P[1]+V.4[1]*k,(P[2]||0)+V.4[2]*k])}},1V:l(t,a){o(1g(a.U)==\'1f\'){a=14.u(a.1N(),v.k)}9 R=S.1R(t,a.U).4;9 C=a.1r(7.K).4;9 A=7.K.4,D=7.U.4;9 b=C[0],1E=C[1],1J=C[2],1w=A[0],18=A[1],1a=A[2];9 x=1w-b,y=18-1E,z=1a-1J;8 14.u([b+R[0][0]*x+R[0][1]*y+R[0][2]*z,1E+R[1][0]*x+R[1][1]*y+R[1][2]*z,1J+R[2][0]*x+R[2][1]*y+R[2][2]*z],[R[0][0]*D[0]+R[0][1]*D[1]+R[0][2]*D[2],R[1][0]*D[0]+R[1][1]*D[1]+R[1][2]*D[2],R[2][0]*D[0]+R[2][1]*D[1]+R[2][2]*D[2]])},1t:l(a){o(a.W){9 A=7.K.4,D=7.U.4;9 b=A[0],18=A[1],1a=A[2],2N=D[0],1l=D[1],1k=D[2];9 c=7.K.1t(a).4;9 d=b+2N,2h=18+1l,2o=1a+1k;9 Q=a.1r([d,2h,2o]).4;9 e=[Q[0]+(Q[0]-d)-c[0],Q[1]+(Q[1]-2h)-c[1],Q[2]+(Q[2]-2o)-c[2]];8 14.u(c,e)}1d o(a.U){8 7.1V(F.1A,a)}1d{9 P=a.4||a;8 14.u(7.K.1t([P[0],P[1],(P[2]||0)]),7.U)}},1Z:l(a,b){a=v.u(a);b=v.u(b);o(a.4.q==2){a.4.19(0)}o(b.4.q==2){b.4.19(0)}o(a.4.q>3||b.4.q>3){8 w}9 c=b.1u();o(c===0){8 w}7.K=a;7.U=v.u([b.4[0]/c,b.4[1]/c,b.4[2]/c]);8 7}};14.u=l(a,b){9 L=25 14();8 L.1Z(a,b)};14.X=14.u(v.1j(3),v.i);14.Y=14.u(v.1j(3),v.j);14.Z=14.u(v.1j(3),v.k);l 11(){}11.23={24:l(a){8(7.1h(a.K)&&7.1m(a))},1q:l(){8 11.u(7.K,7.W)},2U:l(a){9 V=a.4||a;8 11.u([7.K.4[0]+V[0],7.K.4[1]+V[1],7.K.4[2]+(V[2]||0)],7.W)},1m:l(a){9 b;o(a.W){b=7.W.1C(a.W);8(F.13(b)<=17.16||F.13(F.1A-b)<=17.16)}1d o(a.U){8 7.W.2k(a.U)}8 w},2k:l(a){9 b=7.W.1C(a.W);8(F.13(F.1A/2-b)<=17.16)},1o:l(a){o(7.1v(a)||7.1h(a)){8 0}o(a.K){9 A=7.K.4,B=a.K.4,N=7.W.4;8 F.13((A[0]-B[0])*N[0]+(A[1]-B[1])*N[1]+(A[2]-B[2])*N[2])}1d{9 P=a.4||a;9 A=7.K.4,N=7.W.4;8 F.13((A[0]-P[0])*N[0]+(A[1]-P[1])*N[1]+(A[2]-(P[2]||0))*N[2])}},1h:l(a){o(a.W){8 w}o(a.U){8(7.1h(a.K)&&7.1h(a.K.2j(a.U)))}1d{9 P=a.4||a;9 A=7.K.4,N=7.W.4;9 b=F.13(N[0]*(A[0]-P[0])+N[1]*(A[1]-P[1])+N[2]*(A[2]-(P[2]||0)));8(b<=17.16)}},1v:l(a){o(1g(a.U)==\'1f\'&&1g(a.W)==\'1f\'){8 w}8!7.1m(a)},1U:l(a){o(!7.1v(a)){8 w}o(a.U){9 A=a.K.4,D=a.U.4,P=7.K.4,N=7.W.4;9 b=(N[0]*(P[0]-A[0])+N[1]*(P[1]-A[1])+N[2]*(P[2]-A[2]))/(N[0]*D[0]+N[1]*D[1]+N[2]*D[2]);8 v.u([A[0]+D[0]*b,A[1]+D[1]*b,A[2]+D[2]*b])}1d o(a.W){9 c=7.W.2f(a.W).2q();9 N=7.W.4,A=7.K.4,O=a.W.4,B=a.K.4;9 d=S.1j(2,2),i=0;H(d.2y()){i++;d=S.u([[N[i%3],N[(i+1)%3]],[O[i%3],O[(i+1)%3]]])}9 e=d.2w().4;9 x=N[0]*A[0]+N[1]*A[1]+N[2]*A[2];9 y=O[0]*B[0]+O[1]*B[1]+O[2]*B[2];9 f=[e[0][0]*x+e[0][1]*y,e[1][0]*x+e[1][1]*y];9 g=[];2e(9 j=1;j<=3;j++){g.19((i==j)?0:f[(j+(5-i)%3)%3])}8 14.u(g,c)}},1r:l(a){9 P=a.4||a;9 A=7.K.4,N=7.W.4;9 b=(A[0]-P[0])*N[0]+(A[1]-P[1])*N[1]+(A[2]-(P[2]||0))*N[2];8 v.u([P[0]+N[0]*b,P[1]+N[1]*b,(P[2]||0)+N[2]*b])},1V:l(t,a){9 R=S.1R(t,a.U).4;9 C=a.1r(7.K).4;9 A=7.K.4,N=7.W.4;9 b=C[0],1E=C[1],1J=C[2],1w=A[0],18=A[1],1a=A[2];9 x=1w-b,y=18-1E,z=1a-1J;8 11.u([b+R[0][0]*x+R[0][1]*y+R[0][2]*z,1E+R[1][0]*x+R[1][1]*y+R[1][2]*z,1J+R[2][0]*x+R[2][1]*y+R[2][2]*z],[R[0][0]*N[0]+R[0][1]*N[1]+R[0][2]*N[2],R[1][0]*N[0]+R[1][1]*N[1]+R[1][2]*N[2],R[2][0]*N[0]+R[2][1]*N[1]+R[2][2]*N[2]])},1t:l(a){o(a.W){9 A=7.K.4,N=7.W.4;9 b=A[0],18=A[1],1a=A[2],2M=N[0],2L=N[1],2Q=N[2];9 c=7.K.1t(a).4;9 d=b+2M,2p=18+2L,2m=1a+2Q;9 Q=a.1r([d,2p,2m]).4;9 e=[Q[0]+(Q[0]-d)-c[0],Q[1]+(Q[1]-2p)-c[1],Q[2]+(Q[2]-2m)-c[2]];8 11.u(c,e)}1d o(a.U){8 7.1V(F.1A,a)}1d{9 P=a.4||a;8 11.u(7.K.1t([P[0],P[1],(P[2]||0)]),7.W)}},1Z:l(a,b,c){a=v.u(a);a=a.1N();o(a===w){8 w}b=v.u(b);b=b.1N();o(b===w){8 w}o(1g(c)==\'1f\'){c=w}1d{c=v.u(c);c=c.1N();o(c===w){8 w}}9 d=a.4[0],18=a.4[1],1a=a.4[2];9 e=b.4[0],1W=b.4[1],1X=b.4[2];9 f,1i;o(c!==w){9 g=c.4[0],2l=c.4[1],2t=c.4[2];f=v.u([(1W-18)*(2t-1a)-(1X-1a)*(2l-18),(1X-1a)*(g-d)-(e-d)*(2t-1a),(e-d)*(2l-18)-(1W-18)*(g-d)]);1i=f.1u();o(1i===0){8 w}f=v.u([f.4[0]/1i,f.4[1]/1i,f.4[2]/1i])}1d{1i=F.1x(e*e+1W*1W+1X*1X);o(1i===0){8 w}f=v.u([b.4[0]/1i,b.4[1]/1i,b.4[2]/1i])}7.K=a;7.W=f;8 7}};11.u=l(a,b,c){9 P=25 11();8 P.1Z(a,b,c)};11.2I=11.u(v.1j(3),v.k);11.2H=11.u(v.1j(3),v.i);11.2G=11.u(v.1j(3),v.j);11.36=11.2I;11.35=11.2H;11.3j=11.2G;9 $V=v.u;9 $M=S.u;9 $L=14.u;9 $P=11.u;',62,206,'||||elements|||this|return|var||||||||||||function|||if||length||||create|Vector|null|||||||||Math|nj|while||do|anchor||||||||Matrix||direction||normal||||kj|Plane|ni|abs|Line|ki|precision|Sylvester|A2|push|A3|map|els|else||undefined|typeof|contains|mod|Zero|D3|D2|isParallelTo|kp|distanceFrom|cols|dup|pointClosestTo|np|reflectionIn|modulus|intersects|A1|sqrt|isSquare|X2|PI|X3|angleFrom|mod1|C2|mod2|sin|cos|break|C3|toRightTriangular|false|Y3|to3D|E2|E1|E3|Rotation|Y2|Y1|intersectionWith|rotate|v12|v13|rank|setVectors|nc|sum|multiply|prototype|eql|new|setElements|case|each|PA3|PA2|part|new_element|round|for|cross|product|AD2|isSameSizeAs|add|isPerpendicularTo|v22|AN3|inspect|AD3|AN2|toUnitVector|PsubQ3|PsubQ2|v23|dot|divisor|inverse|true|isSingular|determinant|max|canMultiplyFromLeft|subtract|rows|col|random|ZX|YZ|XY|Random|join|N2|N1|D1|slice|default|N3|dimensions|switch|liesIn|translate|snapTo|augment|Diagonal|trace|indexOf|diagonal|transpose|minor|row|isAntiparallelTo|ZY|YX|acos|RotationZ|RotationY|liesOn|RotationX|inv|rk|tr|det|toDiagonalMatrix|toUpperTriangular|version|XZ'.split('|'),0,{}))
"use strict"; 
// augment Sylvester some
Matrix.Translation = function (v) {
  var r;
  if (v.elements.length === 2) {
    r = Matrix.I(3);
    r.elements[2][0] = v.elements[0];
    r.elements[2][1] = v.elements[1];
    return r;
  }

  if (v.elements.length === 3) {
    r = Matrix.I(4);
    r.elements[0][3] = v.elements[0];
    r.elements[1][3] = v.elements[1];
    r.elements[2][3] = v.elements[2];
    return r;
  }

  throw "Invalid length for Translation";
};

Matrix.prototype.flatten = function () {
  var result = [];
  if (this.elements.length === 0)
    return [];

  for (var j = 0; j < this.elements[0].length; j++)
    for (var i = 0; i < this.elements.length; i++)
      result.push(this.elements[i][j]);

  return result;
};

Matrix.prototype.ensure4x4 = function () {
  var i;
  if (this.elements.length === 4 && this.elements[0].length === 4)
    return this;

  if (this.elements.length > 4 || this.elements[0].length > 4)
    return null;

  for (i = 0; i < this.elements.length; i++) {
    for (var j = this.elements[i].length; j < 4; j++) {
      if (i === j)
        this.elements[i].push(1);
      else
        this.elements[i].push(0);
    }
  }

  for (i = this.elements.length; i < 4; i++) {
    if (i === 0)
      this.elements.push([1, 0, 0, 0]);
    else if (i === 1)
      this.elements.push([0, 1, 0, 0]);
    else if (i === 2)
      this.elements.push([0, 0, 1, 0]);
    else if (i === 3)
      this.elements.push([0, 0, 0, 1]);
  }

  return this;
};

Matrix.prototype.make3x3 = function () {
  if (this.elements.length !== 4 || this.elements[0].length !== 4)
    return null;

  return Matrix.create([[this.elements[0][0], this.elements[0][1], this.elements[0][2]],
                       [this.elements[1][0], this.elements[1][1], this.elements[1][2]],
                       [this.elements[2][0], this.elements[2][1], this.elements[2][2]]]);
};

Vector.prototype.flatten = function () {
  return this.elements;
};

function mht(m) {
  var s = "", i;
  if (m.length === 16) {
    for (i = 0; i < 4; i++) {
      s += "<span style='font-family: monospace'>[" + m[i * 4 + 0].toFixed(4) + "," + m[i * 4 + 1].toFixed(4) + "," + m[i * 4 + 2].toFixed(4) + "," + m[i * 4 + 3].toFixed(4) + "]</span><br>";
    }
  } else if (m.length === 9) {
    for (i = 0; i < 3; i++) {
      s += "<span style='font-family: monospace'>[" + m[i * 3 + 0].toFixed(4) + "," + m[i * 3 + 1].toFixed(4) + "," + m[i * 3 + 2].toFixed(4) + "]</font><br>";
    }
  } else {
    return m.toString();
  }
  return s;
}

// gluLookAt
function makeLookAt(ex, ey, ez, cx, cy, cz, ux, uy, uz) {
  var eye = $V([ex, ey, ez]);
  var center = $V([cx, cy, cz]);
  var up = $V([ux, uy, uz]);
  var mag;
  var z = eye.subtract(center).toUnitVector();
  var x = up.cross(z).toUnitVector();
  var y = z.cross(x).toUnitVector();
  var m = $M([[x.e(1), x.e(2), x.e(3), 0],
              [y.e(1), y.e(2), y.e(3), 0],
              [z.e(1), z.e(2), z.e(3), 0],
              [0, 0, 0, 1]]);

  var t = $M([[1, 0, 0, -ex],
              [0, 1, 0, -ey],
              [0, 0, 1, -ez],
              [0, 0, 0, 1]]);

  return m.x(t);
}

// glOrtho
function makeOrtho(left, right, bottom, top, znear, zfar) {
  var tx = -(right + left) / (right - left);
  var ty = -(top + bottom) / (top - bottom);
  var tz = -(zfar + znear) / (zfar - znear);

  return $M([[2 / (right - left), 0, 0, tx],
             [0, 2 / (top - bottom), 0, ty],
             [0, 0, -2 / (zfar - znear), tz],
             [0, 0, 0, 1]]);
}

// glFrustum
function makeFrustum(left, right, bottom, top, znear, zfar) {
  var X = 2 * znear / (right - left);
  var Y = 2 * znear / (top - bottom);
  var A = (right + left) / (right - left);
  var B = (top + bottom) / (top - bottom);
  var C = -(zfar + znear) / (zfar - znear);
  var D = -2 * zfar * znear / (zfar - znear);

  return $M([[X, 0, A, 0],
             [0, Y, B, 0],
             [0, 0, C, D],
             [0, 0, -1, 0]]);
}

// gluPerspective
function makePerspective(fovy, aspect, znear, zfar) {
  var ymax = znear * Math.tan(fovy * Math.PI / 360.0);
  var ymin = -ymax;
  var xmin = ymin * aspect;
  var xmax = ymax * aspect;

  return makeFrustum(xmin, xmax, ymin, ymax, znear, zfar);
}
/*global self */
/*jslint bitwise: true, indent: 4, laxbreak: true, laxcomma: true, smarttabs: true, plusplus: true */

/*! @source http://purl.eligrey.com/github/FileSaver.js/blob/master/FileSaver.js */

var saveAs = saveAs || (function(view) {
	"use strict";
	// IE <10 is explicitly unsupported
	if (typeof view === "undefined" || typeof navigator !== "undefined" && /MSIE [1-9]\./.test(navigator.userAgent)) {
		return;
	}
	var
		  doc = view.document
		  // only get URL when necessary in case Blob.js hasn't overridden it yet
		, get_URL = function() {
			return view.URL || view.webkitURL || view;
		}
		, save_link = doc.createElementNS("http://www.w3.org/1999/xhtml", "a")
		, can_use_save_link = "download" in save_link
		, click = function(node) {
			var event = new MouseEvent("click");
			node.dispatchEvent(event);
		}
		, is_safari = /constructor/i.test(view.HTMLElement)
		, is_chrome_ios =/CriOS\/[\d]+/.test(navigator.userAgent)
		, throw_outside = function(ex) {
			(view.setImmediate || view.setTimeout)(function() {
				throw ex;
			}, 0);
		}
		, force_saveable_type = "application/octet-stream"
		// the Blob API is fundamentally broken as there is no "downloadfinished" event to subscribe to
		, arbitrary_revoke_timeout = 1000 * 40 // in ms
		, revoke = function(file) {
			var revoker = function() {
				if (typeof file === "string") { // file is an object URL
					get_URL().revokeObjectURL(file);
				} else { // file is a File
					file.remove();
				}
			};
			setTimeout(revoker, arbitrary_revoke_timeout);
		}
		, dispatch = function(filesaver, event_types, event) {
			event_types = [].concat(event_types);
			var i = event_types.length;
			while (i--) {
				var listener = filesaver["on" + event_types[i]];
				if (typeof listener === "function") {
					try {
						listener.call(filesaver, event || filesaver);
					} catch (ex) {
						throw_outside(ex);
					}
				}
			}
		}
		, auto_bom = function(blob) {
			// prepend BOM for UTF-8 XML and text/* types (including HTML)
			// note: your browser will automatically convert UTF-16 U+FEFF to EF BB BF
			if (/^\s*(?:text\/\S*|application\/xml|\S*\/\S*\+xml)\s*;.*charset\s*=\s*utf-8/i.test(blob.type)) {
				return new Blob([String.fromCharCode(0xFEFF), blob], {type: blob.type});
			}
			return blob;
		}
		, FileSaver = function(blob, name, no_auto_bom) {
			if (!no_auto_bom) {
				blob = auto_bom(blob);
			}
			// First try a.download, then web filesystem, then object URLs
			var
				  filesaver = this
				, type = blob.type
				, force = type === force_saveable_type
				, object_url
				, dispatch_all = function() {
					dispatch(filesaver, "writestart progress write writeend".split(" "));
				}
				// on any filesys errors revert to saving with object URLs
				, fs_error = function() {
					if ((is_chrome_ios || (force && is_safari)) && view.FileReader) {
						// Safari doesn't allow downloading of blob urls
						var reader = new FileReader();
						reader.onloadend = function() {
							var url = is_chrome_ios ? reader.result : reader.result.replace(/^data:[^;]*;/, 'data:attachment/file;');
							var popup = view.open(url, '_blank');
							if(!popup) view.location.href = url;
							url=undefined; // release reference before dispatching
							filesaver.readyState = filesaver.DONE;
							dispatch_all();
						};
						reader.readAsDataURL(blob);
						filesaver.readyState = filesaver.INIT;
						return;
					}
					// don't create more object URLs than needed
					if (!object_url) {
						object_url = get_URL().createObjectURL(blob);
					}
					if (force) {
						view.location.href = object_url;
					} else {
						var opened = view.open(object_url, "_blank");
						if (!opened) {
							// Apple does not allow window.open, see https://developer.apple.com/library/safari/documentation/Tools/Conceptual/SafariExtensionGuide/WorkingwithWindowsandTabs/WorkingwithWindowsandTabs.html
							view.location.href = object_url;
						}
					}
					filesaver.readyState = filesaver.DONE;
					dispatch_all();
					revoke(object_url);
				}
			;
			filesaver.readyState = filesaver.INIT;

			if (can_use_save_link) {
				object_url = get_URL().createObjectURL(blob);
				setTimeout(function() {
					save_link.href = object_url;
					save_link.download = name;
					click(save_link);
					dispatch_all();
					revoke(object_url);
					filesaver.readyState = filesaver.DONE;
				});
				return;
			}

			fs_error();
		}
		, FS_proto = FileSaver.prototype
		, saveAs = function(blob, name, no_auto_bom) {
			return new FileSaver(blob, name || blob.name || "download", no_auto_bom);
		}
	;
	// IE 10+ (native saveAs)
	if (typeof navigator !== "undefined" && navigator.msSaveOrOpenBlob) {
		return function(blob, name, no_auto_bom) {
			name = name || blob.name || "download";

			if (!no_auto_bom) {
				blob = auto_bom(blob);
			}
			return navigator.msSaveOrOpenBlob(blob, name);
		};
	}

	FS_proto.abort = function(){};
	FS_proto.readyState = FS_proto.INIT = 0;
	FS_proto.WRITING = 1;
	FS_proto.DONE = 2;

	FS_proto.error =
	FS_proto.onwritestart =
	FS_proto.onprogress =
	FS_proto.onwrite =
	FS_proto.onabort =
	FS_proto.onerror =
	FS_proto.onwriteend =
		null;

	return saveAs;
}(
	   typeof self !== "undefined" && self
	|| typeof window !== "undefined" && window
	|| this.content
));
// `self` is undefined in Firefox for Android content script context
// while `this` is nsIContentFrameMessageManager
// with an attribute `content` that corresponds to the window

if (typeof module !== "undefined" && module.exports) {
  module.exports.saveAs = saveAs;
} else if ((typeof define !== "undefined" && define !== null) && (define.amd !== null)) {
  define([], function() {
    return saveAs;
  });
}

(function(factory,root){if(typeof define=="function"&&define.amd){define(factory);}else if(typeof module!="undefined"&&typeof exports=="object"){module.exports=factory();}else{root.log4javascript=factory();}})(function(){if(!Array.prototype.push){Array.prototype.push=function(){for(var i=0,len=arguments.length;i<len;i++){this[this.length]=arguments[i];}
return this.length;};}
if(!Array.prototype.shift){Array.prototype.shift=function(){if(this.length>0){var firstItem=this[0];for(var i=0,len=this.length-1;i<len;i++){this[i]=this[i+1];}
this.length=this.length-1;return firstItem;}};}
if(!Array.prototype.splice){Array.prototype.splice=function(startIndex,deleteCount){var itemsAfterDeleted=this.slice(startIndex+deleteCount);var itemsDeleted=this.slice(startIndex,startIndex+deleteCount);this.length=startIndex;var argumentsArray=[];for(var i=0,len=arguments.length;i<len;i++){argumentsArray[i]=arguments[i];}
var itemsToAppend=(argumentsArray.length>2)?itemsAfterDeleted=argumentsArray.slice(2).concat(itemsAfterDeleted):itemsAfterDeleted;for(i=0,len=itemsToAppend.length;i<len;i++){this.push(itemsToAppend[i]);}
return itemsDeleted;};}
function isUndefined(obj){return typeof obj=="undefined";}
function EventSupport(){}
EventSupport.prototype={eventTypes:[],eventListeners:{},setEventTypes:function(eventTypesParam){if(eventTypesParam instanceof Array){this.eventTypes=eventTypesParam;this.eventListeners={};for(var i=0,len=this.eventTypes.length;i<len;i++){this.eventListeners[this.eventTypes[i]]=[];}}else{handleError("log4javascript.EventSupport ["+this+"]: setEventTypes: eventTypes parameter must be an Array");}},addEventListener:function(eventType,listener){if(typeof listener=="function"){if(!array_contains(this.eventTypes,eventType)){handleError("log4javascript.EventSupport ["+this+"]: addEventListener: no event called '"+eventType+"'");}
this.eventListeners[eventType].push(listener);}else{handleError("log4javascript.EventSupport ["+this+"]: addEventListener: listener must be a function");}},removeEventListener:function(eventType,listener){if(typeof listener=="function"){if(!array_contains(this.eventTypes,eventType)){handleError("log4javascript.EventSupport ["+this+"]: removeEventListener: no event called '"+eventType+"'");}
array_remove(this.eventListeners[eventType],listener);}else{handleError("log4javascript.EventSupport ["+this+"]: removeEventListener: listener must be a function");}},dispatchEvent:function(eventType,eventArgs){if(array_contains(this.eventTypes,eventType)){var listeners=this.eventListeners[eventType];for(var i=0,len=listeners.length;i<len;i++){listeners[i](this,eventType,eventArgs);}}else{handleError("log4javascript.EventSupport ["+this+"]: dispatchEvent: no event called '"+eventType+"'");}}};var applicationStartDate=new Date();var uniqueId="log4javascript_"+applicationStartDate.getTime()+"_"+
Math.floor(Math.random()*100000000);var emptyFunction=function(){};var newLine="\r\n";var pageLoaded=false;function Log4JavaScript(){}
Log4JavaScript.prototype=new EventSupport();var log4javascript=new Log4JavaScript();log4javascript.version="1.4.13";log4javascript.edition="log4javascript";function toStr(obj){if(obj&&obj.toString){return obj.toString();}else{return String(obj);}}
function getExceptionMessage(ex){if(ex.message){return ex.message;}else if(ex.description){return ex.description;}else{return toStr(ex);}}
function getUrlFileName(url){var lastSlashIndex=Math.max(url.lastIndexOf("/"),url.lastIndexOf("\\"));return url.substr(lastSlashIndex+1);}
function getExceptionStringRep(ex){if(ex){var exStr="Exception: "+getExceptionMessage(ex);try{if(ex.lineNumber){exStr+=" on line number "+ex.lineNumber;}
if(ex.fileName){exStr+=" in file "+getUrlFileName(ex.fileName);}}catch(localEx){logLog.warn("Unable to obtain file and line information for error");}
if(showStackTraces&&ex.stack){exStr+=newLine+"Stack trace:"+newLine+ex.stack;}
return exStr;}
return null;}
function bool(obj){return Boolean(obj);}
function trim(str){return str.replace(/^\s+/,"").replace(/\s+$/,"");}
function splitIntoLines(text){var text2=text.replace(/\r\n/g,"\n").replace(/\r/g,"\n");return text2.split("\n");}
var urlEncode=(typeof window.encodeURIComponent!="undefined")?function(str){return encodeURIComponent(str);}:function(str){return escape(str).replace(/\+/g,"%2B").replace(/"/g,"%22").replace(/'/g,"%27").replace(/\//g,"%2F").replace(/=/g,"%3D");};function array_remove(arr,val){var index=-1;for(var i=0,len=arr.length;i<len;i++){if(arr[i]===val){index=i;break;}}
if(index>=0){arr.splice(index,1);return true;}else{return false;}}
function array_contains(arr,val){for(var i=0,len=arr.length;i<len;i++){if(arr[i]==val){return true;}}
return false;}
function extractBooleanFromParam(param,defaultValue){if(isUndefined(param)){return defaultValue;}else{return bool(param);}}
function extractStringFromParam(param,defaultValue){if(isUndefined(param)){return defaultValue;}else{return String(param);}}
function extractIntFromParam(param,defaultValue){if(isUndefined(param)){return defaultValue;}else{try{var value=parseInt(param,10);return isNaN(value)?defaultValue:value;}catch(ex){logLog.warn("Invalid int param "+param,ex);return defaultValue;}}}
function extractFunctionFromParam(param,defaultValue){if(typeof param=="function"){return param;}else{return defaultValue;}}
function isError(err){return(err instanceof Error);}
if(!Function.prototype.apply){Function.prototype.apply=function(obj,args){var methodName="__apply__";if(typeof obj[methodName]!="undefined"){methodName+=String(Math.random()).substr(2);}
obj[methodName]=this;var argsStrings=[];for(var i=0,len=args.length;i<len;i++){argsStrings[i]="args["+i+"]";}
var script="obj."+methodName+"("+argsStrings.join(",")+")";var returnValue=eval(script);delete obj[methodName];return returnValue;};}
if(!Function.prototype.call){Function.prototype.call=function(obj){var args=[];for(var i=1,len=arguments.length;i<len;i++){args[i-1]=arguments[i];}
return this.apply(obj,args);};}
var logLog={quietMode:false,debugMessages:[],setQuietMode:function(quietMode){this.quietMode=bool(quietMode);},numberOfErrors:0,alertAllErrors:false,setAlertAllErrors:function(alertAllErrors){this.alertAllErrors=alertAllErrors;},debug:function(message){this.debugMessages.push(message);},displayDebug:function(){alert(this.debugMessages.join(newLine));},warn:function(message,exception){},error:function(message,exception){if(++this.numberOfErrors==1||this.alertAllErrors){if(!this.quietMode){var alertMessage="log4javascript error: "+message;if(exception){alertMessage+=newLine+newLine+"Original error: "+getExceptionStringRep(exception);}
alert(alertMessage);}}}};log4javascript.logLog=logLog;log4javascript.setEventTypes(["load","error"]);function handleError(message,exception){logLog.error(message,exception);log4javascript.dispatchEvent("error",{"message":message,"exception":exception});}
log4javascript.handleError=handleError;var enabled=!((typeof log4javascript_disabled!="undefined")&&log4javascript_disabled);log4javascript.setEnabled=function(enable){enabled=bool(enable);};log4javascript.isEnabled=function(){return enabled;};var useTimeStampsInMilliseconds=true;log4javascript.setTimeStampsInMilliseconds=function(timeStampsInMilliseconds){useTimeStampsInMilliseconds=bool(timeStampsInMilliseconds);};log4javascript.isTimeStampsInMilliseconds=function(){return useTimeStampsInMilliseconds;};log4javascript.evalInScope=function(expr){return eval(expr);};var showStackTraces=false;log4javascript.setShowStackTraces=function(show){showStackTraces=bool(show);};var Level=function(level,name){this.level=level;this.name=name;};Level.prototype={toString:function(){return this.name;},equals:function(level){return this.level==level.level;},isGreaterOrEqual:function(level){return this.level>=level.level;}};Level.ALL=new Level(Number.MIN_VALUE,"ALL");Level.TRACE=new Level(10000,"TRACE");Level.DEBUG=new Level(20000,"DEBUG");Level.INFO=new Level(30000,"INFO");Level.WARN=new Level(40000,"WARN");Level.ERROR=new Level(50000,"ERROR");Level.FATAL=new Level(60000,"FATAL");Level.OFF=new Level(Number.MAX_VALUE,"OFF");log4javascript.Level=Level;function Timer(name,level){this.name=name;this.level=isUndefined(level)?Level.INFO:level;this.start=new Date();}
Timer.prototype.getElapsedTime=function(){return new Date().getTime()-this.start.getTime();};var anonymousLoggerName="[anonymous]";var defaultLoggerName="[default]";var nullLoggerName="[null]";var rootLoggerName="root";function Logger(name){this.name=name;this.parent=null;this.children=[];var appenders=[];var loggerLevel=null;var isRoot=(this.name===rootLoggerName);var isNull=(this.name===nullLoggerName);var appenderCache=null;var appenderCacheInvalidated=false;this.addChild=function(childLogger){this.children.push(childLogger);childLogger.parent=this;childLogger.invalidateAppenderCache();};var additive=true;this.getAdditivity=function(){return additive;};this.setAdditivity=function(additivity){var valueChanged=(additive!=additivity);additive=additivity;if(valueChanged){this.invalidateAppenderCache();}};this.addAppender=function(appender){if(isNull){handleError("Logger.addAppender: you may not add an appender to the null logger");}else{if(appender instanceof log4javascript.Appender){if(!array_contains(appenders,appender)){appenders.push(appender);appender.setAddedToLogger(this);this.invalidateAppenderCache();}}else{handleError("Logger.addAppender: appender supplied ('"+
toStr(appender)+"') is not a subclass of Appender");}}};this.removeAppender=function(appender){array_remove(appenders,appender);appender.setRemovedFromLogger(this);this.invalidateAppenderCache();};this.removeAllAppenders=function(){var appenderCount=appenders.length;if(appenderCount>0){for(var i=0;i<appenderCount;i++){appenders[i].setRemovedFromLogger(this);}
appenders.length=0;this.invalidateAppenderCache();}};this.getEffectiveAppenders=function(){if(appenderCache===null||appenderCacheInvalidated){var parentEffectiveAppenders=(isRoot||!this.getAdditivity())?[]:this.parent.getEffectiveAppenders();appenderCache=parentEffectiveAppenders.concat(appenders);appenderCacheInvalidated=false;}
return appenderCache;};this.invalidateAppenderCache=function(){appenderCacheInvalidated=true;for(var i=0,len=this.children.length;i<len;i++){this.children[i].invalidateAppenderCache();}};this.log=function(level,params){if(enabled&&level.isGreaterOrEqual(this.getEffectiveLevel())){var exception;var finalParamIndex=params.length-1;var lastParam=params[finalParamIndex];if(params.length>1&&isError(lastParam)){exception=lastParam;finalParamIndex--;}
var messages=[];for(var i=0;i<=finalParamIndex;i++){messages[i]=params[i];}
var loggingEvent=new LoggingEvent(this,new Date(),level,messages,exception);this.callAppenders(loggingEvent);}};this.callAppenders=function(loggingEvent){var effectiveAppenders=this.getEffectiveAppenders();for(var i=0,len=effectiveAppenders.length;i<len;i++){effectiveAppenders[i].doAppend(loggingEvent);}};this.setLevel=function(level){if(isRoot&&level===null){handleError("Logger.setLevel: you cannot set the level of the root logger to null");}else if(level instanceof Level){loggerLevel=level;}else{handleError("Logger.setLevel: level supplied to logger "+
this.name+" is not an instance of log4javascript.Level");}};this.getLevel=function(){return loggerLevel;};this.getEffectiveLevel=function(){for(var logger=this;logger!==null;logger=logger.parent){var level=logger.getLevel();if(level!==null){return level;}}};this.group=function(name,initiallyExpanded){if(enabled){var effectiveAppenders=this.getEffectiveAppenders();for(var i=0,len=effectiveAppenders.length;i<len;i++){effectiveAppenders[i].group(name,initiallyExpanded);}}};this.groupEnd=function(){if(enabled){var effectiveAppenders=this.getEffectiveAppenders();for(var i=0,len=effectiveAppenders.length;i<len;i++){effectiveAppenders[i].groupEnd();}}};var timers={};this.time=function(name,level){if(enabled){if(isUndefined(name)){handleError("Logger.time: a name for the timer must be supplied");}else if(level&&!(level instanceof Level)){handleError("Logger.time: level supplied to timer "+
name+" is not an instance of log4javascript.Level");}else{timers[name]=new Timer(name,level);}}};this.timeEnd=function(name){if(enabled){if(isUndefined(name)){handleError("Logger.timeEnd: a name for the timer must be supplied");}else if(timers[name]){var timer=timers[name];var milliseconds=timer.getElapsedTime();this.log(timer.level,["Timer "+toStr(name)+" completed in "+milliseconds+"ms"]);delete timers[name];}else{logLog.warn("Logger.timeEnd: no timer found with name "+name);}}};this.assert=function(expr){if(enabled&&!expr){var args=[];for(var i=1,len=arguments.length;i<len;i++){args.push(arguments[i]);}
args=(args.length>0)?args:["Assertion Failure"];args.push(newLine);args.push(expr);this.log(Level.ERROR,args);}};this.toString=function(){return"Logger["+this.name+"]";};}
Logger.prototype={trace:function(){this.log(Level.TRACE,arguments);},debug:function(){this.log(Level.DEBUG,arguments);},info:function(){this.log(Level.INFO,arguments);},warn:function(){this.log(Level.WARN,arguments);},error:function(){this.log(Level.ERROR,arguments);},fatal:function(){this.log(Level.FATAL,arguments);},isEnabledFor:function(level){return level.isGreaterOrEqual(this.getEffectiveLevel());},isTraceEnabled:function(){return this.isEnabledFor(Level.TRACE);},isDebugEnabled:function(){return this.isEnabledFor(Level.DEBUG);},isInfoEnabled:function(){return this.isEnabledFor(Level.INFO);},isWarnEnabled:function(){return this.isEnabledFor(Level.WARN);},isErrorEnabled:function(){return this.isEnabledFor(Level.ERROR);},isFatalEnabled:function(){return this.isEnabledFor(Level.FATAL);}};Logger.prototype.trace.isEntryPoint=true;Logger.prototype.debug.isEntryPoint=true;Logger.prototype.info.isEntryPoint=true;Logger.prototype.warn.isEntryPoint=true;Logger.prototype.error.isEntryPoint=true;Logger.prototype.fatal.isEntryPoint=true;var loggers={};var loggerNames=[];var ROOT_LOGGER_DEFAULT_LEVEL=Level.DEBUG;var rootLogger=new Logger(rootLoggerName);rootLogger.setLevel(ROOT_LOGGER_DEFAULT_LEVEL);log4javascript.getRootLogger=function(){return rootLogger;};log4javascript.getLogger=function(loggerName){if(typeof loggerName!="string"){loggerName=anonymousLoggerName;logLog.warn("log4javascript.getLogger: non-string logger name "+
toStr(loggerName)+" supplied, returning anonymous logger");}
if(loggerName==rootLoggerName){handleError("log4javascript.getLogger: root logger may not be obtained by name");}
if(!loggers[loggerName]){var logger=new Logger(loggerName);loggers[loggerName]=logger;loggerNames.push(loggerName);var lastDotIndex=loggerName.lastIndexOf(".");var parentLogger;if(lastDotIndex>-1){var parentLoggerName=loggerName.substring(0,lastDotIndex);parentLogger=log4javascript.getLogger(parentLoggerName);}else{parentLogger=rootLogger;}
parentLogger.addChild(logger);}
return loggers[loggerName];};var defaultLogger=null;log4javascript.getDefaultLogger=function(){if(!defaultLogger){defaultLogger=createDefaultLogger();}
return defaultLogger;};var nullLogger=null;log4javascript.getNullLogger=function(){if(!nullLogger){nullLogger=new Logger(nullLoggerName);nullLogger.setLevel(Level.OFF);}
return nullLogger;};log4javascript.resetConfiguration=function(){rootLogger.setLevel(ROOT_LOGGER_DEFAULT_LEVEL);loggers={};};var LoggingEvent=function(logger,timeStamp,level,messages,exception){this.logger=logger;this.timeStamp=timeStamp;this.timeStampInMilliseconds=timeStamp.getTime();this.timeStampInSeconds=Math.floor(this.timeStampInMilliseconds/1000);this.milliseconds=this.timeStamp.getMilliseconds();this.level=level;this.messages=messages;this.exception=exception;};LoggingEvent.prototype={getThrowableStrRep:function(){return this.exception?getExceptionStringRep(this.exception):"";},getCombinedMessages:function(){return(this.messages.length==1)?this.messages[0]:this.messages.join(newLine);},toString:function(){return"LoggingEvent["+this.level+"]";}};log4javascript.LoggingEvent=LoggingEvent;var Layout=function(){};Layout.prototype={defaults:{loggerKey:"logger",timeStampKey:"timestamp",millisecondsKey:"milliseconds",levelKey:"level",messageKey:"message",exceptionKey:"exception",urlKey:"url"},loggerKey:"logger",timeStampKey:"timestamp",millisecondsKey:"milliseconds",levelKey:"level",messageKey:"message",exceptionKey:"exception",urlKey:"url",batchHeader:"",batchFooter:"",batchSeparator:"",returnsPostData:false,overrideTimeStampsSetting:false,useTimeStampsInMilliseconds:null,format:function(){handleError("Layout.format: layout supplied has no format() method");},ignoresThrowable:function(){handleError("Layout.ignoresThrowable: layout supplied has no ignoresThrowable() method");},getContentType:function(){return"text/plain";},allowBatching:function(){return true;},setTimeStampsInMilliseconds:function(timeStampsInMilliseconds){this.overrideTimeStampsSetting=true;this.useTimeStampsInMilliseconds=bool(timeStampsInMilliseconds);},isTimeStampsInMilliseconds:function(){return this.overrideTimeStampsSetting?this.useTimeStampsInMilliseconds:useTimeStampsInMilliseconds;},getTimeStampValue:function(loggingEvent){return this.isTimeStampsInMilliseconds()?loggingEvent.timeStampInMilliseconds:loggingEvent.timeStampInSeconds;},getDataValues:function(loggingEvent,combineMessages){var dataValues=[[this.loggerKey,loggingEvent.logger.name],[this.timeStampKey,this.getTimeStampValue(loggingEvent)],[this.levelKey,loggingEvent.level.name],[this.urlKey,window.location.href],[this.messageKey,combineMessages?loggingEvent.getCombinedMessages():loggingEvent.messages]];if(!this.isTimeStampsInMilliseconds()){dataValues.push([this.millisecondsKey,loggingEvent.milliseconds]);}
if(loggingEvent.exception){dataValues.push([this.exceptionKey,getExceptionStringRep(loggingEvent.exception)]);}
if(this.hasCustomFields()){for(var i=0,len=this.customFields.length;i<len;i++){var val=this.customFields[i].value;if(typeof val==="function"){val=val(this,loggingEvent);}
dataValues.push([this.customFields[i].name,val]);}}
return dataValues;},setKeys:function(loggerKey,timeStampKey,levelKey,messageKey,exceptionKey,urlKey,millisecondsKey){this.loggerKey=extractStringFromParam(loggerKey,this.defaults.loggerKey);this.timeStampKey=extractStringFromParam(timeStampKey,this.defaults.timeStampKey);this.levelKey=extractStringFromParam(levelKey,this.defaults.levelKey);this.messageKey=extractStringFromParam(messageKey,this.defaults.messageKey);this.exceptionKey=extractStringFromParam(exceptionKey,this.defaults.exceptionKey);this.urlKey=extractStringFromParam(urlKey,this.defaults.urlKey);this.millisecondsKey=extractStringFromParam(millisecondsKey,this.defaults.millisecondsKey);},setCustomField:function(name,value){var fieldUpdated=false;for(var i=0,len=this.customFields.length;i<len;i++){if(this.customFields[i].name===name){this.customFields[i].value=value;fieldUpdated=true;}}
if(!fieldUpdated){this.customFields.push({"name":name,"value":value});}},hasCustomFields:function(){return(this.customFields.length>0);},formatWithException:function(loggingEvent){var formatted=this.format(loggingEvent);if(loggingEvent.exception&&this.ignoresThrowable()){formatted+=loggingEvent.getThrowableStrRep();}
return formatted;},toString:function(){handleError("Layout.toString: all layouts must override this method");}};log4javascript.Layout=Layout;var Appender=function(){};Appender.prototype=new EventSupport();Appender.prototype.layout=new PatternLayout();Appender.prototype.threshold=Level.ALL;Appender.prototype.loggers=[];Appender.prototype.doAppend=function(loggingEvent){if(enabled&&loggingEvent.level.level>=this.threshold.level){this.append(loggingEvent);}};Appender.prototype.append=function(loggingEvent){};Appender.prototype.setLayout=function(layout){if(layout instanceof Layout){this.layout=layout;}else{handleError("Appender.setLayout: layout supplied to "+
this.toString()+" is not a subclass of Layout");}};Appender.prototype.getLayout=function(){return this.layout;};Appender.prototype.setThreshold=function(threshold){if(threshold instanceof Level){this.threshold=threshold;}else{handleError("Appender.setThreshold: threshold supplied to "+
this.toString()+" is not a subclass of Level");}};Appender.prototype.getThreshold=function(){return this.threshold;};Appender.prototype.setAddedToLogger=function(logger){this.loggers.push(logger);};Appender.prototype.setRemovedFromLogger=function(logger){array_remove(this.loggers,logger);};Appender.prototype.group=emptyFunction;Appender.prototype.groupEnd=emptyFunction;Appender.prototype.toString=function(){handleError("Appender.toString: all appenders must override this method");};log4javascript.Appender=Appender;function SimpleLayout(){this.customFields=[];}
SimpleLayout.prototype=new Layout();SimpleLayout.prototype.format=function(loggingEvent){return loggingEvent.level.name+" - "+loggingEvent.getCombinedMessages();};SimpleLayout.prototype.ignoresThrowable=function(){return true;};SimpleLayout.prototype.toString=function(){return"SimpleLayout";};log4javascript.SimpleLayout=SimpleLayout;function NullLayout(){this.customFields=[];}
NullLayout.prototype=new Layout();NullLayout.prototype.format=function(loggingEvent){return loggingEvent.messages;};NullLayout.prototype.ignoresThrowable=function(){return true;};NullLayout.prototype.formatWithException=function(loggingEvent){var messages=loggingEvent.messages,ex=loggingEvent.exception;return ex?messages.concat([ex]):messages;};NullLayout.prototype.toString=function(){return"NullLayout";};log4javascript.NullLayout=NullLayout;function XmlLayout(combineMessages){this.combineMessages=extractBooleanFromParam(combineMessages,true);this.customFields=[];}
XmlLayout.prototype=new Layout();XmlLayout.prototype.isCombinedMessages=function(){return this.combineMessages;};XmlLayout.prototype.getContentType=function(){return"text/xml";};XmlLayout.prototype.escapeCdata=function(str){return str.replace(/\]\]>/,"]]>]]&gt;<![CDATA[");};XmlLayout.prototype.format=function(loggingEvent){var layout=this;var i,len;function formatMessage(message){message=(typeof message==="string")?message:toStr(message);return"<log4javascript:message><![CDATA["+
layout.escapeCdata(message)+"]]></log4javascript:message>";}
var str="<log4javascript:event logger=\""+loggingEvent.logger.name+"\" timestamp=\""+this.getTimeStampValue(loggingEvent)+"\"";if(!this.isTimeStampsInMilliseconds()){str+=" milliseconds=\""+loggingEvent.milliseconds+"\"";}
str+=" level=\""+loggingEvent.level.name+"\">"+newLine;if(this.combineMessages){str+=formatMessage(loggingEvent.getCombinedMessages());}else{str+="<log4javascript:messages>"+newLine;for(i=0,len=loggingEvent.messages.length;i<len;i++){str+=formatMessage(loggingEvent.messages[i])+newLine;}
str+="</log4javascript:messages>"+newLine;}
if(this.hasCustomFields()){for(i=0,len=this.customFields.length;i<len;i++){str+="<log4javascript:customfield name=\""+
this.customFields[i].name+"\"><![CDATA["+
this.customFields[i].value.toString()+"]]></log4javascript:customfield>"+newLine;}}
if(loggingEvent.exception){str+="<log4javascript:exception><![CDATA["+
getExceptionStringRep(loggingEvent.exception)+"]]></log4javascript:exception>"+newLine;}
str+="</log4javascript:event>"+newLine+newLine;return str;};XmlLayout.prototype.ignoresThrowable=function(){return false;};XmlLayout.prototype.toString=function(){return"XmlLayout";};log4javascript.XmlLayout=XmlLayout;function escapeNewLines(str){return str.replace(/\r\n|\r|\n/g,"\\r\\n");}
function JsonLayout(readable,combineMessages){this.readable=extractBooleanFromParam(readable,false);this.combineMessages=extractBooleanFromParam(combineMessages,true);this.batchHeader=this.readable?"["+newLine:"[";this.batchFooter=this.readable?"]"+newLine:"]";this.batchSeparator=this.readable?","+newLine:",";this.setKeys();this.colon=this.readable?": ":":";this.tab=this.readable?"\t":"";this.lineBreak=this.readable?newLine:"";this.customFields=[];}
JsonLayout.prototype=new Layout();JsonLayout.prototype.isReadable=function(){return this.readable;};JsonLayout.prototype.isCombinedMessages=function(){return this.combineMessages;};JsonLayout.prototype.format=function(loggingEvent){var layout=this;var dataValues=this.getDataValues(loggingEvent,this.combineMessages);var str="{"+this.lineBreak;var i,len;function formatValue(val,prefix,expand){var formattedValue;var valType=typeof val;if(val instanceof Date){formattedValue=String(val.getTime());}else if(expand&&(val instanceof Array)){formattedValue="["+layout.lineBreak;for(var i=0,len=val.length;i<len;i++){var childPrefix=prefix+layout.tab;formattedValue+=childPrefix+formatValue(val[i],childPrefix,false);if(i<val.length-1){formattedValue+=",";}
formattedValue+=layout.lineBreak;}
formattedValue+=prefix+"]";}else if(valType!=="number"&&valType!=="boolean"){formattedValue="\""+escapeNewLines(toStr(val).replace(/\"/g,"\\\""))+"\"";}else{formattedValue=val;}
return formattedValue;}
for(i=0,len=dataValues.length-1;i<=len;i++){str+=this.tab+"\""+dataValues[i][0]+"\""+this.colon+formatValue(dataValues[i][1],this.tab,true);if(i<len){str+=",";}
str+=this.lineBreak;}
str+="}"+this.lineBreak;return str;};JsonLayout.prototype.ignoresThrowable=function(){return false;};JsonLayout.prototype.toString=function(){return"JsonLayout";};JsonLayout.prototype.getContentType=function(){return"application/json";};log4javascript.JsonLayout=JsonLayout;function HttpPostDataLayout(){this.setKeys();this.customFields=[];this.returnsPostData=true;}
HttpPostDataLayout.prototype=new Layout();HttpPostDataLayout.prototype.allowBatching=function(){return false;};HttpPostDataLayout.prototype.format=function(loggingEvent){var dataValues=this.getDataValues(loggingEvent);var queryBits=[];for(var i=0,len=dataValues.length;i<len;i++){var val=(dataValues[i][1]instanceof Date)?String(dataValues[i][1].getTime()):dataValues[i][1];queryBits.push(urlEncode(dataValues[i][0])+"="+urlEncode(val));}
return queryBits.join("&");};HttpPostDataLayout.prototype.ignoresThrowable=function(loggingEvent){return false;};HttpPostDataLayout.prototype.toString=function(){return"HttpPostDataLayout";};log4javascript.HttpPostDataLayout=HttpPostDataLayout;function formatObjectExpansion(obj,depth,indentation){var objectsExpanded=[];function doFormat(obj,depth,indentation){var i,len,childDepth,childIndentation,childLines,expansion,childExpansion;if(!indentation){indentation="";}
function formatString(text){var lines=splitIntoLines(text);for(var j=1,jLen=lines.length;j<jLen;j++){lines[j]=indentation+lines[j];}
return lines.join(newLine);}
if(obj===null){return"null";}else if(typeof obj=="undefined"){return"undefined";}else if(typeof obj=="string"){return formatString(obj);}else if(typeof obj=="object"&&array_contains(objectsExpanded,obj)){try{expansion=toStr(obj);}catch(ex){expansion="Error formatting property. Details: "+getExceptionStringRep(ex);}
return expansion+" [already expanded]";}else if((obj instanceof Array)&&depth>0){objectsExpanded.push(obj);expansion="["+newLine;childDepth=depth-1;childIndentation=indentation+"  ";childLines=[];for(i=0,len=obj.length;i<len;i++){try{childExpansion=doFormat(obj[i],childDepth,childIndentation);childLines.push(childIndentation+childExpansion);}catch(ex){childLines.push(childIndentation+"Error formatting array member. Details: "+
getExceptionStringRep(ex)+"");}}
expansion+=childLines.join(","+newLine)+newLine+indentation+"]";return expansion;}else if(Object.prototype.toString.call(obj)=="[object Date]"){return obj.toString();}else if(typeof obj=="object"&&depth>0){objectsExpanded.push(obj);expansion="{"+newLine;childDepth=depth-1;childIndentation=indentation+"  ";childLines=[];for(i in obj){try{childExpansion=doFormat(obj[i],childDepth,childIndentation);childLines.push(childIndentation+i+": "+childExpansion);}catch(ex){childLines.push(childIndentation+i+": Error formatting property. Details: "+
getExceptionStringRep(ex));}}
expansion+=childLines.join(","+newLine)+newLine+indentation+"}";return expansion;}else{return formatString(toStr(obj));}}
return doFormat(obj,depth,indentation);}
var SimpleDateFormat;(function(){var regex=/('[^']*')|(G+|y+|M+|w+|W+|D+|d+|F+|E+|a+|H+|k+|K+|h+|m+|s+|S+|Z+)|([a-zA-Z]+)|([^a-zA-Z']+)/;var monthNames=["January","February","March","April","May","June","July","August","September","October","November","December"];var dayNames=["Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"];var TEXT2=0,TEXT3=1,NUMBER=2,YEAR=3,MONTH=4,TIMEZONE=5;var types={G:TEXT2,y:YEAR,M:MONTH,w:NUMBER,W:NUMBER,D:NUMBER,d:NUMBER,F:NUMBER,E:TEXT3,a:TEXT2,H:NUMBER,k:NUMBER,K:NUMBER,h:NUMBER,m:NUMBER,s:NUMBER,S:NUMBER,Z:TIMEZONE};var ONE_DAY=24*60*60*1000;var ONE_WEEK=7*ONE_DAY;var DEFAULT_MINIMAL_DAYS_IN_FIRST_WEEK=1;var newDateAtMidnight=function(year,month,day){var d=new Date(year,month,day,0,0,0);d.setMilliseconds(0);return d;};Date.prototype.getDifference=function(date){return this.getTime()-date.getTime();};Date.prototype.isBefore=function(d){return this.getTime()<d.getTime();};Date.prototype.getUTCTime=function(){return Date.UTC(this.getFullYear(),this.getMonth(),this.getDate(),this.getHours(),this.getMinutes(),this.getSeconds(),this.getMilliseconds());};Date.prototype.getTimeSince=function(d){return this.getUTCTime()-d.getUTCTime();};Date.prototype.getPreviousSunday=function(){var midday=new Date(this.getFullYear(),this.getMonth(),this.getDate(),12,0,0);var previousSunday=new Date(midday.getTime()-this.getDay()*ONE_DAY);return newDateAtMidnight(previousSunday.getFullYear(),previousSunday.getMonth(),previousSunday.getDate());};Date.prototype.getWeekInYear=function(minimalDaysInFirstWeek){if(isUndefined(this.minimalDaysInFirstWeek)){minimalDaysInFirstWeek=DEFAULT_MINIMAL_DAYS_IN_FIRST_WEEK;}
var previousSunday=this.getPreviousSunday();var startOfYear=newDateAtMidnight(this.getFullYear(),0,1);var numberOfSundays=previousSunday.isBefore(startOfYear)?0:1+Math.floor(previousSunday.getTimeSince(startOfYear)/ONE_WEEK);var numberOfDaysInFirstWeek=7-startOfYear.getDay();var weekInYear=numberOfSundays;if(numberOfDaysInFirstWeek<minimalDaysInFirstWeek){weekInYear--;}
return weekInYear;};Date.prototype.getWeekInMonth=function(minimalDaysInFirstWeek){if(isUndefined(this.minimalDaysInFirstWeek)){minimalDaysInFirstWeek=DEFAULT_MINIMAL_DAYS_IN_FIRST_WEEK;}
var previousSunday=this.getPreviousSunday();var startOfMonth=newDateAtMidnight(this.getFullYear(),this.getMonth(),1);var numberOfSundays=previousSunday.isBefore(startOfMonth)?0:1+Math.floor(previousSunday.getTimeSince(startOfMonth)/ONE_WEEK);var numberOfDaysInFirstWeek=7-startOfMonth.getDay();var weekInMonth=numberOfSundays;if(numberOfDaysInFirstWeek>=minimalDaysInFirstWeek){weekInMonth++;}
return weekInMonth;};Date.prototype.getDayInYear=function(){var startOfYear=newDateAtMidnight(this.getFullYear(),0,1);return 1+Math.floor(this.getTimeSince(startOfYear)/ONE_DAY);};SimpleDateFormat=function(formatString){this.formatString=formatString;};SimpleDateFormat.prototype.setMinimalDaysInFirstWeek=function(days){this.minimalDaysInFirstWeek=days;};SimpleDateFormat.prototype.getMinimalDaysInFirstWeek=function(){return isUndefined(this.minimalDaysInFirstWeek)?DEFAULT_MINIMAL_DAYS_IN_FIRST_WEEK:this.minimalDaysInFirstWeek;};var padWithZeroes=function(str,len){while(str.length<len){str="0"+str;}
return str;};var formatText=function(data,numberOfLetters,minLength){return(numberOfLetters>=4)?data:data.substr(0,Math.max(minLength,numberOfLetters));};var formatNumber=function(data,numberOfLetters){var dataString=""+data;return padWithZeroes(dataString,numberOfLetters);};SimpleDateFormat.prototype.format=function(date){var formattedString="";var result;var searchString=this.formatString;while((result=regex.exec(searchString))){var quotedString=result[1];var patternLetters=result[2];var otherLetters=result[3];var otherCharacters=result[4];if(quotedString){if(quotedString=="''"){formattedString+="'";}else{formattedString+=quotedString.substring(1,quotedString.length-1);}}else if(otherLetters){}else if(otherCharacters){formattedString+=otherCharacters;}else if(patternLetters){var patternLetter=patternLetters.charAt(0);var numberOfLetters=patternLetters.length;var rawData="";switch(patternLetter){case"G":rawData="AD";break;case"y":rawData=date.getFullYear();break;case"M":rawData=date.getMonth();break;case"w":rawData=date.getWeekInYear(this.getMinimalDaysInFirstWeek());break;case"W":rawData=date.getWeekInMonth(this.getMinimalDaysInFirstWeek());break;case"D":rawData=date.getDayInYear();break;case"d":rawData=date.getDate();break;case"F":rawData=1+Math.floor((date.getDate()-1)/7);break;case"E":rawData=dayNames[date.getDay()];break;case"a":rawData=(date.getHours()>=12)?"PM":"AM";break;case"H":rawData=date.getHours();break;case"k":rawData=date.getHours()||24;break;case"K":rawData=date.getHours()%12;break;case"h":rawData=(date.getHours()%12)||12;break;case"m":rawData=date.getMinutes();break;case"s":rawData=date.getSeconds();break;case"S":rawData=date.getMilliseconds();break;case"Z":rawData=date.getTimezoneOffset();break;}
switch(types[patternLetter]){case TEXT2:formattedString+=formatText(rawData,numberOfLetters,2);break;case TEXT3:formattedString+=formatText(rawData,numberOfLetters,3);break;case NUMBER:formattedString+=formatNumber(rawData,numberOfLetters);break;case YEAR:if(numberOfLetters<=3){var dataString=""+rawData;formattedString+=dataString.substr(2,2);}else{formattedString+=formatNumber(rawData,numberOfLetters);}
break;case MONTH:if(numberOfLetters>=3){formattedString+=formatText(monthNames[rawData],numberOfLetters,numberOfLetters);}else{formattedString+=formatNumber(rawData+1,numberOfLetters);}
break;case TIMEZONE:var isPositive=(rawData>0);var prefix=isPositive?"-":"+";var absData=Math.abs(rawData);var hours=""+Math.floor(absData/60);hours=padWithZeroes(hours,2);var minutes=""+(absData%60);minutes=padWithZeroes(minutes,2);formattedString+=prefix+hours+minutes;break;}}
searchString=searchString.substr(result.index+result[0].length);}
return formattedString;};})();log4javascript.SimpleDateFormat=SimpleDateFormat;function PatternLayout(pattern){if(pattern){this.pattern=pattern;}else{this.pattern=PatternLayout.DEFAULT_CONVERSION_PATTERN;}
this.customFields=[];}
PatternLayout.TTCC_CONVERSION_PATTERN="%r %p %c - %m%n";PatternLayout.DEFAULT_CONVERSION_PATTERN="%m%n";PatternLayout.ISO8601_DATEFORMAT="yyyy-MM-dd HH:mm:ss,SSS";PatternLayout.DATETIME_DATEFORMAT="dd MMM yyyy HH:mm:ss,SSS";PatternLayout.ABSOLUTETIME_DATEFORMAT="HH:mm:ss,SSS";PatternLayout.prototype=new Layout();PatternLayout.prototype.format=function(loggingEvent){var regex=/%(-?[0-9]+)?(\.?[0-9]+)?([acdfmMnpr%])(\{([^\}]+)\})?|([^%]+)/;var formattedString="";var result;var searchString=this.pattern;while((result=regex.exec(searchString))){var matchedString=result[0];var padding=result[1];var truncation=result[2];var conversionCharacter=result[3];var specifier=result[5];var text=result[6];if(text){formattedString+=""+text;}else{var replacement="";switch(conversionCharacter){case"a":case"m":var depth=0;if(specifier){depth=parseInt(specifier,10);if(isNaN(depth)){handleError("PatternLayout.format: invalid specifier '"+
specifier+"' for conversion character '"+conversionCharacter+"' - should be a number");depth=0;}}
var messages=(conversionCharacter==="a")?loggingEvent.messages[0]:loggingEvent.messages;for(var i=0,len=messages.length;i<len;i++){if(i>0&&(replacement.charAt(replacement.length-1)!==" ")){replacement+=" ";}
if(depth===0){replacement+=messages[i];}else{replacement+=formatObjectExpansion(messages[i],depth);}}
break;case"c":var loggerName=loggingEvent.logger.name;if(specifier){var precision=parseInt(specifier,10);var loggerNameBits=loggingEvent.logger.name.split(".");if(precision>=loggerNameBits.length){replacement=loggerName;}else{replacement=loggerNameBits.slice(loggerNameBits.length-precision).join(".");}}else{replacement=loggerName;}
break;case"d":var dateFormat=PatternLayout.ISO8601_DATEFORMAT;if(specifier){dateFormat=specifier;if(dateFormat=="ISO8601"){dateFormat=PatternLayout.ISO8601_DATEFORMAT;}else if(dateFormat=="ABSOLUTE"){dateFormat=PatternLayout.ABSOLUTETIME_DATEFORMAT;}else if(dateFormat=="DATE"){dateFormat=PatternLayout.DATETIME_DATEFORMAT;}}
replacement=(new SimpleDateFormat(dateFormat)).format(loggingEvent.timeStamp);break;case"f":if(this.hasCustomFields()){var fieldIndex=0;if(specifier){fieldIndex=parseInt(specifier,10);if(isNaN(fieldIndex)){handleError("PatternLayout.format: invalid specifier '"+
specifier+"' for conversion character 'f' - should be a number");}else if(fieldIndex===0){handleError("PatternLayout.format: invalid specifier '"+
specifier+"' for conversion character 'f' - must be greater than zero");}else if(fieldIndex>this.customFields.length){handleError("PatternLayout.format: invalid specifier '"+
specifier+"' for conversion character 'f' - there aren't that many custom fields");}else{fieldIndex=fieldIndex-1;}}
var val=this.customFields[fieldIndex].value;if(typeof val=="function"){val=val(this,loggingEvent);}
replacement=val;}
break;case"n":replacement=newLine;break;case"p":replacement=loggingEvent.level.name;break;case"r":replacement=""+loggingEvent.timeStamp.getDifference(applicationStartDate);break;case"%":replacement="%";break;default:replacement=matchedString;break;}
var l;if(truncation){l=parseInt(truncation.substr(1),10);var strLen=replacement.length;if(l<strLen){replacement=replacement.substring(strLen-l,strLen);}}
if(padding){if(padding.charAt(0)=="-"){l=parseInt(padding.substr(1),10);while(replacement.length<l){replacement+=" ";}}else{l=parseInt(padding,10);while(replacement.length<l){replacement=" "+replacement;}}}
formattedString+=replacement;}
searchString=searchString.substr(result.index+result[0].length);}
return formattedString;};PatternLayout.prototype.ignoresThrowable=function(){return true;};PatternLayout.prototype.toString=function(){return"PatternLayout";};log4javascript.PatternLayout=PatternLayout;function AlertAppender(){}
AlertAppender.prototype=new Appender();AlertAppender.prototype.layout=new SimpleLayout();AlertAppender.prototype.append=function(loggingEvent){alert(this.getLayout().formatWithException(loggingEvent));};AlertAppender.prototype.toString=function(){return"AlertAppender";};log4javascript.AlertAppender=AlertAppender;function BrowserConsoleAppender(){}
BrowserConsoleAppender.prototype=new log4javascript.Appender();BrowserConsoleAppender.prototype.layout=new NullLayout();BrowserConsoleAppender.prototype.threshold=Level.DEBUG;BrowserConsoleAppender.prototype.append=function(loggingEvent){var appender=this;var getFormattedMessage=function(concatenate){var formattedMessage=appender.getLayout().formatWithException(loggingEvent);return(typeof formattedMessage=="string")?(concatenate?formattedMessage:[formattedMessage]):(concatenate?formattedMessage.join(" "):formattedMessage);};var console=window.console;if(console&&console.log){var consoleMethodName;if(console.debug&&Level.DEBUG.isGreaterOrEqual(loggingEvent.level)){consoleMethodName="debug";}else if(console.info&&Level.INFO.equals(loggingEvent.level)){consoleMethodName="info";}else if(console.warn&&Level.WARN.equals(loggingEvent.level)){consoleMethodName="warn";}else if(console.error&&loggingEvent.level.isGreaterOrEqual(Level.ERROR)){consoleMethodName="error";}else{consoleMethodName="log";}
if(typeof console[consoleMethodName].apply=="function"){console[consoleMethodName].apply(console,getFormattedMessage(false));}else{console[consoleMethodName](getFormattedMessage(true));}}else if((typeof opera!="undefined")&&opera.postError){opera.postError(getFormattedMessage(true));}};BrowserConsoleAppender.prototype.group=function(name){if(window.console&&window.console.group){window.console.group(name);}};BrowserConsoleAppender.prototype.groupEnd=function(){if(window.console&&window.console.groupEnd){window.console.groupEnd();}};BrowserConsoleAppender.prototype.toString=function(){return"BrowserConsoleAppender";};log4javascript.BrowserConsoleAppender=BrowserConsoleAppender;var xhrFactory=function(){return new XMLHttpRequest();};var xmlHttpFactories=[xhrFactory,function(){return new ActiveXObject("Msxml2.XMLHTTP");},function(){return new ActiveXObject("Microsoft.XMLHTTP");}];var withCredentialsSupported=false;var getXmlHttp=function(errorHandler){var xmlHttp=null,factory;for(var i=0,len=xmlHttpFactories.length;i<len;i++){factory=xmlHttpFactories[i];try{xmlHttp=factory();withCredentialsSupported=(factory==xhrFactory&&("withCredentials"in xmlHttp));getXmlHttp=factory;return xmlHttp;}catch(e){}}
if(errorHandler){errorHandler();}else{handleError("getXmlHttp: unable to obtain XMLHttpRequest object");}};function isHttpRequestSuccessful(xmlHttp){return isUndefined(xmlHttp.status)||xmlHttp.status===0||(xmlHttp.status>=200&&xmlHttp.status<300)||xmlHttp.status==1223;}
function AjaxAppender(url,withCredentials){var appender=this;var isSupported=true;if(!url){handleError("AjaxAppender: URL must be specified in constructor");isSupported=false;}
var timed=this.defaults.timed;var waitForResponse=this.defaults.waitForResponse;var batchSize=this.defaults.batchSize;var timerInterval=this.defaults.timerInterval;var requestSuccessCallback=this.defaults.requestSuccessCallback;var failCallback=this.defaults.failCallback;var postVarName=this.defaults.postVarName;var sendAllOnUnload=this.defaults.sendAllOnUnload;var contentType=this.defaults.contentType;var sessionId=null;var queuedLoggingEvents=[];var queuedRequests=[];var headers=[];var sending=false;var initialized=false;function checkCanConfigure(configOptionName){if(initialized){handleError("AjaxAppender: configuration option '"+
configOptionName+"' may not be set after the appender has been initialized");return false;}
return true;}
this.getSessionId=function(){return sessionId;};this.setSessionId=function(sessionIdParam){sessionId=extractStringFromParam(sessionIdParam,null);this.layout.setCustomField("sessionid",sessionId);};this.setLayout=function(layoutParam){if(checkCanConfigure("layout")){this.layout=layoutParam;if(sessionId!==null){this.setSessionId(sessionId);}}};this.isTimed=function(){return timed;};this.setTimed=function(timedParam){if(checkCanConfigure("timed")){timed=bool(timedParam);}};this.getTimerInterval=function(){return timerInterval;};this.setTimerInterval=function(timerIntervalParam){if(checkCanConfigure("timerInterval")){timerInterval=extractIntFromParam(timerIntervalParam,timerInterval);}};this.isWaitForResponse=function(){return waitForResponse;};this.setWaitForResponse=function(waitForResponseParam){if(checkCanConfigure("waitForResponse")){waitForResponse=bool(waitForResponseParam);}};this.getBatchSize=function(){return batchSize;};this.setBatchSize=function(batchSizeParam){if(checkCanConfigure("batchSize")){batchSize=extractIntFromParam(batchSizeParam,batchSize);}};this.isSendAllOnUnload=function(){return sendAllOnUnload;};this.setSendAllOnUnload=function(sendAllOnUnloadParam){if(checkCanConfigure("sendAllOnUnload")){sendAllOnUnload=extractBooleanFromParam(sendAllOnUnloadParam,sendAllOnUnload);}};this.setRequestSuccessCallback=function(requestSuccessCallbackParam){requestSuccessCallback=extractFunctionFromParam(requestSuccessCallbackParam,requestSuccessCallback);};this.setFailCallback=function(failCallbackParam){failCallback=extractFunctionFromParam(failCallbackParam,failCallback);};this.getPostVarName=function(){return postVarName;};this.setPostVarName=function(postVarNameParam){if(checkCanConfigure("postVarName")){postVarName=extractStringFromParam(postVarNameParam,postVarName);}};this.getHeaders=function(){return headers;};this.addHeader=function(name,value){if(name.toLowerCase()=="content-type"){contentType=value;}else{headers.push({name:name,value:value});}};function sendAll(){if(isSupported&&enabled){sending=true;var currentRequestBatch;if(waitForResponse){if(queuedRequests.length>0){currentRequestBatch=queuedRequests.shift();sendRequest(preparePostData(currentRequestBatch),sendAll);}else{sending=false;if(timed){scheduleSending();}}}else{while((currentRequestBatch=queuedRequests.shift())){sendRequest(preparePostData(currentRequestBatch));}
sending=false;if(timed){scheduleSending();}}}}
this.sendAll=sendAll;function sendAllRemaining(){var sendingAnything=false;if(isSupported&&enabled){var actualBatchSize=appender.getLayout().allowBatching()?batchSize:1;var currentLoggingEvent;var batchedLoggingEvents=[];while((currentLoggingEvent=queuedLoggingEvents.shift())){batchedLoggingEvents.push(currentLoggingEvent);if(queuedLoggingEvents.length>=actualBatchSize){queuedRequests.push(batchedLoggingEvents);batchedLoggingEvents=[];}}
if(batchedLoggingEvents.length>0){queuedRequests.push(batchedLoggingEvents);}
sendingAnything=(queuedRequests.length>0);waitForResponse=false;timed=false;sendAll();}
return sendingAnything;}
this.sendAllRemaining=sendAllRemaining;function preparePostData(batchedLoggingEvents){var formattedMessages=[];var currentLoggingEvent;var postData="";while((currentLoggingEvent=batchedLoggingEvents.shift())){formattedMessages.push(appender.getLayout().formatWithException(currentLoggingEvent));}
if(batchedLoggingEvents.length==1){postData=formattedMessages.join("");}else{postData=appender.getLayout().batchHeader+
formattedMessages.join(appender.getLayout().batchSeparator)+
appender.getLayout().batchFooter;}
if(contentType==appender.defaults.contentType){postData=appender.getLayout().returnsPostData?postData:urlEncode(postVarName)+"="+urlEncode(postData);if(postData.length>0){postData+="&";}
postData+="layout="+urlEncode(appender.getLayout().toString());}
return postData;}
function scheduleSending(){window.setTimeout(sendAll,timerInterval);}
function xmlHttpErrorHandler(){var msg="AjaxAppender: could not create XMLHttpRequest object. AjaxAppender disabled";handleError(msg);isSupported=false;if(failCallback){failCallback(msg);}}
function sendRequest(postData,successCallback){try{var xmlHttp=getXmlHttp(xmlHttpErrorHandler);if(isSupported){xmlHttp.onreadystatechange=function(){if(xmlHttp.readyState==4){if(isHttpRequestSuccessful(xmlHttp)){if(requestSuccessCallback){requestSuccessCallback(xmlHttp);}
if(successCallback){successCallback(xmlHttp);}}else{var msg="AjaxAppender.append: XMLHttpRequest request to URL "+
url+" returned status code "+xmlHttp.status;handleError(msg);if(failCallback){failCallback(msg);}}
xmlHttp.onreadystatechange=emptyFunction;xmlHttp=null;}};xmlHttp.open("POST",url,true);if(withCredentials&&withCredentialsSupported){xmlHttp.withCredentials=true;}
try{for(var i=0,header;header=headers[i++];){xmlHttp.setRequestHeader(header.name,header.value);}
xmlHttp.setRequestHeader("Content-Type",contentType);}catch(headerEx){var msg="AjaxAppender.append: your browser's XMLHttpRequest implementation"+" does not support setRequestHeader, therefore cannot post data. AjaxAppender disabled";handleError(msg);isSupported=false;if(failCallback){failCallback(msg);}
return;}
xmlHttp.send(postData);}}catch(ex){var errMsg="AjaxAppender.append: error sending log message to "+url;handleError(errMsg,ex);isSupported=false;if(failCallback){failCallback(errMsg+". Details: "+getExceptionStringRep(ex));}}}
this.append=function(loggingEvent){if(isSupported){if(!initialized){init();}
queuedLoggingEvents.push(loggingEvent);var actualBatchSize=this.getLayout().allowBatching()?batchSize:1;if(queuedLoggingEvents.length>=actualBatchSize){var currentLoggingEvent;var batchedLoggingEvents=[];while((currentLoggingEvent=queuedLoggingEvents.shift())){batchedLoggingEvents.push(currentLoggingEvent);}
queuedRequests.push(batchedLoggingEvents);if(!timed&&(!waitForResponse||(waitForResponse&&!sending))){sendAll();}}}};function init(){initialized=true;if(sendAllOnUnload){var oldBeforeUnload=window.onbeforeunload;window.onbeforeunload=function(){if(oldBeforeUnload){oldBeforeUnload();}
sendAllRemaining();};}
if(timed){scheduleSending();}}}
AjaxAppender.prototype=new Appender();AjaxAppender.prototype.defaults={waitForResponse:false,timed:false,timerInterval:1000,batchSize:1,sendAllOnUnload:false,requestSuccessCallback:null,failCallback:null,postVarName:"data",contentType:"application/x-www-form-urlencoded"};AjaxAppender.prototype.layout=new HttpPostDataLayout();AjaxAppender.prototype.toString=function(){return"AjaxAppender";};log4javascript.AjaxAppender=AjaxAppender;function setCookie(name,value,days,path){var expires;path=path?"; path="+path:"";if(days){var date=new Date();date.setTime(date.getTime()+(days*24*60*60*1000));expires="; expires="+date.toGMTString();}else{expires="";}
document.cookie=escape(name)+"="+escape(value)+expires+path;}
function getCookie(name){var nameEquals=escape(name)+"=";var ca=document.cookie.split(";");for(var i=0,len=ca.length;i<len;i++){var c=ca[i];while(c.charAt(0)===" "){c=c.substring(1,c.length);}
if(c.indexOf(nameEquals)===0){return unescape(c.substring(nameEquals.length,c.length));}}
return null;}
function getBaseUrl(){var scripts=document.getElementsByTagName("script");for(var i=0,len=scripts.length;i<len;++i){if(scripts[i].src.indexOf("log4javascript")!=-1){var lastSlash=scripts[i].src.lastIndexOf("/");return(lastSlash==-1)?"":scripts[i].src.substr(0,lastSlash+1);}}
return null;}
function isLoaded(win){try{return bool(win.loaded);}catch(ex){return false;}}
var ConsoleAppender;(function(){var getConsoleHtmlLines=function(){return['<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">','<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">','<head>','<title>log4javascript</title>','<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />','<!-- Make IE8 behave like IE7, having gone to all the trouble of making IE work -->','<meta http-equiv="X-UA-Compatible" content="IE=7" />','<script type="text/javascript">var isIe = false, isIePre7 = false;</script>','<!--[if IE]><script type="text/javascript">isIe = true</script><![endif]-->','<!--[if lt IE 7]><script type="text/javascript">isIePre7 = true</script><![endif]-->','<script type="text/javascript">','//<![CDATA[','var loggingEnabled=true;var logQueuedEventsTimer=null;var logEntries=[];var logEntriesAndSeparators=[];var logItems=[];var renderDelay=100;var unrenderedLogItemsExist=false;var rootGroup,currentGroup=null;var loaded=false;var currentLogItem=null;var logMainContainer;function copyProperties(obj,props){for(var i in props){obj[i]=props[i];}}','function LogItem(){}','LogItem.prototype={mainContainer:null,wrappedContainer:null,unwrappedContainer:null,group:null,appendToLog:function(){for(var i=0,len=this.elementContainers.length;i<len;i++){this.elementContainers[i].appendToLog();}','this.group.update();},doRemove:function(doUpdate,removeFromGroup){if(this.rendered){for(var i=0,len=this.elementContainers.length;i<len;i++){this.elementContainers[i].remove();}','this.unwrappedElementContainer=null;this.wrappedElementContainer=null;this.mainElementContainer=null;}','if(this.group&&removeFromGroup){this.group.removeChild(this,doUpdate);}','if(this===currentLogItem){currentLogItem=null;}},remove:function(doUpdate,removeFromGroup){this.doRemove(doUpdate,removeFromGroup);},render:function(){},accept:function(visitor){visitor.visit(this);},getUnwrappedDomContainer:function(){return this.group.unwrappedElementContainer.contentDiv;},getWrappedDomContainer:function(){return this.group.wrappedElementContainer.contentDiv;},getMainDomContainer:function(){return this.group.mainElementContainer.contentDiv;}};LogItem.serializedItemKeys={LOG_ENTRY:0,GROUP_START:1,GROUP_END:2};function LogItemContainerElement(){}','LogItemContainerElement.prototype={appendToLog:function(){var insertBeforeFirst=(newestAtTop&&this.containerDomNode.hasChildNodes());if(insertBeforeFirst){this.containerDomNode.insertBefore(this.mainDiv,this.containerDomNode.firstChild);}else{this.containerDomNode.appendChild(this.mainDiv);}}};function SeparatorElementContainer(containerDomNode){this.containerDomNode=containerDomNode;this.mainDiv=document.createElement("div");this.mainDiv.className="separator";this.mainDiv.innerHTML="&nbsp;";}','SeparatorElementContainer.prototype=new LogItemContainerElement();SeparatorElementContainer.prototype.remove=function(){this.mainDiv.parentNode.removeChild(this.mainDiv);this.mainDiv=null;};function Separator(){this.rendered=false;}','Separator.prototype=new LogItem();copyProperties(Separator.prototype,{render:function(){var containerDomNode=this.group.contentDiv;if(isIe){this.unwrappedElementContainer=new SeparatorElementContainer(this.getUnwrappedDomContainer());this.wrappedElementContainer=new SeparatorElementContainer(this.getWrappedDomContainer());this.elementContainers=[this.unwrappedElementContainer,this.wrappedElementContainer];}else{this.mainElementContainer=new SeparatorElementContainer(this.getMainDomContainer());this.elementContainers=[this.mainElementContainer];}','this.content=this.formattedMessage;this.rendered=true;}});function GroupElementContainer(group,containerDomNode,isRoot,isWrapped){this.group=group;this.containerDomNode=containerDomNode;this.isRoot=isRoot;this.isWrapped=isWrapped;this.expandable=false;if(this.isRoot){if(isIe){this.contentDiv=logMainContainer.appendChild(document.createElement("div"));this.contentDiv.id=this.isWrapped?"log_wrapped":"log_unwrapped";}else{this.contentDiv=logMainContainer;}}else{var groupElementContainer=this;this.mainDiv=document.createElement("div");this.mainDiv.className="group";this.headingDiv=this.mainDiv.appendChild(document.createElement("div"));this.headingDiv.className="groupheading";this.expander=this.headingDiv.appendChild(document.createElement("span"));this.expander.className="expander unselectable greyedout";this.expander.unselectable=true;var expanderText=this.group.expanded?"-":"+";this.expanderTextNode=this.expander.appendChild(document.createTextNode(expanderText));this.headingDiv.appendChild(document.createTextNode(" "+this.group.name));this.contentDiv=this.mainDiv.appendChild(document.createElement("div"));var contentCssClass=this.group.expanded?"expanded":"collapsed";this.contentDiv.className="groupcontent "+contentCssClass;this.expander.onclick=function(){if(groupElementContainer.group.expandable){groupElementContainer.group.toggleExpanded();}};}}','GroupElementContainer.prototype=new LogItemContainerElement();copyProperties(GroupElementContainer.prototype,{toggleExpanded:function(){if(!this.isRoot){var oldCssClass,newCssClass,expanderText;if(this.group.expanded){newCssClass="expanded";oldCssClass="collapsed";expanderText="-";}else{newCssClass="collapsed";oldCssClass="expanded";expanderText="+";}','replaceClass(this.contentDiv,newCssClass,oldCssClass);this.expanderTextNode.nodeValue=expanderText;}},remove:function(){if(!this.isRoot){this.headingDiv=null;this.expander.onclick=null;this.expander=null;this.expanderTextNode=null;this.contentDiv=null;this.containerDomNode=null;this.mainDiv.parentNode.removeChild(this.mainDiv);this.mainDiv=null;}},reverseChildren:function(){var node=null;var childDomNodes=[];while((node=this.contentDiv.firstChild)){this.contentDiv.removeChild(node);childDomNodes.push(node);}','while((node=childDomNodes.pop())){this.contentDiv.appendChild(node);}},update:function(){if(!this.isRoot){if(this.group.expandable){removeClass(this.expander,"greyedout");}else{addClass(this.expander,"greyedout");}}},clear:function(){if(this.isRoot){this.contentDiv.innerHTML="";}}});function Group(name,isRoot,initiallyExpanded){this.name=name;this.group=null;this.isRoot=isRoot;this.initiallyExpanded=initiallyExpanded;this.elementContainers=[];this.children=[];this.expanded=initiallyExpanded;this.rendered=false;this.expandable=false;}','Group.prototype=new LogItem();copyProperties(Group.prototype,{addChild:function(logItem){this.children.push(logItem);logItem.group=this;},render:function(){if(isIe){var unwrappedDomContainer,wrappedDomContainer;if(this.isRoot){unwrappedDomContainer=logMainContainer;wrappedDomContainer=logMainContainer;}else{unwrappedDomContainer=this.getUnwrappedDomContainer();wrappedDomContainer=this.getWrappedDomContainer();}','this.unwrappedElementContainer=new GroupElementContainer(this,unwrappedDomContainer,this.isRoot,false);this.wrappedElementContainer=new GroupElementContainer(this,wrappedDomContainer,this.isRoot,true);this.elementContainers=[this.unwrappedElementContainer,this.wrappedElementContainer];}else{var mainDomContainer=this.isRoot?logMainContainer:this.getMainDomContainer();this.mainElementContainer=new GroupElementContainer(this,mainDomContainer,this.isRoot,false);this.elementContainers=[this.mainElementContainer];}','this.rendered=true;},toggleExpanded:function(){this.expanded=!this.expanded;for(var i=0,len=this.elementContainers.length;i<len;i++){this.elementContainers[i].toggleExpanded();}},expand:function(){if(!this.expanded){this.toggleExpanded();}},accept:function(visitor){visitor.visitGroup(this);},reverseChildren:function(){if(this.rendered){for(var i=0,len=this.elementContainers.length;i<len;i++){this.elementContainers[i].reverseChildren();}}},update:function(){var previouslyExpandable=this.expandable;this.expandable=(this.children.length!==0);if(this.expandable!==previouslyExpandable){for(var i=0,len=this.elementContainers.length;i<len;i++){this.elementContainers[i].update();}}},flatten:function(){var visitor=new GroupFlattener();this.accept(visitor);return visitor.logEntriesAndSeparators;},removeChild:function(child,doUpdate){array_remove(this.children,child);child.group=null;if(doUpdate){this.update();}},remove:function(doUpdate,removeFromGroup){for(var i=0,len=this.children.length;i<len;i++){this.children[i].remove(false,false);}','this.children=[];this.update();if(this===currentGroup){currentGroup=this.group;}','this.doRemove(doUpdate,removeFromGroup);},serialize:function(items){items.push([LogItem.serializedItemKeys.GROUP_START,this.name]);for(var i=0,len=this.children.length;i<len;i++){this.children[i].serialize(items);}','if(this!==currentGroup){items.push([LogItem.serializedItemKeys.GROUP_END]);}},clear:function(){for(var i=0,len=this.elementContainers.length;i<len;i++){this.elementContainers[i].clear();}}});function LogEntryElementContainer(){}','LogEntryElementContainer.prototype=new LogItemContainerElement();copyProperties(LogEntryElementContainer.prototype,{remove:function(){this.doRemove();},doRemove:function(){this.mainDiv.parentNode.removeChild(this.mainDiv);this.mainDiv=null;this.contentElement=null;this.containerDomNode=null;},setContent:function(content,wrappedContent){if(content===this.formattedMessage){this.contentElement.innerHTML="";this.contentElement.appendChild(document.createTextNode(this.formattedMessage));}else{this.contentElement.innerHTML=content;}},setSearchMatch:function(isMatch){var oldCssClass=isMatch?"searchnonmatch":"searchmatch";var newCssClass=isMatch?"searchmatch":"searchnonmatch";replaceClass(this.mainDiv,newCssClass,oldCssClass);},clearSearch:function(){removeClass(this.mainDiv,"searchmatch");removeClass(this.mainDiv,"searchnonmatch");}});function LogEntryWrappedElementContainer(logEntry,containerDomNode){this.logEntry=logEntry;this.containerDomNode=containerDomNode;this.mainDiv=document.createElement("div");this.mainDiv.appendChild(document.createTextNode(this.logEntry.formattedMessage));this.mainDiv.className="logentry wrapped "+this.logEntry.level;this.contentElement=this.mainDiv;}','LogEntryWrappedElementContainer.prototype=new LogEntryElementContainer();LogEntryWrappedElementContainer.prototype.setContent=function(content,wrappedContent){if(content===this.formattedMessage){this.contentElement.innerHTML="";this.contentElement.appendChild(document.createTextNode(this.formattedMessage));}else{this.contentElement.innerHTML=wrappedContent;}};function LogEntryUnwrappedElementContainer(logEntry,containerDomNode){this.logEntry=logEntry;this.containerDomNode=containerDomNode;this.mainDiv=document.createElement("div");this.mainDiv.className="logentry unwrapped "+this.logEntry.level;this.pre=this.mainDiv.appendChild(document.createElement("pre"));this.pre.appendChild(document.createTextNode(this.logEntry.formattedMessage));this.pre.className="unwrapped";this.contentElement=this.pre;}','LogEntryUnwrappedElementContainer.prototype=new LogEntryElementContainer();LogEntryUnwrappedElementContainer.prototype.remove=function(){this.doRemove();this.pre=null;};function LogEntryMainElementContainer(logEntry,containerDomNode){this.logEntry=logEntry;this.containerDomNode=containerDomNode;this.mainDiv=document.createElement("div");this.mainDiv.className="logentry nonielogentry "+this.logEntry.level;this.contentElement=this.mainDiv.appendChild(document.createElement("span"));this.contentElement.appendChild(document.createTextNode(this.logEntry.formattedMessage));}','LogEntryMainElementContainer.prototype=new LogEntryElementContainer();function LogEntry(level,formattedMessage){this.level=level;this.formattedMessage=formattedMessage;this.rendered=false;}','LogEntry.prototype=new LogItem();copyProperties(LogEntry.prototype,{render:function(){var logEntry=this;var containerDomNode=this.group.contentDiv;if(isIe){this.formattedMessage=this.formattedMessage.replace(/\\r\\n/g,"\\r");this.unwrappedElementContainer=new LogEntryUnwrappedElementContainer(this,this.getUnwrappedDomContainer());this.wrappedElementContainer=new LogEntryWrappedElementContainer(this,this.getWrappedDomContainer());this.elementContainers=[this.unwrappedElementContainer,this.wrappedElementContainer];}else{this.mainElementContainer=new LogEntryMainElementContainer(this,this.getMainDomContainer());this.elementContainers=[this.mainElementContainer];}','this.content=this.formattedMessage;this.rendered=true;},setContent:function(content,wrappedContent){if(content!=this.content){if(isIe&&(content!==this.formattedMessage)){content=content.replace(/\\r\\n/g,"\\r");}','for(var i=0,len=this.elementContainers.length;i<len;i++){this.elementContainers[i].setContent(content,wrappedContent);}','this.content=content;}},getSearchMatches:function(){var matches=[];var i,len;if(isIe){var unwrappedEls=getElementsByClass(this.unwrappedElementContainer.mainDiv,"searchterm","span");var wrappedEls=getElementsByClass(this.wrappedElementContainer.mainDiv,"searchterm","span");for(i=0,len=unwrappedEls.length;i<len;i++){matches[i]=new Match(this.level,null,unwrappedEls[i],wrappedEls[i]);}}else{var els=getElementsByClass(this.mainElementContainer.mainDiv,"searchterm","span");for(i=0,len=els.length;i<len;i++){matches[i]=new Match(this.level,els[i]);}}','return matches;},setSearchMatch:function(isMatch){for(var i=0,len=this.elementContainers.length;i<len;i++){this.elementContainers[i].setSearchMatch(isMatch);}},clearSearch:function(){for(var i=0,len=this.elementContainers.length;i<len;i++){this.elementContainers[i].clearSearch();}},accept:function(visitor){visitor.visitLogEntry(this);},serialize:function(items){items.push([LogItem.serializedItemKeys.LOG_ENTRY,this.level,this.formattedMessage]);}});function LogItemVisitor(){}','LogItemVisitor.prototype={visit:function(logItem){},visitParent:function(logItem){if(logItem.group){logItem.group.accept(this);}},visitChildren:function(logItem){for(var i=0,len=logItem.children.length;i<len;i++){logItem.children[i].accept(this);}},visitLogEntry:function(logEntry){this.visit(logEntry);},visitSeparator:function(separator){this.visit(separator);},visitGroup:function(group){this.visit(group);}};function GroupFlattener(){this.logEntriesAndSeparators=[];}','GroupFlattener.prototype=new LogItemVisitor();GroupFlattener.prototype.visitGroup=function(group){this.visitChildren(group);};GroupFlattener.prototype.visitLogEntry=function(logEntry){this.logEntriesAndSeparators.push(logEntry);};GroupFlattener.prototype.visitSeparator=function(separator){this.logEntriesAndSeparators.push(separator);};window.onload=function(){if(location.search){var queryBits=unescape(location.search).substr(1).split("&"),nameValueBits;for(var i=0,len=queryBits.length;i<len;i++){nameValueBits=queryBits[i].split("=");if(nameValueBits[0]=="log4javascript_domain"){document.domain=nameValueBits[1];break;}}}','logMainContainer=$("log");if(isIePre7){addClass(logMainContainer,"oldIe");}','rootGroup=new Group("root",true);rootGroup.render();currentGroup=rootGroup;setCommandInputWidth();setLogContainerHeight();toggleLoggingEnabled();toggleSearchEnabled();toggleSearchFilter();toggleSearchHighlight();applyFilters();checkAllLevels();toggleWrap();toggleNewestAtTop();toggleScrollToLatest();renderQueuedLogItems();loaded=true;$("command").value="";$("command").autocomplete="off";$("command").onkeydown=function(evt){evt=getEvent(evt);if(evt.keyCode==10||evt.keyCode==13){evalCommandLine();stopPropagation(evt);}else if(evt.keyCode==27){this.value="";this.focus();}else if(evt.keyCode==38&&commandHistory.length>0){currentCommandIndex=Math.max(0,currentCommandIndex-1);this.value=commandHistory[currentCommandIndex];moveCaretToEnd(this);}else if(evt.keyCode==40&&commandHistory.length>0){currentCommandIndex=Math.min(commandHistory.length-1,currentCommandIndex+1);this.value=commandHistory[currentCommandIndex];moveCaretToEnd(this);}};$("command").onkeypress=function(evt){evt=getEvent(evt);if(evt.keyCode==38&&commandHistory.length>0&&evt.preventDefault){evt.preventDefault();}};$("command").onkeyup=function(evt){evt=getEvent(evt);if(evt.keyCode==27&&evt.preventDefault){evt.preventDefault();this.focus();}};document.onkeydown=function keyEventHandler(evt){evt=getEvent(evt);switch(evt.keyCode){case 69:if(evt.shiftKey&&(evt.ctrlKey||evt.metaKey)){evalLastCommand();cancelKeyEvent(evt);return false;}','break;case 75:if(evt.shiftKey&&(evt.ctrlKey||evt.metaKey)){focusSearch();cancelKeyEvent(evt);return false;}','break;case 40:case 76:if(evt.shiftKey&&(evt.ctrlKey||evt.metaKey)){focusCommandLine();cancelKeyEvent(evt);return false;}','break;}};setTimeout(setLogContainerHeight,20);setShowCommandLine(showCommandLine);doSearch();};window.onunload=function(){if(mainWindowExists()){appender.unload();}','appender=null;};function toggleLoggingEnabled(){setLoggingEnabled($("enableLogging").checked);}','function setLoggingEnabled(enable){loggingEnabled=enable;}','var appender=null;function setAppender(appenderParam){appender=appenderParam;}','function setShowCloseButton(showCloseButton){$("closeButton").style.display=showCloseButton?"inline":"none";}','function setShowHideButton(showHideButton){$("hideButton").style.display=showHideButton?"inline":"none";}','var newestAtTop=false;function LogItemContentReverser(){}','LogItemContentReverser.prototype=new LogItemVisitor();LogItemContentReverser.prototype.visitGroup=function(group){group.reverseChildren();this.visitChildren(group);};function setNewestAtTop(isNewestAtTop){var oldNewestAtTop=newestAtTop;var i,iLen,j,jLen;newestAtTop=Boolean(isNewestAtTop);if(oldNewestAtTop!=newestAtTop){var visitor=new LogItemContentReverser();rootGroup.accept(visitor);if(currentSearch){var currentMatch=currentSearch.matches[currentMatchIndex];var matchIndex=0;var matches=[];var actOnLogEntry=function(logEntry){var logEntryMatches=logEntry.getSearchMatches();for(j=0,jLen=logEntryMatches.length;j<jLen;j++){matches[matchIndex]=logEntryMatches[j];if(currentMatch&&logEntryMatches[j].equals(currentMatch)){currentMatchIndex=matchIndex;}','matchIndex++;}};if(newestAtTop){for(i=logEntries.length-1;i>=0;i--){actOnLogEntry(logEntries[i]);}}else{for(i=0,iLen=logEntries.length;i<iLen;i++){actOnLogEntry(logEntries[i]);}}','currentSearch.matches=matches;if(currentMatch){currentMatch.setCurrent();}}else if(scrollToLatest){doScrollToLatest();}}','$("newestAtTop").checked=isNewestAtTop;}','function toggleNewestAtTop(){var isNewestAtTop=$("newestAtTop").checked;setNewestAtTop(isNewestAtTop);}','var scrollToLatest=true;function setScrollToLatest(isScrollToLatest){scrollToLatest=isScrollToLatest;if(scrollToLatest){doScrollToLatest();}','$("scrollToLatest").checked=isScrollToLatest;}','function toggleScrollToLatest(){var isScrollToLatest=$("scrollToLatest").checked;setScrollToLatest(isScrollToLatest);}','function doScrollToLatest(){var l=logMainContainer;if(typeof l.scrollTop!="undefined"){if(newestAtTop){l.scrollTop=0;}else{var latestLogEntry=l.lastChild;if(latestLogEntry){l.scrollTop=l.scrollHeight;}}}}','var closeIfOpenerCloses=true;function setCloseIfOpenerCloses(isCloseIfOpenerCloses){closeIfOpenerCloses=isCloseIfOpenerCloses;}','var maxMessages=null;function setMaxMessages(max){maxMessages=max;pruneLogEntries();}','var showCommandLine=false;function setShowCommandLine(isShowCommandLine){showCommandLine=isShowCommandLine;if(loaded){$("commandLine").style.display=showCommandLine?"block":"none";setCommandInputWidth();setLogContainerHeight();}}','function focusCommandLine(){if(loaded){$("command").focus();}}','function focusSearch(){if(loaded){$("searchBox").focus();}}','function getLogItems(){var items=[];for(var i=0,len=logItems.length;i<len;i++){logItems[i].serialize(items);}','return items;}','function setLogItems(items){var loggingReallyEnabled=loggingEnabled;loggingEnabled=true;for(var i=0,len=items.length;i<len;i++){switch(items[i][0]){case LogItem.serializedItemKeys.LOG_ENTRY:log(items[i][1],items[i][2]);break;case LogItem.serializedItemKeys.GROUP_START:group(items[i][1]);break;case LogItem.serializedItemKeys.GROUP_END:groupEnd();break;}}','loggingEnabled=loggingReallyEnabled;}','function log(logLevel,formattedMessage){if(loggingEnabled){var logEntry=new LogEntry(logLevel,formattedMessage);logEntries.push(logEntry);logEntriesAndSeparators.push(logEntry);logItems.push(logEntry);currentGroup.addChild(logEntry);if(loaded){if(logQueuedEventsTimer!==null){clearTimeout(logQueuedEventsTimer);}','logQueuedEventsTimer=setTimeout(renderQueuedLogItems,renderDelay);unrenderedLogItemsExist=true;}}}','function renderQueuedLogItems(){logQueuedEventsTimer=null;var pruned=pruneLogEntries();var initiallyHasMatches=currentSearch?currentSearch.hasMatches():false;for(var i=0,len=logItems.length;i<len;i++){if(!logItems[i].rendered){logItems[i].render();logItems[i].appendToLog();if(currentSearch&&(logItems[i]instanceof LogEntry)){currentSearch.applyTo(logItems[i]);}}}','if(currentSearch){if(pruned){if(currentSearch.hasVisibleMatches()){if(currentMatchIndex===null){setCurrentMatchIndex(0);}','displayMatches();}else{displayNoMatches();}}else if(!initiallyHasMatches&&currentSearch.hasVisibleMatches()){setCurrentMatchIndex(0);displayMatches();}}','if(scrollToLatest){doScrollToLatest();}','unrenderedLogItemsExist=false;}','function pruneLogEntries(){if((maxMessages!==null)&&(logEntriesAndSeparators.length>maxMessages)){var numberToDelete=logEntriesAndSeparators.length-maxMessages;var prunedLogEntries=logEntriesAndSeparators.slice(0,numberToDelete);if(currentSearch){currentSearch.removeMatches(prunedLogEntries);}','var group;for(var i=0;i<numberToDelete;i++){group=logEntriesAndSeparators[i].group;array_remove(logItems,logEntriesAndSeparators[i]);array_remove(logEntries,logEntriesAndSeparators[i]);logEntriesAndSeparators[i].remove(true,true);if(group.children.length===0&&group!==currentGroup&&group!==rootGroup){array_remove(logItems,group);group.remove(true,true);}}','logEntriesAndSeparators=array_removeFromStart(logEntriesAndSeparators,numberToDelete);return true;}','return false;}','function group(name,startExpanded){if(loggingEnabled){initiallyExpanded=(typeof startExpanded==="undefined")?true:Boolean(startExpanded);var newGroup=new Group(name,false,initiallyExpanded);currentGroup.addChild(newGroup);currentGroup=newGroup;logItems.push(newGroup);if(loaded){if(logQueuedEventsTimer!==null){clearTimeout(logQueuedEventsTimer);}','logQueuedEventsTimer=setTimeout(renderQueuedLogItems,renderDelay);unrenderedLogItemsExist=true;}}}','function groupEnd(){currentGroup=(currentGroup===rootGroup)?rootGroup:currentGroup.group;}','function mainPageReloaded(){currentGroup=rootGroup;var separator=new Separator();logEntriesAndSeparators.push(separator);logItems.push(separator);currentGroup.addChild(separator);}','function closeWindow(){if(appender&&mainWindowExists()){appender.close(true);}else{window.close();}}','function hide(){if(appender&&mainWindowExists()){appender.hide();}}','var mainWindow=window;var windowId="log4javascriptConsoleWindow_"+new Date().getTime()+"_"+(""+Math.random()).substr(2);function setMainWindow(win){mainWindow=win;mainWindow[windowId]=window;if(opener&&closeIfOpenerCloses){pollOpener();}}','function pollOpener(){if(closeIfOpenerCloses){if(mainWindowExists()){setTimeout(pollOpener,500);}else{closeWindow();}}}','function mainWindowExists(){try{return(mainWindow&&!mainWindow.closed&&mainWindow[windowId]==window);}catch(ex){}','return false;}','var logLevels=["TRACE","DEBUG","INFO","WARN","ERROR","FATAL"];function getCheckBox(logLevel){return $("switch_"+logLevel);}','function getIeWrappedLogContainer(){return $("log_wrapped");}','function getIeUnwrappedLogContainer(){return $("log_unwrapped");}','function applyFilters(){for(var i=0;i<logLevels.length;i++){if(getCheckBox(logLevels[i]).checked){addClass(logMainContainer,logLevels[i]);}else{removeClass(logMainContainer,logLevels[i]);}}','updateSearchFromFilters();}','function toggleAllLevels(){var turnOn=$("switch_ALL").checked;for(var i=0;i<logLevels.length;i++){getCheckBox(logLevels[i]).checked=turnOn;if(turnOn){addClass(logMainContainer,logLevels[i]);}else{removeClass(logMainContainer,logLevels[i]);}}}','function checkAllLevels(){for(var i=0;i<logLevels.length;i++){if(!getCheckBox(logLevels[i]).checked){getCheckBox("ALL").checked=false;return;}}','getCheckBox("ALL").checked=true;}','function clearLog(){rootGroup.clear();currentGroup=rootGroup;logEntries=[];logItems=[];logEntriesAndSeparators=[];doSearch();}','function toggleWrap(){var enable=$("wrap").checked;if(enable){addClass(logMainContainer,"wrap");}else{removeClass(logMainContainer,"wrap");}','refreshCurrentMatch();}','var searchTimer=null;function scheduleSearch(){try{clearTimeout(searchTimer);}catch(ex){}','searchTimer=setTimeout(doSearch,500);}','function Search(searchTerm,isRegex,searchRegex,isCaseSensitive){this.searchTerm=searchTerm;this.isRegex=isRegex;this.searchRegex=searchRegex;this.isCaseSensitive=isCaseSensitive;this.matches=[];}','Search.prototype={hasMatches:function(){return this.matches.length>0;},hasVisibleMatches:function(){if(this.hasMatches()){for(var i=0;i<this.matches.length;i++){if(this.matches[i].isVisible()){return true;}}}','return false;},match:function(logEntry){var entryText=String(logEntry.formattedMessage);var matchesSearch=false;if(this.isRegex){matchesSearch=this.searchRegex.test(entryText);}else if(this.isCaseSensitive){matchesSearch=(entryText.indexOf(this.searchTerm)>-1);}else{matchesSearch=(entryText.toLowerCase().indexOf(this.searchTerm.toLowerCase())>-1);}','return matchesSearch;},getNextVisibleMatchIndex:function(){for(var i=currentMatchIndex+1;i<this.matches.length;i++){if(this.matches[i].isVisible()){return i;}}','for(i=0;i<=currentMatchIndex;i++){if(this.matches[i].isVisible()){return i;}}','return-1;},getPreviousVisibleMatchIndex:function(){for(var i=currentMatchIndex-1;i>=0;i--){if(this.matches[i].isVisible()){return i;}}','for(var i=this.matches.length-1;i>=currentMatchIndex;i--){if(this.matches[i].isVisible()){return i;}}','return-1;},applyTo:function(logEntry){var doesMatch=this.match(logEntry);if(doesMatch){logEntry.group.expand();logEntry.setSearchMatch(true);var logEntryContent;var wrappedLogEntryContent;var searchTermReplacementStartTag="<span class=\\\"searchterm\\\">";var searchTermReplacementEndTag="<"+"/span>";var preTagName=isIe?"pre":"span";var preStartTag="<"+preTagName+" class=\\\"pre\\\">";var preEndTag="<"+"/"+preTagName+">";var startIndex=0;var searchIndex,matchedText,textBeforeMatch;if(this.isRegex){var flags=this.isCaseSensitive?"g":"gi";var capturingRegex=new RegExp("("+this.searchRegex.source+")",flags);var rnd=(""+Math.random()).substr(2);var startToken="%%s"+rnd+"%%";var endToken="%%e"+rnd+"%%";logEntryContent=logEntry.formattedMessage.replace(capturingRegex,startToken+"$1"+endToken);logEntryContent=escapeHtml(logEntryContent);var result;var searchString=logEntryContent;logEntryContent="";wrappedLogEntryContent="";while((searchIndex=searchString.indexOf(startToken,startIndex))>-1){var endTokenIndex=searchString.indexOf(endToken,searchIndex);matchedText=searchString.substring(searchIndex+startToken.length,endTokenIndex);textBeforeMatch=searchString.substring(startIndex,searchIndex);logEntryContent+=preStartTag+textBeforeMatch+preEndTag;logEntryContent+=searchTermReplacementStartTag+preStartTag+matchedText+','preEndTag+searchTermReplacementEndTag;if(isIe){wrappedLogEntryContent+=textBeforeMatch+searchTermReplacementStartTag+','matchedText+searchTermReplacementEndTag;}','startIndex=endTokenIndex+endToken.length;}','logEntryContent+=preStartTag+searchString.substr(startIndex)+preEndTag;if(isIe){wrappedLogEntryContent+=searchString.substr(startIndex);}}else{logEntryContent="";wrappedLogEntryContent="";var searchTermReplacementLength=searchTermReplacementStartTag.length+','this.searchTerm.length+searchTermReplacementEndTag.length;var searchTermLength=this.searchTerm.length;var searchTermLowerCase=this.searchTerm.toLowerCase();var logTextLowerCase=logEntry.formattedMessage.toLowerCase();while((searchIndex=logTextLowerCase.indexOf(searchTermLowerCase,startIndex))>-1){matchedText=escapeHtml(logEntry.formattedMessage.substr(searchIndex,this.searchTerm.length));textBeforeMatch=escapeHtml(logEntry.formattedMessage.substring(startIndex,searchIndex));var searchTermReplacement=searchTermReplacementStartTag+','preStartTag+matchedText+preEndTag+searchTermReplacementEndTag;logEntryContent+=preStartTag+textBeforeMatch+preEndTag+searchTermReplacement;if(isIe){wrappedLogEntryContent+=textBeforeMatch+searchTermReplacementStartTag+','matchedText+searchTermReplacementEndTag;}','startIndex=searchIndex+searchTermLength;}','var textAfterLastMatch=escapeHtml(logEntry.formattedMessage.substr(startIndex));logEntryContent+=preStartTag+textAfterLastMatch+preEndTag;if(isIe){wrappedLogEntryContent+=textAfterLastMatch;}}','logEntry.setContent(logEntryContent,wrappedLogEntryContent);var logEntryMatches=logEntry.getSearchMatches();this.matches=this.matches.concat(logEntryMatches);}else{logEntry.setSearchMatch(false);logEntry.setContent(logEntry.formattedMessage,logEntry.formattedMessage);}','return doesMatch;},removeMatches:function(logEntries){var matchesToRemoveCount=0;var currentMatchRemoved=false;var matchesToRemove=[];var i,iLen,j,jLen;for(i=0,iLen=this.matches.length;i<iLen;i++){for(j=0,jLen=logEntries.length;j<jLen;j++){if(this.matches[i].belongsTo(logEntries[j])){matchesToRemove.push(this.matches[i]);if(i===currentMatchIndex){currentMatchRemoved=true;}}}}','var newMatch=currentMatchRemoved?null:this.matches[currentMatchIndex];if(currentMatchRemoved){for(i=currentMatchIndex,iLen=this.matches.length;i<iLen;i++){if(this.matches[i].isVisible()&&!array_contains(matchesToRemove,this.matches[i])){newMatch=this.matches[i];break;}}}','for(i=0,iLen=matchesToRemove.length;i<iLen;i++){array_remove(this.matches,matchesToRemove[i]);matchesToRemove[i].remove();}','if(this.hasVisibleMatches()){if(newMatch===null){setCurrentMatchIndex(0);}else{var newMatchIndex=0;for(i=0,iLen=this.matches.length;i<iLen;i++){if(newMatch===this.matches[i]){newMatchIndex=i;break;}}','setCurrentMatchIndex(newMatchIndex);}}else{currentMatchIndex=null;displayNoMatches();}}};function getPageOffsetTop(el,container){var currentEl=el;var y=0;while(currentEl&&currentEl!=container){y+=currentEl.offsetTop;currentEl=currentEl.offsetParent;}','return y;}','function scrollIntoView(el){var logContainer=logMainContainer;if(!$("wrap").checked){var logContainerLeft=logContainer.scrollLeft;var logContainerRight=logContainerLeft+logContainer.offsetWidth;var elLeft=el.offsetLeft;var elRight=elLeft+el.offsetWidth;if(elLeft<logContainerLeft||elRight>logContainerRight){logContainer.scrollLeft=elLeft-(logContainer.offsetWidth-el.offsetWidth)/2;}}','var logContainerTop=logContainer.scrollTop;var logContainerBottom=logContainerTop+logContainer.offsetHeight;var elTop=getPageOffsetTop(el)-getToolBarsHeight();var elBottom=elTop+el.offsetHeight;if(elTop<logContainerTop||elBottom>logContainerBottom){logContainer.scrollTop=elTop-(logContainer.offsetHeight-el.offsetHeight)/2;}}','function Match(logEntryLevel,spanInMainDiv,spanInUnwrappedPre,spanInWrappedDiv){this.logEntryLevel=logEntryLevel;this.spanInMainDiv=spanInMainDiv;if(isIe){this.spanInUnwrappedPre=spanInUnwrappedPre;this.spanInWrappedDiv=spanInWrappedDiv;}','this.mainSpan=isIe?spanInUnwrappedPre:spanInMainDiv;}','Match.prototype={equals:function(match){return this.mainSpan===match.mainSpan;},setCurrent:function(){if(isIe){addClass(this.spanInUnwrappedPre,"currentmatch");addClass(this.spanInWrappedDiv,"currentmatch");var elementToScroll=$("wrap").checked?this.spanInWrappedDiv:this.spanInUnwrappedPre;scrollIntoView(elementToScroll);}else{addClass(this.spanInMainDiv,"currentmatch");scrollIntoView(this.spanInMainDiv);}},belongsTo:function(logEntry){if(isIe){return isDescendant(this.spanInUnwrappedPre,logEntry.unwrappedPre);}else{return isDescendant(this.spanInMainDiv,logEntry.mainDiv);}},setNotCurrent:function(){if(isIe){removeClass(this.spanInUnwrappedPre,"currentmatch");removeClass(this.spanInWrappedDiv,"currentmatch");}else{removeClass(this.spanInMainDiv,"currentmatch");}},isOrphan:function(){return isOrphan(this.mainSpan);},isVisible:function(){return getCheckBox(this.logEntryLevel).checked;},remove:function(){if(isIe){this.spanInUnwrappedPre=null;this.spanInWrappedDiv=null;}else{this.spanInMainDiv=null;}}};var currentSearch=null;var currentMatchIndex=null;function doSearch(){var searchBox=$("searchBox");var searchTerm=searchBox.value;var isRegex=$("searchRegex").checked;var isCaseSensitive=$("searchCaseSensitive").checked;var i;if(searchTerm===""){$("searchReset").disabled=true;$("searchNav").style.display="none";removeClass(document.body,"searching");removeClass(searchBox,"hasmatches");removeClass(searchBox,"nomatches");for(i=0;i<logEntries.length;i++){logEntries[i].clearSearch();logEntries[i].setContent(logEntries[i].formattedMessage,logEntries[i].formattedMessage);}','currentSearch=null;setLogContainerHeight();}else{$("searchReset").disabled=false;$("searchNav").style.display="block";var searchRegex;var regexValid;if(isRegex){try{searchRegex=isCaseSensitive?new RegExp(searchTerm,"g"):new RegExp(searchTerm,"gi");regexValid=true;replaceClass(searchBox,"validregex","invalidregex");searchBox.title="Valid regex";}catch(ex){regexValid=false;replaceClass(searchBox,"invalidregex","validregex");searchBox.title="Invalid regex: "+(ex.message?ex.message:(ex.description?ex.description:"unknown error"));return;}}else{searchBox.title="";removeClass(searchBox,"validregex");removeClass(searchBox,"invalidregex");}','addClass(document.body,"searching");currentSearch=new Search(searchTerm,isRegex,searchRegex,isCaseSensitive);for(i=0;i<logEntries.length;i++){currentSearch.applyTo(logEntries[i]);}','setLogContainerHeight();if(currentSearch.hasVisibleMatches()){setCurrentMatchIndex(0);displayMatches();}else{displayNoMatches();}}}','function updateSearchFromFilters(){if(currentSearch){if(currentSearch.hasMatches()){if(currentMatchIndex===null){currentMatchIndex=0;}','var currentMatch=currentSearch.matches[currentMatchIndex];if(currentMatch.isVisible()){displayMatches();setCurrentMatchIndex(currentMatchIndex);}else{currentMatch.setNotCurrent();var nextVisibleMatchIndex=currentSearch.getNextVisibleMatchIndex();if(nextVisibleMatchIndex>-1){setCurrentMatchIndex(nextVisibleMatchIndex);displayMatches();}else{displayNoMatches();}}}else{displayNoMatches();}}}','function refreshCurrentMatch(){if(currentSearch&&currentSearch.hasVisibleMatches()){setCurrentMatchIndex(currentMatchIndex);}}','function displayMatches(){replaceClass($("searchBox"),"hasmatches","nomatches");$("searchBox").title=""+currentSearch.matches.length+" matches found";$("searchNav").style.display="block";setLogContainerHeight();}','function displayNoMatches(){replaceClass($("searchBox"),"nomatches","hasmatches");$("searchBox").title="No matches found";$("searchNav").style.display="none";setLogContainerHeight();}','function toggleSearchEnabled(enable){enable=(typeof enable=="undefined")?!$("searchDisable").checked:enable;$("searchBox").disabled=!enable;$("searchReset").disabled=!enable;$("searchRegex").disabled=!enable;$("searchNext").disabled=!enable;$("searchPrevious").disabled=!enable;$("searchCaseSensitive").disabled=!enable;$("searchNav").style.display=(enable&&($("searchBox").value!=="")&&currentSearch&&currentSearch.hasVisibleMatches())?"block":"none";if(enable){removeClass($("search"),"greyedout");addClass(document.body,"searching");if($("searchHighlight").checked){addClass(logMainContainer,"searchhighlight");}else{removeClass(logMainContainer,"searchhighlight");}','if($("searchFilter").checked){addClass(logMainContainer,"searchfilter");}else{removeClass(logMainContainer,"searchfilter");}','$("searchDisable").checked=!enable;}else{addClass($("search"),"greyedout");removeClass(document.body,"searching");removeClass(logMainContainer,"searchhighlight");removeClass(logMainContainer,"searchfilter");}','setLogContainerHeight();}','function toggleSearchFilter(){var enable=$("searchFilter").checked;if(enable){addClass(logMainContainer,"searchfilter");}else{removeClass(logMainContainer,"searchfilter");}','refreshCurrentMatch();}','function toggleSearchHighlight(){var enable=$("searchHighlight").checked;if(enable){addClass(logMainContainer,"searchhighlight");}else{removeClass(logMainContainer,"searchhighlight");}}','function clearSearch(){$("searchBox").value="";doSearch();}','function searchNext(){if(currentSearch!==null&&currentMatchIndex!==null){currentSearch.matches[currentMatchIndex].setNotCurrent();var nextMatchIndex=currentSearch.getNextVisibleMatchIndex();if(nextMatchIndex>currentMatchIndex||confirm("Reached the end of the page. Start from the top?")){setCurrentMatchIndex(nextMatchIndex);}}}','function searchPrevious(){if(currentSearch!==null&&currentMatchIndex!==null){currentSearch.matches[currentMatchIndex].setNotCurrent();var previousMatchIndex=currentSearch.getPreviousVisibleMatchIndex();if(previousMatchIndex<currentMatchIndex||confirm("Reached the start of the page. Continue from the bottom?")){setCurrentMatchIndex(previousMatchIndex);}}}','function setCurrentMatchIndex(index){currentMatchIndex=index;currentSearch.matches[currentMatchIndex].setCurrent();}','function addClass(el,cssClass){if(!hasClass(el,cssClass)){if(el.className){el.className+=" "+cssClass;}else{el.className=cssClass;}}}','function hasClass(el,cssClass){if(el.className){var classNames=el.className.split(" ");return array_contains(classNames,cssClass);}','return false;}','function removeClass(el,cssClass){if(hasClass(el,cssClass)){var existingClasses=el.className.split(" ");var newClasses=[];for(var i=0,len=existingClasses.length;i<len;i++){if(existingClasses[i]!=cssClass){newClasses[newClasses.length]=existingClasses[i];}}','el.className=newClasses.join(" ");}}','function replaceClass(el,newCssClass,oldCssClass){removeClass(el,oldCssClass);addClass(el,newCssClass);}','function getElementsByClass(el,cssClass,tagName){var elements=el.getElementsByTagName(tagName);var matches=[];for(var i=0,len=elements.length;i<len;i++){if(hasClass(elements[i],cssClass)){matches.push(elements[i]);}}','return matches;}','function $(id){return document.getElementById(id);}','function isDescendant(node,ancestorNode){while(node!=null){if(node===ancestorNode){return true;}','node=node.parentNode;}','return false;}','function isOrphan(node){var currentNode=node;while(currentNode){if(currentNode==document.body){return false;}','currentNode=currentNode.parentNode;}','return true;}','function escapeHtml(str){return str.replace(/&/g,"&amp;").replace(/[<]/g,"&lt;").replace(/>/g,"&gt;");}','function getWindowWidth(){if(window.innerWidth){return window.innerWidth;}else if(document.documentElement&&document.documentElement.clientWidth){return document.documentElement.clientWidth;}else if(document.body){return document.body.clientWidth;}','return 0;}','function getWindowHeight(){if(window.innerHeight){return window.innerHeight;}else if(document.documentElement&&document.documentElement.clientHeight){return document.documentElement.clientHeight;}else if(document.body){return document.body.clientHeight;}','return 0;}','function getToolBarsHeight(){return $("switches").offsetHeight;}','function getChromeHeight(){var height=getToolBarsHeight();if(showCommandLine){height+=$("commandLine").offsetHeight;}','return height;}','function setLogContainerHeight(){if(logMainContainer){var windowHeight=getWindowHeight();$("body").style.height=getWindowHeight()+"px";logMainContainer.style.height=""+','Math.max(0,windowHeight-getChromeHeight())+"px";}}','function setCommandInputWidth(){if(showCommandLine){$("command").style.width=""+Math.max(0,$("commandLineContainer").offsetWidth-','($("evaluateButton").offsetWidth+13))+"px";}}','window.onresize=function(){setCommandInputWidth();setLogContainerHeight();};if(!Array.prototype.push){Array.prototype.push=function(){for(var i=0,len=arguments.length;i<len;i++){this[this.length]=arguments[i];}','return this.length;};}','if(!Array.prototype.pop){Array.prototype.pop=function(){if(this.length>0){var val=this[this.length-1];this.length=this.length-1;return val;}};}','if(!Array.prototype.shift){Array.prototype.shift=function(){if(this.length>0){var firstItem=this[0];for(var i=0,len=this.length-1;i<len;i++){this[i]=this[i+1];}','this.length=this.length-1;return firstItem;}};}','if(!Array.prototype.splice){Array.prototype.splice=function(startIndex,deleteCount){var itemsAfterDeleted=this.slice(startIndex+deleteCount);var itemsDeleted=this.slice(startIndex,startIndex+deleteCount);this.length=startIndex;var argumentsArray=[];for(var i=0,len=arguments.length;i<len;i++){argumentsArray[i]=arguments[i];}','var itemsToAppend=(argumentsArray.length>2)?itemsAfterDeleted=argumentsArray.slice(2).concat(itemsAfterDeleted):itemsAfterDeleted;for(i=0,len=itemsToAppend.length;i<len;i++){this.push(itemsToAppend[i]);}','return itemsDeleted;};}','function array_remove(arr,val){var index=-1;for(var i=0,len=arr.length;i<len;i++){if(arr[i]===val){index=i;break;}}','if(index>=0){arr.splice(index,1);return index;}else{return false;}}','function array_removeFromStart(array,numberToRemove){if(Array.prototype.splice){array.splice(0,numberToRemove);}else{for(var i=numberToRemove,len=array.length;i<len;i++){array[i-numberToRemove]=array[i];}','array.length=array.length-numberToRemove;}','return array;}','function array_contains(arr,val){for(var i=0,len=arr.length;i<len;i++){if(arr[i]==val){return true;}}','return false;}','function getErrorMessage(ex){if(ex.message){return ex.message;}else if(ex.description){return ex.description;}','return""+ex;}','function moveCaretToEnd(input){if(input.setSelectionRange){input.focus();var length=input.value.length;input.setSelectionRange(length,length);}else if(input.createTextRange){var range=input.createTextRange();range.collapse(false);range.select();}','input.focus();}','function stopPropagation(evt){if(evt.stopPropagation){evt.stopPropagation();}else if(typeof evt.cancelBubble!="undefined"){evt.cancelBubble=true;}}','function getEvent(evt){return evt?evt:event;}','function getTarget(evt){return evt.target?evt.target:evt.srcElement;}','function getRelatedTarget(evt){if(evt.relatedTarget){return evt.relatedTarget;}else if(evt.srcElement){switch(evt.type){case"mouseover":return evt.fromElement;case"mouseout":return evt.toElement;default:return evt.srcElement;}}}','function cancelKeyEvent(evt){evt.returnValue=false;stopPropagation(evt);}','function evalCommandLine(){var expr=$("command").value;evalCommand(expr);$("command").value="";}','function evalLastCommand(){if(lastCommand!=null){evalCommand(lastCommand);}}','var lastCommand=null;var commandHistory=[];var currentCommandIndex=0;function evalCommand(expr){if(appender){appender.evalCommandAndAppend(expr);}else{var prefix=">>> "+expr+"\\r\\n";try{log("INFO",prefix+eval(expr));}catch(ex){log("ERROR",prefix+"Error: "+getErrorMessage(ex));}}','if(expr!=commandHistory[commandHistory.length-1]){commandHistory.push(expr);if(appender){appender.storeCommandHistory(commandHistory);}}','currentCommandIndex=(expr==commandHistory[currentCommandIndex])?currentCommandIndex+1:commandHistory.length;lastCommand=expr;}','//]]>','</script>','<style type="text/css">','body{background-color:white;color:black;padding:0;margin:0;font-family:tahoma,verdana,arial,helvetica,sans-serif;overflow:hidden}div#switchesContainer input{margin-bottom:0}div.toolbar{border-top:solid #ffffff 1px;border-bottom:solid #aca899 1px;background-color:#f1efe7;padding:3px 5px;font-size:68.75%}div.toolbar,div#search input{font-family:tahoma,verdana,arial,helvetica,sans-serif}div.toolbar input.button{padding:0 5px;font-size:100%}div.toolbar input.hidden{display:none}div#switches input#clearButton{margin-left:20px}div#levels label{font-weight:bold}div#levels label,div#options label{margin-right:5px}div#levels label#wrapLabel{font-weight:normal}div#search label{margin-right:10px}div#search label.searchboxlabel{margin-right:0}div#search input{font-size:100%}div#search input.validregex{color:green}div#search input.invalidregex{color:red}div#search input.nomatches{color:white;background-color:#ff6666}div#search input.nomatches{color:white;background-color:#ff6666}div#searchNav{display:none}div#commandLine{display:none}div#commandLine input#command{font-size:100%;font-family:Courier New,Courier}div#commandLine input#evaluateButton{}*.greyedout{color:gray !important;border-color:gray !important}*.greyedout *.alwaysenabled{color:black}*.unselectable{-khtml-user-select:none;-moz-user-select:none;user-select:none}div#log{font-family:Courier New,Courier;font-size:75%;width:100%;overflow:auto;clear:both;position:relative}div.group{border-color:#cccccc;border-style:solid;border-width:1px 0 1px 1px;overflow:visible}div.oldIe div.group,div.oldIe div.group *,div.oldIe *.logentry{height:1%}div.group div.groupheading span.expander{border:solid black 1px;font-family:Courier New,Courier;font-size:0.833em;background-color:#eeeeee;position:relative;top:-1px;color:black;padding:0 2px;cursor:pointer;cursor:hand;height:1%}div.group div.groupcontent{margin-left:10px;padding-bottom:2px;overflow:visible}div.group div.expanded{display:block}div.group div.collapsed{display:none}*.logentry{overflow:visible;display:none;white-space:pre}span.pre{white-space:pre}pre.unwrapped{display:inline !important}pre.unwrapped pre.pre,div.wrapped pre.pre{display:inline}div.wrapped pre.pre{white-space:normal}div.wrapped{display:none}body.searching *.logentry span.currentmatch{color:white !important;background-color:green !important}body.searching div.searchhighlight *.logentry span.searchterm{color:black;background-color:yellow}div.wrap *.logentry{white-space:normal !important;border-width:0 0 1px 0;border-color:#dddddd;border-style:dotted}div.wrap #log_wrapped,#log_unwrapped{display:block}div.wrap #log_unwrapped,#log_wrapped{display:none}div.wrap *.logentry span.pre{overflow:visible;white-space:normal}div.wrap *.logentry pre.unwrapped{display:none}div.wrap *.logentry span.wrapped{display:inline}div.searchfilter *.searchnonmatch{display:none !important}div#log *.TRACE,label#label_TRACE{color:#666666}div#log *.DEBUG,label#label_DEBUG{color:green}div#log *.INFO,label#label_INFO{color:#000099}div#log *.WARN,label#label_WARN{color:#999900}div#log *.ERROR,label#label_ERROR{color:red}div#log *.FATAL,label#label_FATAL{color:#660066}div.TRACE#log *.TRACE,div.DEBUG#log *.DEBUG,div.INFO#log *.INFO,div.WARN#log *.WARN,div.ERROR#log *.ERROR,div.FATAL#log *.FATAL{display:block}div#log div.separator{background-color:#cccccc;margin:5px 0;line-height:1px}','</style>','</head>','<body id="body">','<div id="switchesContainer">','<div id="switches">','<div id="levels" class="toolbar">','Filters:','<input type="checkbox" id="switch_TRACE" onclick="applyFilters(); checkAllLevels()" checked="checked" title="Show/hide trace messages" /><label for="switch_TRACE" id="label_TRACE">trace</label>','<input type="checkbox" id="switch_DEBUG" onclick="applyFilters(); checkAllLevels()" checked="checked" title="Show/hide debug messages" /><label for="switch_DEBUG" id="label_DEBUG">debug</label>','<input type="checkbox" id="switch_INFO" onclick="applyFilters(); checkAllLevels()" checked="checked" title="Show/hide info messages" /><label for="switch_INFO" id="label_INFO">info</label>','<input type="checkbox" id="switch_WARN" onclick="applyFilters(); checkAllLevels()" checked="checked" title="Show/hide warn messages" /><label for="switch_WARN" id="label_WARN">warn</label>','<input type="checkbox" id="switch_ERROR" onclick="applyFilters(); checkAllLevels()" checked="checked" title="Show/hide error messages" /><label for="switch_ERROR" id="label_ERROR">error</label>','<input type="checkbox" id="switch_FATAL" onclick="applyFilters(); checkAllLevels()" checked="checked" title="Show/hide fatal messages" /><label for="switch_FATAL" id="label_FATAL">fatal</label>','<input type="checkbox" id="switch_ALL" onclick="toggleAllLevels(); applyFilters()" checked="checked" title="Show/hide all messages" /><label for="switch_ALL" id="label_ALL">all</label>','</div>','<div id="search" class="toolbar">','<label for="searchBox" class="searchboxlabel">Search:</label> <input type="text" id="searchBox" onclick="toggleSearchEnabled(true)" onkeyup="scheduleSearch()" size="20" />','<input type="button" id="searchReset" disabled="disabled" value="Reset" onclick="clearSearch()" class="button" title="Reset the search" />','<input type="checkbox" id="searchRegex" onclick="doSearch()" title="If checked, search is treated as a regular expression" /><label for="searchRegex">Regex</label>','<input type="checkbox" id="searchCaseSensitive" onclick="doSearch()" title="If checked, search is case sensitive" /><label for="searchCaseSensitive">Match case</label>','<input type="checkbox" id="searchDisable" onclick="toggleSearchEnabled()" title="Enable/disable search" /><label for="searchDisable" class="alwaysenabled">Disable</label>','<div id="searchNav">','<input type="button" id="searchNext" disabled="disabled" value="Next" onclick="searchNext()" class="button" title="Go to the next matching log entry" />','<input type="button" id="searchPrevious" disabled="disabled" value="Previous" onclick="searchPrevious()" class="button" title="Go to the previous matching log entry" />','<input type="checkbox" id="searchFilter" onclick="toggleSearchFilter()" title="If checked, non-matching log entries are filtered out" /><label for="searchFilter">Filter</label>','<input type="checkbox" id="searchHighlight" onclick="toggleSearchHighlight()" title="Highlight matched search terms" /><label for="searchHighlight" class="alwaysenabled">Highlight all</label>','</div>','</div>','<div id="options" class="toolbar">','Options:','<input type="checkbox" id="enableLogging" onclick="toggleLoggingEnabled()" checked="checked" title="Enable/disable logging" /><label for="enableLogging" id="enableLoggingLabel">Log</label>','<input type="checkbox" id="wrap" onclick="toggleWrap()" title="Enable / disable word wrap" /><label for="wrap" id="wrapLabel">Wrap</label>','<input type="checkbox" id="newestAtTop" onclick="toggleNewestAtTop()" title="If checked, causes newest messages to appear at the top" /><label for="newestAtTop" id="newestAtTopLabel">Newest at the top</label>','<input type="checkbox" id="scrollToLatest" onclick="toggleScrollToLatest()" checked="checked" title="If checked, window automatically scrolls to a new message when it is added" /><label for="scrollToLatest" id="scrollToLatestLabel">Scroll to latest</label>','<input type="button" id="clearButton" value="Clear" onclick="clearLog()" class="button" title="Clear all log messages"  />','<input type="button" id="hideButton" value="Hide" onclick="hide()" class="hidden button" title="Hide the console" />','<input type="button" id="closeButton" value="Close" onclick="closeWindow()" class="hidden button" title="Close the window" />','</div>','</div>','</div>','<div id="log" class="TRACE DEBUG INFO WARN ERROR FATAL"></div>','<div id="commandLine" class="toolbar">','<div id="commandLineContainer">','<input type="text" id="command" title="Enter a JavaScript command here and hit return or press \'Evaluate\'" />','<input type="button" id="evaluateButton" value="Evaluate" class="button" title="Evaluate the command" onclick="evalCommandLine()" />','</div>','</div>','</body>','</html>',''];};var defaultCommandLineFunctions=[];ConsoleAppender=function(){};var consoleAppenderIdCounter=1;ConsoleAppender.prototype=new Appender();ConsoleAppender.prototype.create=function(inPage,container,lazyInit,initiallyMinimized,useDocumentWrite,width,height,focusConsoleWindow){var appender=this;var initialized=false;var consoleWindowCreated=false;var consoleWindowLoaded=false;var consoleClosed=false;var queuedLoggingEvents=[];var isSupported=true;var consoleAppenderId=consoleAppenderIdCounter++;initiallyMinimized=extractBooleanFromParam(initiallyMinimized,this.defaults.initiallyMinimized);lazyInit=extractBooleanFromParam(lazyInit,this.defaults.lazyInit);useDocumentWrite=extractBooleanFromParam(useDocumentWrite,this.defaults.useDocumentWrite);var newestMessageAtTop=this.defaults.newestMessageAtTop;var scrollToLatestMessage=this.defaults.scrollToLatestMessage;width=width?width:this.defaults.width;height=height?height:this.defaults.height;var maxMessages=this.defaults.maxMessages;var showCommandLine=this.defaults.showCommandLine;var commandLineObjectExpansionDepth=this.defaults.commandLineObjectExpansionDepth;var showHideButton=this.defaults.showHideButton;var showCloseButton=this.defaults.showCloseButton;this.setLayout(this.defaults.layout);var init,createWindow,safeToAppend,getConsoleWindow,open;var appenderName=inPage?"InPageAppender":"PopUpAppender";var checkCanConfigure=function(configOptionName){if(consoleWindowCreated){handleError(appenderName+": configuration option '"+configOptionName+"' may not be set after the appender has been initialized");return false;}
return true;};var consoleWindowExists=function(){return(consoleWindowLoaded&&isSupported&&!consoleClosed);};this.isNewestMessageAtTop=function(){return newestMessageAtTop;};this.setNewestMessageAtTop=function(newestMessageAtTopParam){newestMessageAtTop=bool(newestMessageAtTopParam);if(consoleWindowExists()){getConsoleWindow().setNewestAtTop(newestMessageAtTop);}};this.isScrollToLatestMessage=function(){return scrollToLatestMessage;};this.setScrollToLatestMessage=function(scrollToLatestMessageParam){scrollToLatestMessage=bool(scrollToLatestMessageParam);if(consoleWindowExists()){getConsoleWindow().setScrollToLatest(scrollToLatestMessage);}};this.getWidth=function(){return width;};this.setWidth=function(widthParam){if(checkCanConfigure("width")){width=extractStringFromParam(widthParam,width);}};this.getHeight=function(){return height;};this.setHeight=function(heightParam){if(checkCanConfigure("height")){height=extractStringFromParam(heightParam,height);}};this.getMaxMessages=function(){return maxMessages;};this.setMaxMessages=function(maxMessagesParam){maxMessages=extractIntFromParam(maxMessagesParam,maxMessages);if(consoleWindowExists()){getConsoleWindow().setMaxMessages(maxMessages);}};this.isShowCommandLine=function(){return showCommandLine;};this.setShowCommandLine=function(showCommandLineParam){showCommandLine=bool(showCommandLineParam);if(consoleWindowExists()){getConsoleWindow().setShowCommandLine(showCommandLine);}};this.isShowHideButton=function(){return showHideButton;};this.setShowHideButton=function(showHideButtonParam){showHideButton=bool(showHideButtonParam);if(consoleWindowExists()){getConsoleWindow().setShowHideButton(showHideButton);}};this.isShowCloseButton=function(){return showCloseButton;};this.setShowCloseButton=function(showCloseButtonParam){showCloseButton=bool(showCloseButtonParam);if(consoleWindowExists()){getConsoleWindow().setShowCloseButton(showCloseButton);}};this.getCommandLineObjectExpansionDepth=function(){return commandLineObjectExpansionDepth;};this.setCommandLineObjectExpansionDepth=function(commandLineObjectExpansionDepthParam){commandLineObjectExpansionDepth=extractIntFromParam(commandLineObjectExpansionDepthParam,commandLineObjectExpansionDepth);};var minimized=initiallyMinimized;this.isInitiallyMinimized=function(){return initiallyMinimized;};this.setInitiallyMinimized=function(initiallyMinimizedParam){if(checkCanConfigure("initiallyMinimized")){initiallyMinimized=bool(initiallyMinimizedParam);minimized=initiallyMinimized;}};this.isUseDocumentWrite=function(){return useDocumentWrite;};this.setUseDocumentWrite=function(useDocumentWriteParam){if(checkCanConfigure("useDocumentWrite")){useDocumentWrite=bool(useDocumentWriteParam);}};function QueuedLoggingEvent(loggingEvent,formattedMessage){this.loggingEvent=loggingEvent;this.levelName=loggingEvent.level.name;this.formattedMessage=formattedMessage;}
QueuedLoggingEvent.prototype.append=function(){getConsoleWindow().log(this.levelName,this.formattedMessage);};function QueuedGroup(name,initiallyExpanded){this.name=name;this.initiallyExpanded=initiallyExpanded;}
QueuedGroup.prototype.append=function(){getConsoleWindow().group(this.name,this.initiallyExpanded);};function QueuedGroupEnd(){}
QueuedGroupEnd.prototype.append=function(){getConsoleWindow().groupEnd();};var checkAndAppend=function(){safeToAppend();if(!initialized){init();}else if(consoleClosed&&reopenWhenClosed){createWindow();}
if(safeToAppend()){appendQueuedLoggingEvents();}};this.append=function(loggingEvent){if(isSupported){var formattedMessage=appender.getLayout().formatWithException(loggingEvent);queuedLoggingEvents.push(new QueuedLoggingEvent(loggingEvent,formattedMessage));checkAndAppend();}};this.group=function(name,initiallyExpanded){if(isSupported){queuedLoggingEvents.push(new QueuedGroup(name,initiallyExpanded));checkAndAppend();}};this.groupEnd=function(){if(isSupported){queuedLoggingEvents.push(new QueuedGroupEnd());checkAndAppend();}};var appendQueuedLoggingEvents=function(){while(queuedLoggingEvents.length>0){queuedLoggingEvents.shift().append();}
if(focusConsoleWindow){getConsoleWindow().focus();}};this.setAddedToLogger=function(logger){this.loggers.push(logger);if(enabled&&!lazyInit){init();}};this.clear=function(){if(consoleWindowExists()){getConsoleWindow().clearLog();}
queuedLoggingEvents.length=0;};this.focus=function(){if(consoleWindowExists()){getConsoleWindow().focus();}};this.focusCommandLine=function(){if(consoleWindowExists()){getConsoleWindow().focusCommandLine();}};this.focusSearch=function(){if(consoleWindowExists()){getConsoleWindow().focusSearch();}};var commandWindow=window;this.getCommandWindow=function(){return commandWindow;};this.setCommandWindow=function(commandWindowParam){commandWindow=commandWindowParam;};this.executeLastCommand=function(){if(consoleWindowExists()){getConsoleWindow().evalLastCommand();}};var commandLayout=new PatternLayout("%m");this.getCommandLayout=function(){return commandLayout;};this.setCommandLayout=function(commandLayoutParam){commandLayout=commandLayoutParam;};this.evalCommandAndAppend=function(expr){var commandReturnValue={appendResult:true,isError:false};var commandOutput="";try{var result,i;if(!commandWindow.eval&&commandWindow.execScript){commandWindow.execScript("null");}
var commandLineFunctionsHash={};for(i=0,len=commandLineFunctions.length;i<len;i++){commandLineFunctionsHash[commandLineFunctions[i][0]]=commandLineFunctions[i][1];}
var objectsToRestore=[];var addObjectToRestore=function(name){objectsToRestore.push([name,commandWindow[name]]);};addObjectToRestore("appender");commandWindow.appender=appender;addObjectToRestore("commandReturnValue");commandWindow.commandReturnValue=commandReturnValue;addObjectToRestore("commandLineFunctionsHash");commandWindow.commandLineFunctionsHash=commandLineFunctionsHash;var addFunctionToWindow=function(name){addObjectToRestore(name);commandWindow[name]=function(){return this.commandLineFunctionsHash[name](appender,arguments,commandReturnValue);};};for(i=0,len=commandLineFunctions.length;i<len;i++){addFunctionToWindow(commandLineFunctions[i][0]);}
if(commandWindow===window&&commandWindow.execScript){addObjectToRestore("evalExpr");addObjectToRestore("result");window.evalExpr=expr;commandWindow.execScript("window.result=eval(window.evalExpr);");result=window.result;}else{result=commandWindow.eval(expr);}
commandOutput=isUndefined(result)?result:formatObjectExpansion(result,commandLineObjectExpansionDepth);for(i=0,len=objectsToRestore.length;i<len;i++){commandWindow[objectsToRestore[i][0]]=objectsToRestore[i][1];}}catch(ex){commandOutput="Error evaluating command: "+getExceptionStringRep(ex);commandReturnValue.isError=true;}
if(commandReturnValue.appendResult){var message=">>> "+expr;if(!isUndefined(commandOutput)){message+=newLine+commandOutput;}
var level=commandReturnValue.isError?Level.ERROR:Level.INFO;var loggingEvent=new LoggingEvent(null,new Date(),level,[message],null);var mainLayout=this.getLayout();this.setLayout(commandLayout);this.append(loggingEvent);this.setLayout(mainLayout);}};var commandLineFunctions=defaultCommandLineFunctions.concat([]);this.addCommandLineFunction=function(functionName,commandLineFunction){commandLineFunctions.push([functionName,commandLineFunction]);};var commandHistoryCookieName="log4javascriptCommandHistory";this.storeCommandHistory=function(commandHistory){setCookie(commandHistoryCookieName,commandHistory.join(","));};var writeHtml=function(doc){var lines=getConsoleHtmlLines();doc.open();for(var i=0,len=lines.length;i<len;i++){doc.writeln(lines[i]);}
doc.close();};this.setEventTypes(["load","unload"]);var consoleWindowLoadHandler=function(){var win=getConsoleWindow();win.setAppender(appender);win.setNewestAtTop(newestMessageAtTop);win.setScrollToLatest(scrollToLatestMessage);win.setMaxMessages(maxMessages);win.setShowCommandLine(showCommandLine);win.setShowHideButton(showHideButton);win.setShowCloseButton(showCloseButton);win.setMainWindow(window);var storedValue=getCookie(commandHistoryCookieName);if(storedValue){win.commandHistory=storedValue.split(",");win.currentCommandIndex=win.commandHistory.length;}
appender.dispatchEvent("load",{"win":win});};this.unload=function(){logLog.debug("unload "+this+", caller: "+this.unload.caller);if(!consoleClosed){logLog.debug("really doing unload "+this);consoleClosed=true;consoleWindowLoaded=false;consoleWindowCreated=false;appender.dispatchEvent("unload",{});}};var pollConsoleWindow=function(windowTest,interval,successCallback,errorMessage){function doPoll(){try{if(consoleClosed){clearInterval(poll);}
if(windowTest(getConsoleWindow())){clearInterval(poll);successCallback();}}catch(ex){clearInterval(poll);isSupported=false;handleError(errorMessage,ex);}}
var poll=setInterval(doPoll,interval);};var getConsoleUrl=function(){var documentDomainSet=(document.domain!=location.hostname);return useDocumentWrite?"":getBaseUrl()+"console.html"+
(documentDomainSet?"?log4javascript_domain="+escape(document.domain):"");};if(inPage){var containerElement=null;var cssProperties=[];this.addCssProperty=function(name,value){if(checkCanConfigure("cssProperties")){cssProperties.push([name,value]);}};var windowCreationStarted=false;var iframeContainerDiv;var iframeId=uniqueId+"_InPageAppender_"+consoleAppenderId;this.hide=function(){if(initialized&&consoleWindowCreated){if(consoleWindowExists()){getConsoleWindow().$("command").blur();}
iframeContainerDiv.style.display="none";minimized=true;}};this.show=function(){if(initialized){if(consoleWindowCreated){iframeContainerDiv.style.display="block";this.setShowCommandLine(showCommandLine);minimized=false;}else if(!windowCreationStarted){createWindow(true);}}};this.isVisible=function(){return!minimized&&!consoleClosed;};this.close=function(fromButton){if(!consoleClosed&&(!fromButton||confirm("This will permanently remove the console from the page. No more messages will be logged. Do you wish to continue?"))){iframeContainerDiv.parentNode.removeChild(iframeContainerDiv);this.unload();}};open=function(){var initErrorMessage="InPageAppender.open: unable to create console iframe";function finalInit(){try{if(!initiallyMinimized){appender.show();}
consoleWindowLoadHandler();consoleWindowLoaded=true;appendQueuedLoggingEvents();}catch(ex){isSupported=false;handleError(initErrorMessage,ex);}}
function writeToDocument(){try{var windowTest=function(win){return isLoaded(win);};if(useDocumentWrite){writeHtml(getConsoleWindow().document);}
if(windowTest(getConsoleWindow())){finalInit();}else{pollConsoleWindow(windowTest,100,finalInit,initErrorMessage);}}catch(ex){isSupported=false;handleError(initErrorMessage,ex);}}
minimized=false;iframeContainerDiv=containerElement.appendChild(document.createElement("div"));iframeContainerDiv.style.width=width;iframeContainerDiv.style.height=height;iframeContainerDiv.style.border="solid gray 1px";for(var i=0,len=cssProperties.length;i<len;i++){iframeContainerDiv.style[cssProperties[i][0]]=cssProperties[i][1];}
var iframeSrc=useDocumentWrite?"":" src='"+getConsoleUrl()+"'";iframeContainerDiv.innerHTML="<iframe id='"+iframeId+"' name='"+iframeId+"' width='100%' height='100%' frameborder='0'"+iframeSrc+" scrolling='no'></iframe>";consoleClosed=false;var iframeDocumentExistsTest=function(win){try{return bool(win)&&bool(win.document);}catch(ex){return false;}};if(iframeDocumentExistsTest(getConsoleWindow())){writeToDocument();}else{pollConsoleWindow(iframeDocumentExistsTest,100,writeToDocument,initErrorMessage);}
consoleWindowCreated=true;};createWindow=function(show){if(show||!initiallyMinimized){var pageLoadHandler=function(){if(!container){containerElement=document.createElement("div");containerElement.style.position="fixed";containerElement.style.left="0";containerElement.style.right="0";containerElement.style.bottom="0";document.body.appendChild(containerElement);appender.addCssProperty("borderWidth","1px 0 0 0");appender.addCssProperty("zIndex",1000000);open();}else{try{var el=document.getElementById(container);if(el.nodeType==1){containerElement=el;}
open();}catch(ex){handleError("InPageAppender.init: invalid container element '"+container+"' supplied",ex);}}};if(pageLoaded&&container&&container.appendChild){containerElement=container;open();}else if(pageLoaded){pageLoadHandler();}else{log4javascript.addEventListener("load",pageLoadHandler);}
windowCreationStarted=true;}};init=function(){createWindow();initialized=true;};getConsoleWindow=function(){var iframe=window.frames[iframeId];if(iframe){return iframe;}};safeToAppend=function(){if(isSupported&&!consoleClosed){if(consoleWindowCreated&&!consoleWindowLoaded&&getConsoleWindow()&&isLoaded(getConsoleWindow())){consoleWindowLoaded=true;}
return consoleWindowLoaded;}
return false;};}else{var useOldPopUp=appender.defaults.useOldPopUp;var complainAboutPopUpBlocking=appender.defaults.complainAboutPopUpBlocking;var reopenWhenClosed=this.defaults.reopenWhenClosed;this.isUseOldPopUp=function(){return useOldPopUp;};this.setUseOldPopUp=function(useOldPopUpParam){if(checkCanConfigure("useOldPopUp")){useOldPopUp=bool(useOldPopUpParam);}};this.isComplainAboutPopUpBlocking=function(){return complainAboutPopUpBlocking;};this.setComplainAboutPopUpBlocking=function(complainAboutPopUpBlockingParam){if(checkCanConfigure("complainAboutPopUpBlocking")){complainAboutPopUpBlocking=bool(complainAboutPopUpBlockingParam);}};this.isFocusPopUp=function(){return focusConsoleWindow;};this.setFocusPopUp=function(focusPopUpParam){focusConsoleWindow=bool(focusPopUpParam);};this.isReopenWhenClosed=function(){return reopenWhenClosed;};this.setReopenWhenClosed=function(reopenWhenClosedParam){reopenWhenClosed=bool(reopenWhenClosedParam);};this.close=function(){logLog.debug("close "+this);try{popUp.close();this.unload();}catch(ex){}};this.hide=function(){logLog.debug("hide "+this);if(consoleWindowExists()){this.close();}};this.show=function(){logLog.debug("show "+this);if(!consoleWindowCreated){open();}};this.isVisible=function(){return safeToAppend();};var popUp;open=function(){var windowProperties="width="+width+",height="+height+",status,resizable";var frameInfo="";try{var frameEl=window.frameElement;if(frameEl){frameInfo="_"+frameEl.tagName+"_"+(frameEl.name||frameEl.id||"");}}catch(e){frameInfo="_inaccessibleParentFrame";}
var windowName="PopUp_"+location.host.replace(/[^a-z0-9]/gi,"_")+"_"+consoleAppenderId+frameInfo;if(!useOldPopUp||!useDocumentWrite){windowName=windowName+"_"+uniqueId;}
var checkPopUpClosed=function(win){if(consoleClosed){return true;}else{try{return bool(win)&&win.closed;}catch(ex){}}
return false;};var popUpClosedCallback=function(){if(!consoleClosed){appender.unload();}};function finalInit(){getConsoleWindow().setCloseIfOpenerCloses(!useOldPopUp||!useDocumentWrite);consoleWindowLoadHandler();consoleWindowLoaded=true;appendQueuedLoggingEvents();pollConsoleWindow(checkPopUpClosed,500,popUpClosedCallback,"PopUpAppender.checkPopUpClosed: error checking pop-up window");}
try{popUp=window.open(getConsoleUrl(),windowName,windowProperties);consoleClosed=false;consoleWindowCreated=true;if(popUp&&popUp.document){if(useDocumentWrite&&useOldPopUp&&isLoaded(popUp)){popUp.mainPageReloaded();finalInit();}else{if(useDocumentWrite){writeHtml(popUp.document);}
var popUpLoadedTest=function(win){return bool(win)&&isLoaded(win);};if(isLoaded(popUp)){finalInit();}else{pollConsoleWindow(popUpLoadedTest,100,finalInit,"PopUpAppender.init: unable to create console window");}}}else{isSupported=false;logLog.warn("PopUpAppender.init: pop-ups blocked, please unblock to use PopUpAppender");if(complainAboutPopUpBlocking){handleError("log4javascript: pop-up windows appear to be blocked. Please unblock them to use pop-up logging.");}}}catch(ex){handleError("PopUpAppender.init: error creating pop-up",ex);}};createWindow=function(){if(!initiallyMinimized){open();}};init=function(){createWindow();initialized=true;};getConsoleWindow=function(){return popUp;};safeToAppend=function(){if(isSupported&&!isUndefined(popUp)&&!consoleClosed){if(popUp.closed||(consoleWindowLoaded&&isUndefined(popUp.closed))){appender.unload();logLog.debug("PopUpAppender: pop-up closed");return false;}
if(!consoleWindowLoaded&&isLoaded(popUp)){consoleWindowLoaded=true;}}
return isSupported&&consoleWindowLoaded&&!consoleClosed;};}
this.getConsoleWindow=getConsoleWindow;};ConsoleAppender.addGlobalCommandLineFunction=function(functionName,commandLineFunction){defaultCommandLineFunctions.push([functionName,commandLineFunction]);};function PopUpAppender(lazyInit,initiallyMinimized,useDocumentWrite,width,height){this.create(false,null,lazyInit,initiallyMinimized,useDocumentWrite,width,height,this.defaults.focusPopUp);}
PopUpAppender.prototype=new ConsoleAppender();PopUpAppender.prototype.defaults={layout:new PatternLayout("%d{HH:mm:ss} %-5p - %m{1}%n"),initiallyMinimized:false,focusPopUp:false,lazyInit:true,useOldPopUp:true,complainAboutPopUpBlocking:true,newestMessageAtTop:false,scrollToLatestMessage:true,width:"600",height:"400",reopenWhenClosed:false,maxMessages:null,showCommandLine:true,commandLineObjectExpansionDepth:1,showHideButton:false,showCloseButton:true,useDocumentWrite:true};PopUpAppender.prototype.toString=function(){return"PopUpAppender";};log4javascript.PopUpAppender=PopUpAppender;function InPageAppender(container,lazyInit,initiallyMinimized,useDocumentWrite,width,height){this.create(true,container,lazyInit,initiallyMinimized,useDocumentWrite,width,height,false);}
InPageAppender.prototype=new ConsoleAppender();InPageAppender.prototype.defaults={layout:new PatternLayout("%d{HH:mm:ss} %-5p - %m{1}%n"),initiallyMinimized:false,lazyInit:true,newestMessageAtTop:false,scrollToLatestMessage:true,width:"100%",height:"220px",maxMessages:null,showCommandLine:true,commandLineObjectExpansionDepth:1,showHideButton:false,showCloseButton:false,showLogEntryDeleteButtons:true,useDocumentWrite:true};InPageAppender.prototype.toString=function(){return"InPageAppender";};log4javascript.InPageAppender=InPageAppender;log4javascript.InlineAppender=InPageAppender;})();function padWithSpaces(str,len){if(str.length<len){var spaces=[];var numberOfSpaces=Math.max(0,len-str.length);for(var i=0;i<numberOfSpaces;i++){spaces[i]=" ";}
str+=spaces.join("");}
return str;}
(function(){function dir(obj){var maxLen=0;for(var p in obj){maxLen=Math.max(toStr(p).length,maxLen);}
var propList=[];for(p in obj){var propNameStr="  "+padWithSpaces(toStr(p),maxLen+2);var propVal;try{propVal=splitIntoLines(toStr(obj[p])).join(padWithSpaces(newLine,maxLen+6));}catch(ex){propVal="[Error obtaining property. Details: "+getExceptionMessage(ex)+"]";}
propList.push(propNameStr+propVal);}
return propList.join(newLine);}
var nodeTypes={ELEMENT_NODE:1,ATTRIBUTE_NODE:2,TEXT_NODE:3,CDATA_SECTION_NODE:4,ENTITY_REFERENCE_NODE:5,ENTITY_NODE:6,PROCESSING_INSTRUCTION_NODE:7,COMMENT_NODE:8,DOCUMENT_NODE:9,DOCUMENT_TYPE_NODE:10,DOCUMENT_FRAGMENT_NODE:11,NOTATION_NODE:12};var preFormattedElements=["script","pre"];var emptyElements=["br","img","hr","param","link","area","input","col","base","meta"];var indentationUnit="  ";function getXhtml(rootNode,includeRootNode,indentation,startNewLine,preformatted){includeRootNode=(typeof includeRootNode=="undefined")?true:!!includeRootNode;if(typeof indentation!="string"){indentation="";}
startNewLine=!!startNewLine;preformatted=!!preformatted;var xhtml;function isWhitespace(node){return((node.nodeType==nodeTypes.TEXT_NODE)&&/^[ \t\r\n]*$/.test(node.nodeValue));}
function fixAttributeValue(attrValue){return attrValue.toString().replace(/&/g,"&amp;").replace(/</g,"&lt;").replace(/"/g,"&quot;");}
function getStyleAttributeValue(el){var stylePairs=el.style.cssText.split(";");var styleValue="";for(var j=0,len=stylePairs.length;j<len;j++){var nameValueBits=stylePairs[j].split(":");var props=[];if(!/^\s*$/.test(nameValueBits[0])){props.push(trim(nameValueBits[0]).toLowerCase()+":"+trim(nameValueBits[1]));}
styleValue=props.join(";");}
return styleValue;}
function getNamespace(el){if(el.prefix){return el.prefix;}else if(el.outerHTML){var regex=new RegExp("<([^:]+):"+el.tagName+"[^>]*>","i");if(regex.test(el.outerHTML)){return RegExp.$1.toLowerCase();}}
return"";}
var lt="<";var gt=">";var i,len;if(includeRootNode&&rootNode.nodeType!=nodeTypes.DOCUMENT_FRAGMENT_NODE){switch(rootNode.nodeType){case nodeTypes.ELEMENT_NODE:var tagName=rootNode.tagName.toLowerCase();xhtml=startNewLine?newLine+indentation:"";xhtml+=lt;var prefix=getNamespace(rootNode);var hasPrefix=!!prefix;if(hasPrefix){xhtml+=prefix+":";}
xhtml+=tagName;for(i=0,len=rootNode.attributes.length;i<len;i++){var currentAttr=rootNode.attributes[i];if(!currentAttr.specified||currentAttr.nodeValue===null||currentAttr.nodeName.toLowerCase()==="style"||typeof currentAttr.nodeValue!=="string"||currentAttr.nodeName.indexOf("_moz")===0){continue;}
xhtml+=" "+currentAttr.nodeName.toLowerCase()+"=\"";xhtml+=fixAttributeValue(currentAttr.nodeValue);xhtml+="\"";}
if(rootNode.style.cssText){var styleValue=getStyleAttributeValue(rootNode);if(styleValue!==""){xhtml+=" style=\""+getStyleAttributeValue(rootNode)+"\"";}}
if(array_contains(emptyElements,tagName)||(hasPrefix&&!rootNode.hasChildNodes())){xhtml+="/"+gt;}else{xhtml+=gt;var childStartNewLine=!(rootNode.childNodes.length===1&&rootNode.childNodes[0].nodeType===nodeTypes.TEXT_NODE);var childPreformatted=array_contains(preFormattedElements,tagName);for(i=0,len=rootNode.childNodes.length;i<len;i++){xhtml+=getXhtml(rootNode.childNodes[i],true,indentation+indentationUnit,childStartNewLine,childPreformatted);}
var endTag=lt+"/"+tagName+gt;xhtml+=childStartNewLine?newLine+indentation+endTag:endTag;}
return xhtml;case nodeTypes.TEXT_NODE:if(isWhitespace(rootNode)){xhtml="";}else{if(preformatted){xhtml=rootNode.nodeValue;}else{var lines=splitIntoLines(trim(rootNode.nodeValue));var trimmedLines=[];for(i=0,len=lines.length;i<len;i++){trimmedLines[i]=trim(lines[i]);}
xhtml=trimmedLines.join(newLine+indentation);}
if(startNewLine){xhtml=newLine+indentation+xhtml;}}
return xhtml;case nodeTypes.CDATA_SECTION_NODE:return"<![CDA"+"TA["+rootNode.nodeValue+"]"+"]>"+newLine;case nodeTypes.DOCUMENT_NODE:xhtml="";for(i=0,len=rootNode.childNodes.length;i<len;i++){xhtml+=getXhtml(rootNode.childNodes[i],true,indentation);}
return xhtml;default:return"";}}else{xhtml="";for(i=0,len=rootNode.childNodes.length;i<len;i++){xhtml+=getXhtml(rootNode.childNodes[i],true,indentation+indentationUnit);}
return xhtml;}}
function createCommandLineFunctions(){ConsoleAppender.addGlobalCommandLineFunction("$",function(appender,args,returnValue){return document.getElementById(args[0]);});ConsoleAppender.addGlobalCommandLineFunction("dir",function(appender,args,returnValue){var lines=[];for(var i=0,len=args.length;i<len;i++){lines[i]=dir(args[i]);}
return lines.join(newLine+newLine);});ConsoleAppender.addGlobalCommandLineFunction("dirxml",function(appender,args,returnValue){var lines=[];for(var i=0,len=args.length;i<len;i++){lines[i]=getXhtml(args[i]);}
return lines.join(newLine+newLine);});ConsoleAppender.addGlobalCommandLineFunction("cd",function(appender,args,returnValue){var win,message;if(args.length===0||args[0]===""){win=window;message="Command line set to run in main window";}else{if(args[0].window==args[0]){win=args[0];message="Command line set to run in frame '"+args[0].name+"'";}else{win=window.frames[args[0]];if(win){message="Command line set to run in frame '"+args[0]+"'";}else{returnValue.isError=true;message="Frame '"+args[0]+"' does not exist";win=appender.getCommandWindow();}}}
appender.setCommandWindow(win);return message;});ConsoleAppender.addGlobalCommandLineFunction("clear",function(appender,args,returnValue){returnValue.appendResult=false;appender.clear();});ConsoleAppender.addGlobalCommandLineFunction("keys",function(appender,args,returnValue){var keys=[];for(var k in args[0]){keys.push(k);}
return keys;});ConsoleAppender.addGlobalCommandLineFunction("values",function(appender,args,returnValue){var values=[];for(var k in args[0]){try{values.push(args[0][k]);}catch(ex){logLog.warn("values(): Unable to obtain value for key "+k+". Details: "+getExceptionMessage(ex));}}
return values;});ConsoleAppender.addGlobalCommandLineFunction("expansionDepth",function(appender,args,returnValue){var expansionDepth=parseInt(args[0],10);if(isNaN(expansionDepth)||expansionDepth<0){returnValue.isError=true;return""+args[0]+" is not a valid expansion depth";}else{appender.setCommandLineObjectExpansionDepth(expansionDepth);return"Object expansion depth set to "+expansionDepth;}});}
function init(){createCommandLineFunctions();}
init();})();function createDefaultLogger(){var logger=log4javascript.getLogger(defaultLoggerName);var a=new log4javascript.PopUpAppender();logger.addAppender(a);return logger;}
log4javascript.setDocumentReady=function(){pageLoaded=true;log4javascript.dispatchEvent("load",{});};if(window.addEventListener){window.addEventListener("load",log4javascript.setDocumentReady,false);}else if(window.attachEvent){window.attachEvent("onload",log4javascript.setDocumentReady);}else{var oldOnload=window.onload;if(typeof window.onload!="function"){window.onload=log4javascript.setDocumentReady;}else{window.onload=function(evt){if(oldOnload){oldOnload(evt);}
log4javascript.setDocumentReady();};}}
return log4javascript;},this);

(function(){
'use strict';var aa=new Set("annotation-xml color-profile font-face font-face-src font-face-uri font-face-format font-face-name missing-glyph".split(" "));function g(b){var a=aa.has(b);b=/^[a-z][.0-9_a-z]*-[\-.0-9_a-z]*$/.test(b);return!a&&b}function l(b){var a=b.isConnected;if(void 0!==a)return a;for(;b&&!(b.__CE_isImportDocument||b instanceof Document);)b=b.parentNode||(window.ShadowRoot&&b instanceof ShadowRoot?b.host:void 0);return!(!b||!(b.__CE_isImportDocument||b instanceof Document))}
function p(b,a){for(;a&&a!==b&&!a.nextSibling;)a=a.parentNode;return a&&a!==b?a.nextSibling:null}
function q(b,a,d){d=void 0===d?new Set:d;for(var c=b;c;){if(c.nodeType===Node.ELEMENT_NODE){var e=c;a(e);var f=e.localName;if("link"===f&&"import"===e.getAttribute("rel")){c=e.import;if(c instanceof Node&&!d.has(c))for(d.add(c),c=c.firstChild;c;c=c.nextSibling)q(c,a,d);c=p(b,e);continue}else if("template"===f){c=p(b,e);continue}if(e=e.__CE_shadowRoot)for(e=e.firstChild;e;e=e.nextSibling)q(e,a,d)}c=c.firstChild?c.firstChild:p(b,c)}}function t(b,a,d){b[a]=d};function u(){this.a=new Map;this.f=new Map;this.c=[];this.b=!1}function ba(b,a,d){b.a.set(a,d);b.f.set(d.constructorFunction,d)}function v(b,a){b.b=!0;b.c.push(a)}function w(b,a){b.b&&q(a,function(a){return x(b,a)})}function x(b,a){if(b.b&&!a.__CE_patched){a.__CE_patched=!0;for(var d=0;d<b.c.length;d++)b.c[d](a)}}function y(b,a){var d=[];q(a,function(a){return d.push(a)});for(a=0;a<d.length;a++){var c=d[a];1===c.__CE_state?b.connectedCallback(c):z(b,c)}}
function A(b,a){var d=[];q(a,function(a){return d.push(a)});for(a=0;a<d.length;a++){var c=d[a];1===c.__CE_state&&b.disconnectedCallback(c)}}
function B(b,a,d){d=void 0===d?{}:d;var c=d.u||new Set,e=d.h||function(a){return z(b,a)},f=[];q(a,function(a){if("link"===a.localName&&"import"===a.getAttribute("rel")){var d=a.import;d instanceof Node&&(d.__CE_isImportDocument=!0,d.__CE_hasRegistry=!0);d&&"complete"===d.readyState?d.__CE_documentLoadHandled=!0:a.addEventListener("load",function(){var d=a.import;if(!d.__CE_documentLoadHandled){d.__CE_documentLoadHandled=!0;var f=new Set(c);f.delete(d);B(b,d,{u:f,h:e})}})}else f.push(a)},c);if(b.b)for(a=
0;a<f.length;a++)x(b,f[a]);for(a=0;a<f.length;a++)e(f[a])}
function z(b,a){if(void 0===a.__CE_state){var d=a.ownerDocument;if(d.defaultView||d.__CE_isImportDocument&&d.__CE_hasRegistry)if(d=b.a.get(a.localName)){d.constructionStack.push(a);var c=d.constructorFunction;try{try{if(new c!==a)throw Error("The custom element constructor did not produce the element being upgraded.");}finally{d.constructionStack.pop()}}catch(m){throw a.__CE_state=2,m;}a.__CE_state=1;a.__CE_definition=d;if(d.attributeChangedCallback)for(d=d.observedAttributes,c=0;c<d.length;c++){var e=
d[c],f=a.getAttribute(e);null!==f&&b.attributeChangedCallback(a,e,null,f,null)}l(a)&&b.connectedCallback(a)}}}u.prototype.connectedCallback=function(b){var a=b.__CE_definition;a.connectedCallback&&a.connectedCallback.call(b)};u.prototype.disconnectedCallback=function(b){var a=b.__CE_definition;a.disconnectedCallback&&a.disconnectedCallback.call(b)};
u.prototype.attributeChangedCallback=function(b,a,d,c,e){var f=b.__CE_definition;f.attributeChangedCallback&&-1<f.observedAttributes.indexOf(a)&&f.attributeChangedCallback.call(b,a,d,c,e)};function C(b){var a=document;this.c=b;this.a=a;this.b=void 0;B(this.c,this.a);"loading"===this.a.readyState&&(this.b=new MutationObserver(this.f.bind(this)),this.b.observe(this.a,{childList:!0,subtree:!0}))}function D(b){b.b&&b.b.disconnect()}C.prototype.f=function(b){var a=this.a.readyState;"interactive"!==a&&"complete"!==a||D(this);for(a=0;a<b.length;a++)for(var d=b[a].addedNodes,c=0;c<d.length;c++)B(this.c,d[c])};function ca(){var b=this;this.b=this.a=void 0;this.c=new Promise(function(a){b.b=a;b.a&&a(b.a)})}function E(b){if(b.a)throw Error("Already resolved.");b.a=void 0;b.b&&b.b(void 0)};function F(b){this.c=!1;this.a=b;this.j=new Map;this.f=function(a){return a()};this.b=!1;this.i=[];this.o=new C(b)}
F.prototype.l=function(b,a){var d=this;if(!(a instanceof Function))throw new TypeError("Custom element constructors must be functions.");if(!g(b))throw new SyntaxError("The element name '"+b+"' is not valid.");if(this.a.a.get(b))throw Error("A custom element with name '"+b+"' has already been defined.");if(this.c)throw Error("A custom element is already being defined.");this.c=!0;try{var c=function(a){var b=e[a];if(void 0!==b&&!(b instanceof Function))throw Error("The '"+a+"' callback must be a function.");
return b},e=a.prototype;if(!(e instanceof Object))throw new TypeError("The custom element constructor's prototype is not an object.");var f=c("connectedCallback");var m=c("disconnectedCallback");var k=c("adoptedCallback");var h=c("attributeChangedCallback");var n=a.observedAttributes||[]}catch(r){return}finally{this.c=!1}a={localName:b,constructorFunction:a,connectedCallback:f,disconnectedCallback:m,adoptedCallback:k,attributeChangedCallback:h,observedAttributes:n,constructionStack:[]};ba(this.a,
b,a);this.i.push(a);this.b||(this.b=!0,this.f(function(){return da(d)}))};F.prototype.h=function(b){B(this.a,b)};
function da(b){if(!1!==b.b){b.b=!1;for(var a=b.i,d=[],c=new Map,e=0;e<a.length;e++)c.set(a[e].localName,[]);B(b.a,document,{h:function(a){if(void 0===a.__CE_state){var e=a.localName,f=c.get(e);f?f.push(a):b.a.a.get(e)&&d.push(a)}}});for(e=0;e<d.length;e++)z(b.a,d[e]);for(;0<a.length;){var f=a.shift();e=f.localName;f=c.get(f.localName);for(var m=0;m<f.length;m++)z(b.a,f[m]);(e=b.j.get(e))&&E(e)}}}F.prototype.get=function(b){if(b=this.a.a.get(b))return b.constructorFunction};
F.prototype.m=function(b){if(!g(b))return Promise.reject(new SyntaxError("'"+b+"' is not a valid custom element name."));var a=this.j.get(b);if(a)return a.c;a=new ca;this.j.set(b,a);this.a.a.get(b)&&!this.i.some(function(a){return a.localName===b})&&E(a);return a.c};F.prototype.s=function(b){D(this.o);var a=this.f;this.f=function(d){return b(function(){return a(d)})}};window.CustomElementRegistry=F;F.prototype.define=F.prototype.l;F.prototype.upgrade=F.prototype.h;F.prototype.get=F.prototype.get;
F.prototype.whenDefined=F.prototype.m;F.prototype.polyfillWrapFlushCallback=F.prototype.s;var G=window.Document.prototype.createElement,H=window.Document.prototype.createElementNS,ea=window.Document.prototype.importNode,fa=window.Document.prototype.prepend,ha=window.Document.prototype.append,ia=window.DocumentFragment.prototype.prepend,ja=window.DocumentFragment.prototype.append,I=window.Node.prototype.cloneNode,J=window.Node.prototype.appendChild,K=window.Node.prototype.insertBefore,L=window.Node.prototype.removeChild,M=window.Node.prototype.replaceChild,N=Object.getOwnPropertyDescriptor(window.Node.prototype,
"textContent"),O=window.Element.prototype.attachShadow,P=Object.getOwnPropertyDescriptor(window.Element.prototype,"innerHTML"),Q=window.Element.prototype.getAttribute,R=window.Element.prototype.setAttribute,S=window.Element.prototype.removeAttribute,T=window.Element.prototype.getAttributeNS,U=window.Element.prototype.setAttributeNS,ka=window.Element.prototype.removeAttributeNS,la=window.Element.prototype.insertAdjacentElement,ma=window.Element.prototype.insertAdjacentHTML,na=window.Element.prototype.prepend,
oa=window.Element.prototype.append,V=window.Element.prototype.before,pa=window.Element.prototype.after,qa=window.Element.prototype.replaceWith,ra=window.Element.prototype.remove,sa=window.HTMLElement,W=Object.getOwnPropertyDescriptor(window.HTMLElement.prototype,"innerHTML"),ta=window.HTMLElement.prototype.insertAdjacentElement,ua=window.HTMLElement.prototype.insertAdjacentHTML;var va=new function(){};function wa(){var b=X;window.HTMLElement=function(){function a(){var a=this.constructor,c=b.f.get(a);if(!c)throw Error("The custom element being constructed was not registered with `customElements`.");var e=c.constructionStack;if(0===e.length)return e=G.call(document,c.localName),Object.setPrototypeOf(e,a.prototype),e.__CE_state=1,e.__CE_definition=c,x(b,e),e;c=e.length-1;var f=e[c];if(f===va)throw Error("The HTMLElement constructor was either called reentrantly for this constructor or called multiple times.");
e[c]=va;Object.setPrototypeOf(f,a.prototype);x(b,f);return f}a.prototype=sa.prototype;Object.defineProperty(a.prototype,"constructor",{writable:!0,configurable:!0,enumerable:!1,value:a});return a}()};function Y(b,a,d){function c(a){return function(d){for(var e=[],c=0;c<arguments.length;++c)e[c]=arguments[c];c=[];for(var f=[],n=0;n<e.length;n++){var r=e[n];r instanceof Element&&l(r)&&f.push(r);if(r instanceof DocumentFragment)for(r=r.firstChild;r;r=r.nextSibling)c.push(r);else c.push(r)}a.apply(this,e);for(e=0;e<f.length;e++)A(b,f[e]);if(l(this))for(e=0;e<c.length;e++)f=c[e],f instanceof Element&&y(b,f)}}void 0!==d.g&&(a.prepend=c(d.g));void 0!==d.append&&(a.append=c(d.append))};function xa(){var b=X;t(Document.prototype,"createElement",function(a){if(this.__CE_hasRegistry){var d=b.a.get(a);if(d)return new d.constructorFunction}a=G.call(this,a);x(b,a);return a});t(Document.prototype,"importNode",function(a,d){a=ea.call(this,a,!!d);this.__CE_hasRegistry?B(b,a):w(b,a);return a});t(Document.prototype,"createElementNS",function(a,d){if(this.__CE_hasRegistry&&(null===a||"http://www.w3.org/1999/xhtml"===a)){var c=b.a.get(d);if(c)return new c.constructorFunction}a=H.call(this,a,
d);x(b,a);return a});Y(b,Document.prototype,{g:fa,append:ha})};function ya(){function b(b,c){Object.defineProperty(b,"textContent",{enumerable:c.enumerable,configurable:!0,get:c.get,set:function(b){if(this.nodeType===Node.TEXT_NODE)c.set.call(this,b);else{var d=void 0;if(this.firstChild){var e=this.childNodes,k=e.length;if(0<k&&l(this)){d=Array(k);for(var h=0;h<k;h++)d[h]=e[h]}}c.set.call(this,b);if(d)for(b=0;b<d.length;b++)A(a,d[b])}}})}var a=X;t(Node.prototype,"insertBefore",function(b,c){if(b instanceof DocumentFragment){var e=Array.prototype.slice.apply(b.childNodes);
b=K.call(this,b,c);if(l(this))for(c=0;c<e.length;c++)y(a,e[c]);return b}e=l(b);c=K.call(this,b,c);e&&A(a,b);l(this)&&y(a,b);return c});t(Node.prototype,"appendChild",function(b){if(b instanceof DocumentFragment){var c=Array.prototype.slice.apply(b.childNodes);b=J.call(this,b);if(l(this))for(var e=0;e<c.length;e++)y(a,c[e]);return b}c=l(b);e=J.call(this,b);c&&A(a,b);l(this)&&y(a,b);return e});t(Node.prototype,"cloneNode",function(b){b=I.call(this,!!b);this.ownerDocument.__CE_hasRegistry?B(a,b):w(a,
b);return b});t(Node.prototype,"removeChild",function(b){var c=l(b),e=L.call(this,b);c&&A(a,b);return e});t(Node.prototype,"replaceChild",function(b,c){if(b instanceof DocumentFragment){var e=Array.prototype.slice.apply(b.childNodes);b=M.call(this,b,c);if(l(this))for(A(a,c),c=0;c<e.length;c++)y(a,e[c]);return b}e=l(b);var f=M.call(this,b,c),d=l(this);d&&A(a,c);e&&A(a,b);d&&y(a,b);return f});N&&N.get?b(Node.prototype,N):v(a,function(a){b(a,{enumerable:!0,configurable:!0,get:function(){for(var b=[],
a=0;a<this.childNodes.length;a++)b.push(this.childNodes[a].textContent);return b.join("")},set:function(b){for(;this.firstChild;)L.call(this,this.firstChild);J.call(this,document.createTextNode(b))}})})};function za(b){function a(a){return function(e){for(var c=[],d=0;d<arguments.length;++d)c[d]=arguments[d];d=[];for(var k=[],h=0;h<c.length;h++){var n=c[h];n instanceof Element&&l(n)&&k.push(n);if(n instanceof DocumentFragment)for(n=n.firstChild;n;n=n.nextSibling)d.push(n);else d.push(n)}a.apply(this,c);for(c=0;c<k.length;c++)A(b,k[c]);if(l(this))for(c=0;c<d.length;c++)k=d[c],k instanceof Element&&y(b,k)}}var d=Element.prototype;void 0!==V&&(d.before=a(V));void 0!==V&&(d.after=a(pa));void 0!==qa&&
t(d,"replaceWith",function(a){for(var c=[],d=0;d<arguments.length;++d)c[d]=arguments[d];d=[];for(var m=[],k=0;k<c.length;k++){var h=c[k];h instanceof Element&&l(h)&&m.push(h);if(h instanceof DocumentFragment)for(h=h.firstChild;h;h=h.nextSibling)d.push(h);else d.push(h)}k=l(this);qa.apply(this,c);for(c=0;c<m.length;c++)A(b,m[c]);if(k)for(A(b,this),c=0;c<d.length;c++)m=d[c],m instanceof Element&&y(b,m)});void 0!==ra&&t(d,"remove",function(){var a=l(this);ra.call(this);a&&A(b,this)})};function Aa(){function b(a,b){Object.defineProperty(a,"innerHTML",{enumerable:b.enumerable,configurable:!0,get:b.get,set:function(a){var d=this,e=void 0;l(this)&&(e=[],q(this,function(a){a!==d&&e.push(a)}));b.set.call(this,a);if(e)for(var f=0;f<e.length;f++){var m=e[f];1===m.__CE_state&&c.disconnectedCallback(m)}this.ownerDocument.__CE_hasRegistry?B(c,this):w(c,this);return a}})}function a(a,b){t(a,"insertAdjacentElement",function(a,d){var e=l(d);a=b.call(this,a,d);e&&A(c,d);l(a)&&y(c,d);return a})}
function d(a,b){function d(a,b){for(var d=[];a!==b;a=a.nextSibling)d.push(a);for(b=0;b<d.length;b++)B(c,d[b])}t(a,"insertAdjacentHTML",function(a,c){a=a.toLowerCase();if("beforebegin"===a){var e=this.previousSibling;b.call(this,a,c);d(e||this.parentNode.firstChild,this)}else if("afterbegin"===a)e=this.firstChild,b.call(this,a,c),d(this.firstChild,e);else if("beforeend"===a)e=this.lastChild,b.call(this,a,c),d(e||this.firstChild,null);else if("afterend"===a)e=this.nextSibling,b.call(this,a,c),d(this.nextSibling,
e);else throw new SyntaxError("The value provided ("+String(a)+") is not one of 'beforebegin', 'afterbegin', 'beforeend', or 'afterend'.");})}var c=X;O&&t(Element.prototype,"attachShadow",function(a){return this.__CE_shadowRoot=a=O.call(this,a)});P&&P.get?b(Element.prototype,P):W&&W.get?b(HTMLElement.prototype,W):v(c,function(a){b(a,{enumerable:!0,configurable:!0,get:function(){return I.call(this,!0).innerHTML},set:function(a){var b="template"===this.localName,c=b?this.content:this,d=H.call(document,
this.namespaceURI,this.localName);for(d.innerHTML=a;0<c.childNodes.length;)L.call(c,c.childNodes[0]);for(a=b?d.content:d;0<a.childNodes.length;)J.call(c,a.childNodes[0])}})});t(Element.prototype,"setAttribute",function(a,b){if(1!==this.__CE_state)return R.call(this,a,b);var d=Q.call(this,a);R.call(this,a,b);b=Q.call(this,a);c.attributeChangedCallback(this,a,d,b,null)});t(Element.prototype,"setAttributeNS",function(a,b,d){if(1!==this.__CE_state)return U.call(this,a,b,d);var e=T.call(this,a,b);U.call(this,
a,b,d);d=T.call(this,a,b);c.attributeChangedCallback(this,b,e,d,a)});t(Element.prototype,"removeAttribute",function(a){if(1!==this.__CE_state)return S.call(this,a);var b=Q.call(this,a);S.call(this,a);null!==b&&c.attributeChangedCallback(this,a,b,null,null)});t(Element.prototype,"removeAttributeNS",function(a,b){if(1!==this.__CE_state)return ka.call(this,a,b);var d=T.call(this,a,b);ka.call(this,a,b);var e=T.call(this,a,b);d!==e&&c.attributeChangedCallback(this,b,d,e,a)});ta?a(HTMLElement.prototype,
ta):la?a(Element.prototype,la):console.warn("Custom Elements: `Element#insertAdjacentElement` was not patched.");ua?d(HTMLElement.prototype,ua):ma?d(Element.prototype,ma):console.warn("Custom Elements: `Element#insertAdjacentHTML` was not patched.");Y(c,Element.prototype,{g:na,append:oa});za(c)};/*

 Copyright (c) 2016 The Polymer Project Authors. All rights reserved.
 This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
 The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
 The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
 Code distributed by Google as part of the polymer project is also
 subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/
var Z=window.customElements;if(!Z||Z.forcePolyfill||"function"!=typeof Z.define||"function"!=typeof Z.get){var X=new u;wa();xa();Y(X,DocumentFragment.prototype,{g:ia,append:ja});ya();Aa();document.__CE_hasRegistry=!0;var customElements=new F(X);Object.defineProperty(window,"customElements",{configurable:!0,enumerable:!0,value:customElements})};
}).call(self);

//# sourceMappingURL=custom-elements.min.js.map

// Polyfill for creating CustomEvents on IE9/10/11

// code pulled from:
// https://github.com/d4tocchini/customevent-polyfill
// https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent#Polyfill

(function() {
  if (typeof window === 'undefined') {
    return;
  }

  try {
    var ce = new window.CustomEvent('test', { cancelable: true });
    ce.preventDefault();
    if (ce.defaultPrevented !== true) {
      // IE has problems with .preventDefault() on custom events
      // http://stackoverflow.com/questions/23349191
      throw new Error('Could not prevent default');
    }
  } catch (e) {
    var CustomEvent = function(event, params) {
      var evt, origPrevent;
      params = params || {
        bubbles: false,
        cancelable: false,
        detail: undefined
      };

      evt = document.createEvent('CustomEvent');
      evt.initCustomEvent(
        event,
        params.bubbles,
        params.cancelable,
        params.detail
      );
      origPrevent = evt.preventDefault;
      evt.preventDefault = function() {
        origPrevent.call(this);
        try {
          Object.defineProperty(this, 'defaultPrevented', {
            get: function() {
              return true;
            }
          });
        } catch (e) {
          this.defaultPrevented = true;
        }
      };
      return evt;
    };

    CustomEvent.prototype = window.Event.prototype;
    window.CustomEvent = CustomEvent; // expose definition to window
  }
})();

/*
 * CommonAudioUtil()
 *
 * Common Util Object
 * includes common functions to audio decode.
 *
 */
function CommonAudioUtil() {
  "use strict";
  var power2 = [1, 2, 4, 8, 0x10, 0x20, 0x40, 0x80,0x100, 0x200, 0x400, 0x800, 0x1000, 0x2000, 0x4000];

  /*
   * quan()
   *
   * quantizes the input val against the table of size short integers.
   * It returns i if table[i - 1] <= val < table[i].
   *
   * Using linear search for simple coding.
   */
  var quan = function(val, table, size) { //int, *int, int
    var i; //int
    var k = 0;
    for (i = 0; i < size; i++) {
      if (val < table[k]) {
        break;
      } else {
        k++;
      }
    }
    return (i);
  };

  /*
   * fmult()
   *
   * returns the integer product of the 14-bit integer "an" and
   * "floating point" representation (4-bit exponent, 6-bit mantessa) "srn".
   */

  var fmult = function(an, srn) { // int, int
    var anmag;//int
    var anexp;//int
    var anmant;//int
    var wanexp;//int
    var wanmant;//int
    var retval;//int

    anmag = (an > 0) ? an : ((-an) & 0x1FFF);
    anexp = quan(anmag, power2, 15) - 6;
    anmant = (anmag === 0) ? 32 :
        (anexp >= 0) ? anmag >> anexp : anmag << -anexp;
    wanexp = anexp + ((srn >> 6) & 0xF) - 13;

    wanmant = (anmant * (srn & parseInt('077', 8)) + 0x30) >> 4;
    retval = (wanexp >= 0) ? ((wanmant << wanexp) & 0x7FFF) :
        (wanmant >> -wanexp);

    return (((an ^ srn) < 0) ? -retval : retval);
  };

  /*
   * g72x_init_state()
   *
   * This routine initializes and/or resets the g72x_state structure
   * pointed to by 'state_ptr'.
   * All the initial state values are specified in the CCITT G.721 document.
   */
  this.g726_init_state = function() {
   // var a[2];//int  /* Coefficients of pole portion of prediction filter. */
    // var b[6];//int  /* Coefficients of zero portion of prediction filter. */
    // var pk[2];//int /* Signs of previous two samples of a partially reconstructed signal. */
    // var dq[6];//short /* int here fails in newupdate on encode!
    //         // Previous 6 samples of the quantized difference
    //         // signal represented in an internal floating point
    //         // format.       
    // var sr[2];//int /* Previous 2 samples of the quantized difference
    var state_ptr = {};
    var cnta; //int
    state_ptr.a = new Array(2);
    state_ptr.b = new Array(6);
    state_ptr.pk = new Array(2);
    state_ptr.dq = new Array(6);
    state_ptr.sr = new Array(2);

    state_ptr.yl = 34816;
    state_ptr.yu = 544;
    state_ptr.dms = 0;
    state_ptr.dml = 0;
    state_ptr.ap = 0;
    for (cnta = 0; cnta < 2; cnta++) {
      state_ptr.a[cnta] = 0;
      state_ptr.pk[cnta] = 0;
      state_ptr.sr[cnta] = 32;
    }
    for (cnta = 0; cnta < 6; cnta++) {
      state_ptr.b[cnta] = 0;
      state_ptr.dq[cnta] = 32;
    }
    state_ptr.td = 0;

    // g726_state = state_ptr;
    return state_ptr;
  };

    /*
   * predictor_zero()
   *
   * computes the estimated signal from 6-zero predictor.
   *
   */
  this.predictor_zero = function(state_ptr) {
    var i;//int
    var sezi;//int
    sezi = fmult(state_ptr.b[0] >> 2, state_ptr.dq[0]);
    for (i = 1; i < 6; i++) {    /* ACCUM */
      sezi += fmult(state_ptr.b[i] >> 2, state_ptr.dq[i]);
    }
    return (sezi);
  };

  /*
   * predictor_pole()
   *
   * computes the estimated signal from 2-pole predictor.
   *
   */
  this.predictor_pole = function(state_ptr) {
    return (fmult(state_ptr.a[1] >> 2, state_ptr.sr[1]) +
        fmult(state_ptr.a[0] >> 2, state_ptr.sr[0]));
  };

  /*
   * step_size()
   *
   * computes the quantization step size of the adaptive quantizer.
   *
   */
  this.step_size = function(state_ptr) {
    var y;//int
    var dif;//int
    var al;//int
    if (state_ptr.ap >= 256) {
      return (state_ptr.yu);
    } else {
      y = state_ptr.yl >> 6;
      dif = state_ptr.yu - y;
      al = state_ptr.ap >> 2;
      if (dif > 0) {
        y += (dif * al) >> 6;
      } else if (dif < 0) {
        y += (dif * al + 0x3F) >> 6;
      }
      return (y);
    }
  };

  /*
   * quantize()
   *
   * Given a raw sample, 'd', of the difference signal and a
   * quantization step size scale factor, 'y', this routine returns the
   * ADPCM codeword to which that sample gets quantized.  The step
   * size scale factor division operation is done in the log base 2 domain
   * as a subtraction.
   */
  this.quantize = function(
    d,//int /* Raw difference signal sample */
    y,//int /* Step size multiplier */
    table,//int /* quantization table */ //wjuncho
    size)//int  /* table size of integers */
  {
    var   dqm;//int /* Magnitude of 'd' */
    var   exp;//int /* Integer part of base 2 log of 'd' */
    var   mant;//int  /* Fractional part of base 2 log */
    var   dl;//int  /* Log of magnitude of 'd' */
    var   dln;//int /* Step size scale factor normalized log */
    var   i;//int

    /*
     * LOG
     *
     * Compute base 2 log of 'd', and store in 'dl'.
     */
    dqm = Math.abs(d);
    exp = quan(dqm >> 1, power2, 15);
    mant = ((dqm << 7) >> exp) & 0x7F;  /* Fractional portion. */
    dl = (exp << 7) + mant;

    /*
     * SUBTB
     *
     * "Divide" by step size multiplier.
     */
    dln = dl - (y >> 2);

    /*
     * QUAN
     *
     * Obtain codword i for 'd'.
     */
    i = quan(dln, table, size);
    if (d < 0)      /* take 1's complement of i */
      return ((size << 1) + 1 - i);
    else if (i === 0)    /* take 1's complement of 0 */
      return ((size << 1) + 1); /* new in 1988 */
    else
      return (i);
  };
/*
 * reconstruct()
 *
 * Returns reconstructed difference signal 'dq' obtained from
 * codeword 'i' and quantization step size scale factor 'y'.
 * Multiplication is performed in log base 2 domain as addition.
 */
  this.reconstruct = function(
    sign,//int  /* 0 for non-negative value */
    dqln,//int  /* G.72x codeword */
    y)//int   /* Step size multiplier */
  {
    var   dql;//int /* Log of 'dq' magnitude */
    var   dex;//int /* Integer part of log */
    var   dqt;//int
    var   dq;//int    /* Reconstructed difference signal sample */

    dql = dqln + (y >> 2);  /* ADDA */

    if (dql < 0) {
      return ((sign) ? -0x8000 : 0);
    } else {    /* ANTILOG */
      dex = (dql >> 7) & 15;
      dqt = 128 + (dql & 127);
      dq = ((dqt << 7) >> (14 - dex)); //wjuncho convert it to (short) :: dq = (short)((dqt << 7) >> (14 - dex));
      return ((sign) ? (dq - 0x8000) : dq);
    }
  };


  /*
   * update()
   *
   * updates the state variables for each output code
   */
  this.update = function(
    code_size,//int /* distinguish 723_40 with others */
    y,//int   /* quantizer step size */
    wi,//int    /* scale factor multiplier */
    fi,//int    /* for long/short term energies */
    dq,//int    /* quantized prediction difference */
    sr,//int    /* reconstructed signal */
    dqsez,//int   /* difference from 2-pole predictor */
    state_ptr)  /* coder state pointer */
  {
    var   cnt;//int
    var   mag, exp;//int  /* Adaptive predictor, FLOAT A */
    var   a2p;//int   /* LIMC */
    var   a1ul;//int    /* UPA1 */
    var   pks1;//int    /* UPA2 */
    var   fa1;//int
    var   tr;//int      /* tone/transition detector */
    var   ylint, thr2, dqthr; //int
    var   ylfrac, thr1;//int
    var   pk0;//int

    pk0 = (dqsez < 0) ? 1 : 0;  /* needed in updating predictor poles */

    mag = dq & 0x7FFF;    /* prediction difference magnitude */
    /* TRANS */
    ylint = state_ptr.yl >> 15; /* exponent part of yl */
    ylfrac = (state_ptr.yl >> 10) & 0x1F; /* fractional part of yl */
    thr1 = (32 + ylfrac) << ylint;    /* threshold */
    thr2 = (ylint > 9) ? 31 << 10 : thr1; /* limit thr2 to 31 << 10 */
    dqthr = (thr2 + (thr2 >> 1)) >> 1;  /* dqthr = 0.75 * thr2 */
    if (state_ptr.td === 0)    /* signal supposed voice */
      tr = 0;
    else if (mag <= dqthr)    /* supposed data, but small mag */
      tr = 0;     /* treated as voice */
    else        /* signal is data (modem) */
      tr = 1;

    /*
     * Quantizer scale factor adaptation.
     */

    /* FUNCTW & FILTD & DELAY */
    /* update non-steady state step size multiplier */
    state_ptr.yu = y + ((wi - y) >> 5);

    /* LIMB */
    if (state_ptr.yu < 544) /* 544 <= yu <= 5120 */
      state_ptr.yu = 544;
    else if (state_ptr.yu > 5120)
      state_ptr.yu = 5120;

    /* FILTE & DELAY */
    /* update steady state step size multiplier */
    state_ptr.yl += state_ptr.yu + ((-state_ptr.yl) >> 6);

    /*
     * Adaptive predictor coefficients.
     */
    if (tr === 1) {      /* reset a's and b's for modem signal */
      state_ptr.a[0] = 0;
      state_ptr.a[1] = 0;
      state_ptr.b[0] = 0;
      state_ptr.b[1] = 0;
      state_ptr.b[2] = 0;
      state_ptr.b[3] = 0;
      state_ptr.b[4] = 0;
      state_ptr.b[5] = 0;
      a2p = 0 ;
    } else {      /* update a's and b's */
      pks1 = pk0 ^ state_ptr.pk[0];   /* UPA2 */

      /* update predictor pole a[1] */
      a2p = state_ptr.a[1] - (state_ptr.a[1] >> 7);
      if (dqsez !== 0) {
        fa1 = (pks1) ? state_ptr.a[0] : -state_ptr.a[0];
        if (fa1 < -8191) {  /* a2p = function of fa1 */
          a2p -= 0x100;
        } else if (fa1 > 8191) {
          a2p += 0xFF;
        } else {
          a2p += fa1 >> 5;
        }

        if (pk0 ^ state_ptr.pk[1]) {
          /* LIMC */
          if (a2p <= -12160) {
            a2p = -12288;
          } else if (a2p >= 12416) {
            a2p = 12288;
          } else {
            a2p -= 0x80;
          }
        } else if (a2p <= -12416) {
          a2p = -12288;
        } else if (a2p >= 12160) {
          a2p = 12288;
        } else {
          a2p += 0x80;
        }
      }

      /* TRIGB & DELAY */
      state_ptr.a[1] = a2p;

      /* UPA1 */
      /* update predictor pole a[0] */
      state_ptr.a[0] -= state_ptr.a[0] >> 8;
      if (dqsez !== 0) {
        if (pks1 === 0) {
          state_ptr.a[0] += 192;
        } else {
          state_ptr.a[0] -= 192;
        }
      }

      /* LIMD */
      a1ul = 15360 - a2p;
      if (state_ptr.a[0] < -a1ul) {
        state_ptr.a[0] = -a1ul;
      } else if (state_ptr.a[0] > a1ul) {
        state_ptr.a[0] = a1ul;
      }

      /* UPB : update predictor zeros b[6] */
      for (cnt = 0; cnt < 6; cnt++) {
        if (code_size === 5) {   /* for 40Kbps G.723 */
          state_ptr.b[cnt] -= state_ptr.b[cnt] >> 9;
        } else {      /* for G.721 and 24Kbps G.723 */
          state_ptr.b[cnt] -= state_ptr.b[cnt] >> 8;
        }
        if (dq & 0x7FFF) {      /* XOR */
          if ((dq ^ state_ptr.dq[cnt]) >= 0) {
            state_ptr.b[cnt] += 128;
          } else {
            state_ptr.b[cnt] -= 128;
          }
        }
      }
    }

    for (cnt = 5; cnt > 0; cnt--)
      state_ptr.dq[cnt] = state_ptr.dq[cnt-1];
    /* FLOAT A : convert dq[0] to 4-bit exp, 6-bit mantissa f.p. */
    if (mag === 0) {
      state_ptr.dq[0] = (dq >= 0) ? 0x20 : 0xFC20;
    } else {
      exp = quan(mag, power2, 15);
      state_ptr.dq[0] = ((dq >= 0) ? //wjuncho  state_ptr.dq[0] = (short)((dq >= 0) ?
          (exp << 6) + ((mag << 6) >> exp) :
          (exp << 6) + ((mag << 6) >> exp) - 0x400);
    }

    state_ptr.sr[1] = state_ptr.sr[0];
    /* FLOAT B : convert sr to 4-bit exp., 6-bit mantissa f.p. */
    if (sr === 0) {
      state_ptr.sr[0] = 0x20;
    } else if (sr > 0) {
      exp = quan(sr, power2, 15);
      state_ptr.sr[0] = (exp << 6) + ((sr << 6) >> exp);
    } else if (sr > -32768) {
      mag = -sr;
      exp = quan(mag, power2, 15);
      state_ptr.sr[0] =  (exp << 6) + ((mag << 6) >> exp) - 0x400;
    } else {
      state_ptr.sr[0] = 0xFC20;
    }
    /* DELAY A */
    state_ptr.pk[1] = state_ptr.pk[0];
    state_ptr.pk[0] = pk0;

    /* TONE */
    if (tr === 1) {   /* this sample has been treated as data */
      state_ptr.td = 0; /* next one will be treated as voice */
    } else if (a2p < -11776) {  /* small sample-to-sample correlation */
      state_ptr.td = 1; /* signal may be data */
    } else {        /* signal is voice */
      state_ptr.td = 0;
    }

    /*
     * Adaptation speed control.
     */
    state_ptr.dms += (fi - state_ptr.dms) >> 5;   /* FILTA */
    state_ptr.dml += (((fi << 2) - state_ptr.dml) >> 7);  /* FILTB */

    if (tr === 1) {
      state_ptr.ap = 256;
    } else if (y < 1536) {          /* SUBTC */
      state_ptr.ap += (0x200 - state_ptr.ap) >> 4;
    } else if (state_ptr.td === 1) {
      state_ptr.ap += (0x200 - state_ptr.ap) >> 4;
    } else if (Math.abs((state_ptr.dms << 2) - state_ptr.dml) >=
        (state_ptr.dml >> 3)) {
      state_ptr.ap += (0x200 - state_ptr.ap) >> 4;
    } else {
      state_ptr.ap += (-state_ptr.ap) >> 4;
    }
    return state_ptr;
  };

    /*
   * tandem_adjust(sr, se, y, i, sign)
   *
   * At the end of ADPCM decoding, it simulates an encoder which may be receiving
   * the output of this decoder as a tandem process. If the output of the
   * simulated encoder differs from the input to this decoder, the decoder output
   * is adjusted by one level of A-law or u-law codes.
   *
   * Input:
   *  sr  decoder output linear PCM sample,
   *  se  predictor estimate sample,
   *  y quantizer step size,
   *  i decoder input code,
   *  sign  sign bit of code i
   *
   * Return:
   *  adjusted A-law or u-law compressed sample.
   */
  // var tandem_adjust_alaw = function(
  //   sr, /* decoder output linear PCM sample */ //int
  //   se, /* predictor estimate sample */ //int
  //   y,  /* quantizer step size */ //int
  //   i,  /* decoder input code */ //int
  //   sign,  //int
  //   qtab) //*int
  // {
  //   var sp; /* A-law compressed 8-bit code */
  //   var dx; /* prediction error */
  //   var id; /* quantized prediction error */
  //   var sd; /* adjusted A-law decoded sample value */
  //   var im; /* biased magnitude of i */
  //   var imx;  /* biased magnitude of id */

  //   if (sr <= -32768)
  //     sr = -1;
  //   sp = linear2alaw((sr >> 1) << 3); /* short to A-law compression */
  //   dx = (alaw2linear(sp) >> 2) - se; /* 16-bit prediction error */
  //   id = quantize(dx, y, qtab, sign - 1);

  //   if (id === i) {       no adjustment on sp 
  //     return (sp);
  //   } else {      /* sp adjustment needed */
  //     /* ADPCM codes : 8, 9, ... F, 0, 1, ... , 6, 7 */
  //     im = i ^ sign;    /* 2's complement to biased unsigned */
  //     imx = id ^ sign;

  //     if (imx > im) {   /* sp adjusted to next lower value */
  //       if (sp & 0x80) {
  //         sd = (sp === 0xD5) ? 0x55 :
  //             ((sp ^ 0x55) - 1) ^ 0x55;
  //       } else {
  //         sd = (sp === 0x2A) ? 0x2A :
  //             ((sp ^ 0x55) + 1) ^ 0x55;
  //       }
  //     } else {    /* sp adjusted to next higher value */
  //       if (sp & 0x80)
  //         sd = (sp === 0xAA) ? 0xAA :
  //             ((sp ^ 0x55) + 1) ^ 0x55;
  //       else
  //         sd = (sp === 0x55) ? 0xD5 :
  //             ((sp ^ 0x55) - 1) ^ 0x55;
  //     }
  //     return (sd);
  //   }
  // };

  // var tandem_adjust_ulaw = function(
  //   sr, /* decoder output linear PCM sample */ // int
  //   se, /* predictor estimate sample */ // int
  //   y,  /* quantizer step size */ // int
  //   i,  /* decoder input code */ // int
  //   sign, // int
  //   qtab) // *int
  // {
  //   var sp; /* u-law compressed 8-bit code */
  //   var dx; /* prediction error */
  //   var id; /* quantized prediction error */
  //   var sd; /* adjusted u-law decoded sample value */
  //   var im; /* biased magnitude of i */
  //   var imx;  /* biased magnitude of id */

  //   if (sr <= -32768){
  //     sr = 0;
  //   }
  //   sp = linear2ulaw(sr << 2);  /* short to u-law compression */
  //   dx = (ulaw2linear(sp) >> 2) - se;  16-bit prediction error 
  //   id = quantize(dx, y, qtab, sign - 1);
  //   if (id === i) {
  //     return (sp);
  //   } else {
  //     /* ADPCM codes : 8, 9, ... F, 0, 1, ... , 6, 7 */
  //     im = i ^ sign;    /* 2's complement to biased unsigned */
  //     imx = id ^ sign;
  //     if (imx > im) {   /* sp adjusted to next lower value */
  //       if (sp & 0x80)
  //         sd = (sp === 0xFF) ? 0x7E : sp + 1;
  //       else
  //         sd = (sp === 0) ? 0 : sp - 1;

  //     } else {    /* sp adjusted to next higher value */
  //       if (sp & 0x80)
  //         sd = (sp === 0x80) ? 0x80 : sp - 1;
  //       else
  //         sd = (sp === 0x7F) ? 0xFE : sp + 1;
  //     }
  //     return (sd);
  //   }
  // };  

  // constructor.prototype = {
  //   quan: function(val, table, size) {
  //     return quan(val, table, size);
  //   },
  //   fmult: function(an, srn) {
  //     return fmult(an, srn);
  //   },
  //   g726_init_state: function() {
  //     return g726_init_state();
  //   },
  //   predictor_zero: function(state_ptr) {
  //     return predictor_zero(state_ptr);
  //   },
  //   predictor_pole: function(state_ptr) {
  //     return predictor_pole(state_ptr);
  //   },
  //   step_size: function(state_ptr) {
  //     return step_size(state_ptr);
  //   },
  //   quantize: function(d, y, table, size) {
  //     return quantize(d, y, table, size);
  //   },
  //   reconstruct: function(sign, dqln, y) {
  //     return reconstruct(sign, dqln, y);
  //   },
  //   update: function(code_size, y, wi, fi, dq, sr, dqsez, state_ptr) {
  //     return update(code_size, y, wi, fi, dq, sr, dqsez, state_ptr);
  //   },
  //   // tandem_adjust_alaw: function(sr, se, y, i, sign, qtab) {
  //   //   return tandem_adjust_alaw(sr, se, y, i, sign, qtab);
  //   // },
  //   // tandem_adjust_ulaw: function(sr, se, y, i, sign, qtab) {
  //   //   return tandem_adjust_ulaw(sr, se, y, i, sign, qtab);
  //   // }
  // };
  // return new constructor();
}
var DigestGenerator = function () {
    var module = {};

    module.formulateResponse = function (username, password, url, realm, method, nonce) {
        var HA1 = CryptoJS.MD5(username + ':' + realm + ':' + password).toString();
        var HA2 = CryptoJS.MD5(method + ':' + url).toString();
        var response = CryptoJS.MD5(HA1 + ':' + nonce + ':' + HA2).toString();
        return response;
    };

    module.getDigestInfoInWwwAuthenticate = function (wwwAuthenticate) {
        var digestHeaders = wwwAuthenticate;
        var realm = null;
        var nonce = null;

        if (digestHeaders !== null) {
            digestHeaders = digestHeaders.split(',');

            for (var i = 0; i < digestHeaders.length; i++) {
                var keyVal = digestHeaders[i].split('=');
                var key = keyVal[0];
                var val = keyVal[1].replace(/\"/g, '').trim();

                if (key.match(/realm/i) !== null) {
                    realm = val;
                }

                if (key.match(/nonce/i) !== null) {
                    nonce = val;
                }
            }
        }

        return {
            "realm": realm,
            "nonce": nonce,
        };
    };
    
    return module;
};
/* global Float32Array, THREE */
function Fisheye3DMulti() {
  var camera,
    scene,
    renderer,
    texture_placeholder,
    isUserInteracting = false,
    onMouseDownMouseX = 0,
    onMouseDownMouseY = 0,
    onMouseDownLon = 0,
    onMouseDownLat = 0,
    lon = 0,
    lat = 0,
    phi = 0,
    theta = 0,
    distance = 230,
    distanceNear = 500,
    resol = 2992.0,
    initFov = 45,
    fov = initFov,
    mindist = 0.0000000001,
    tex,
    minimapCamera,
    cameraHelper;

  var meshVertex = (function () {
    function meshVertex(vertex) {
      var _this = this;
      if (((vertex != null && vertex instanceof meshVertex) || vertex === null)) {
        this.u = 0;
        this.v = 0;
        this.x = 0;
        this.y = 0;
        this.z = 0;
        (function () {
          _this.x = vertex.x;
          _this.y = vertex.y;
          _this.z = vertex.z;
          _this.u = vertex.u;
          _this.v = vertex.v;
        })();
      } else if (vertex === undefined) {
        this.u = 0;
        this.v = 0;
        this.x = 0;
        this.y = 0;
        this.z = 0;
        (function () {
          _this.v = 0.0;
          _this.u = 0.0;
          _this.z = 0.0;
          _this.y = 0.0;
          _this.x = 0.0;
        })();
      } else {
        throw new Error('invalid overload');
      }
    }
    return meshVertex;
  }());

  var GridMesh = (function () {
    function GridMesh() {
      this.m_InvertX = false;
      this.m_InvertY = false;
      this.m_FisheyeHeight = 0;
      this.m_FisheyeWidth = 0;
      this.m_NumTriangles = 0;
      this.m_TextureHeight = 0;
      this.m_TextureWidth = 0;
    }
    GridMesh.prototype.ClipToCircle = function (vertex) {
      var centerX = this.m_FisheyeConfig.GetCenterX();
      var centerY = this.m_FisheyeConfig.GetCenterY();
      var maxRadius = this.m_FisheyeConfig.GetMaxRadius();
      var var8 = Math.sqrt((vertex.u - centerX) * (vertex.u - centerX) + (vertex.v - centerY) * (vertex.v - centerY));
      var var10;
      if (var8 < maxRadius) {
        var10 = true;
      } else {
        var10 = false;
      }
      if (!var10) {
        maxRadius /= var8;
        vertex.u = (vertex.u - centerX) * maxRadius + centerX;
        vertex.v = (vertex.v - centerY) * maxRadius + centerY;
      }
      return var10;
    };
    GridMesh.prototype.CreateTriangle = function (var1, var2, var3) {
      var1 = new meshVertex(var1);
      var2 = new meshVertex(var2);
      var3 = new meshVertex(var3);

      var v1 = this.ClipToCircle(var1);
      var v2 = this.ClipToCircle(var2);
      var v3 = this.ClipToCircle(var3);
      var n1 = this.Normalize(var1);
      var n2 = this.Normalize(var2);
      var n3 = this.Normalize(var3);

      if ((v1 || v2 || v3) && (n1 || n2 || n3)) {
        this.Find3DPos(var1);
        this.Find3DPos(var2);
        this.Find3DPos(var3);
        this.m_Triangles[this.m_NumTriangles * 5 * 3 + 0 + 0] = var1.x;
        this.m_Triangles[this.m_NumTriangles * 5 * 3 + 0 + 1] = var1.y;
        this.m_Triangles[this.m_NumTriangles * 5 * 3 + 0 + 2] = var1.z;
        this.m_Triangles[this.m_NumTriangles * 5 * 3 + 0 + 3] = var1.u;
        this.m_Triangles[this.m_NumTriangles * 5 * 3 + 0 + 4] = var1.v;
        this.m_Triangles[this.m_NumTriangles * 5 * 3 + 5 + 0] = var2.x;
        this.m_Triangles[this.m_NumTriangles * 5 * 3 + 5 + 1] = var2.y;
        this.m_Triangles[this.m_NumTriangles * 5 * 3 + 5 + 2] = var2.z;
        this.m_Triangles[this.m_NumTriangles * 5 * 3 + 5 + 3] = var2.u;
        this.m_Triangles[this.m_NumTriangles * 5 * 3 + 5 + 4] = var2.v;
        this.m_Triangles[this.m_NumTriangles * 5 * 3 + 10 + 0] = var3.x;
        this.m_Triangles[this.m_NumTriangles * 5 * 3 + 10 + 1] = var3.y;
        this.m_Triangles[this.m_NumTriangles * 5 * 3 + 10 + 2] = var3.z;
        this.m_Triangles[this.m_NumTriangles * 5 * 3 + 10 + 3] = var3.u;
        this.m_Triangles[this.m_NumTriangles * 5 * 3 + 10 + 4] = var3.v;
        ++this.m_NumTriangles;
      }
    };
    GridMesh.prototype.Find3DPos = function (vertex) {
      var var6 = vertex.u;
      var textureWidth = this.m_TextureWidth;
      var var2 = vertex.v;
      var textureHeight = this.m_TextureHeight;
      var6 = var6 * textureWidth - this.m_FisheyeConfig.GetCenterX();
      textureHeight = var2 * textureHeight - this.m_FisheyeConfig.GetCenterY();
      var2 = textureHeight;
      if (this.m_InvertY) {
        var2 = -textureHeight;
      }
      textureHeight = var6;
      if (this.m_InvertX) {
        textureHeight = -var6;
      }
      textureWidth = this.m_FisheyeConfig.GetMaxRadius();
      var var10 = Math.sqrt(textureHeight * textureHeight + var2 * var2);
      var6 = var10;
      if (var10 > textureWidth) {
        var6 = textureWidth;
      }
      var6 = 0.017453293 * this.m_FisheyeConfig.GetFOV(var6) / 2.0;
      var2 = Math.atan2(var2, textureHeight);
      vertex.z = Math.cos(var6);
      vertex.y = Math.sin(var6) * Math.sin(var2);
      vertex.x = Math.sin(var6) * Math.cos(var2);
    };
    GridMesh.prototype.GenerateMesh = function (var1, fisheyeConfig, fisheyeWidth, fisheyeHeight, textureWidth, textureHeight, invertX, invertY) {
      this.m_InvertX = invertX;
      this.m_InvertY = invertY;
      this.m_FisheyeConfig = fisheyeConfig;
      this.m_FisheyeWidth = fisheyeWidth;
      this.m_FisheyeHeight = fisheyeHeight;
      this.m_TextureWidth = textureWidth;
      this.m_TextureHeight = textureHeight;
      var var10 = 3.0 * var1 / 4.0;
      var maxRadius = this.m_FisheyeConfig.GetMaxRadius();
      var var19 = new meshVertex();
      var var16 = new meshVertex();
      var var17 = new meshVertex();
      var var18 = new meshVertex();
      this.m_NumTriangles = 0;
      textureWidth = (Math.ceil(maxRadius / var1 + 0.5) | 0) * 2;
      var var12 = this.m_FisheyeConfig.GetCenterX() - ((textureWidth / 2 | 0)) * var1;
      textureHeight = (Math.ceil(maxRadius / var10) | 0) * 2;
      maxRadius = this.m_FisheyeConfig.GetCenterY() - ((textureHeight / 2 | 0)) * var10;
      this.m_Triangles = new Array(textureWidth * 30 * textureHeight);
      for (fisheyeWidth = 0; fisheyeWidth < textureHeight; ++fisheyeWidth) {
        for (fisheyeHeight = 0; fisheyeHeight < textureWidth; ++fisheyeHeight) {
          var19.v = fisheyeWidth * var10 + maxRadius;
          var16.v = fisheyeWidth * var10 + maxRadius;
          var17.v = (fisheyeWidth + 1) * var10 + maxRadius;
          var18.v = (fisheyeWidth + 1) * var10 + maxRadius;
          if (fisheyeWidth % 2 === 0) {
            var16.u = (fisheyeHeight + 1) * var1 + var12;
            var19.u = fisheyeHeight * var1 + var12;
            var17.u = var1 / 2.0 + fisheyeHeight * var1 + var12;
            var18.u = var1 / 2.0 + (fisheyeHeight + 1) * var1 + var12;
            this.CreateTriangle(var19, var17, var16);
            this.CreateTriangle(var16, var17, var18);
          } else {
            var19.u = var1 / 2.0 + var12 + fisheyeHeight * var1;
            var16.u = var1 / 2.0 + var12 + (fisheyeHeight + 1) * var1;
            var17.u = fisheyeHeight * var1 + var12;
            var18.u = (fisheyeHeight + 1) * var1 + var12;
            this.CreateTriangle(var19, var18, var16);
            this.CreateTriangle(var19, var17, var18);
          }
        }
      }
    };
    GridMesh.prototype.GetTriangleCount = function () {
      return this.m_NumTriangles;
    };
    GridMesh.prototype.GetTriangles = function () {
      return this.m_Triangles;
    };
    GridMesh.prototype.Normalize = function (vertex) {
      var var2 = true;
      vertex.u /= this.m_FisheyeWidth;
      vertex.v /= this.m_FisheyeHeight;
      if (vertex.u < 0.0) {
        vertex.u = 0.0;
        var2 = false;
      }
      if (vertex.u > 1.0) {
        vertex.u = 1.0;
        var2 = false;
      }
      if (vertex.v < 0.0) {
        vertex.v = 0.0;
        var2 = false;
      }
      if (vertex.v > 1.0) {
        vertex.v = 1.0;
        var2 = false;
      }
      vertex.u *= this.m_FisheyeWidth / this.m_TextureWidth;
      vertex.v *= this.m_FisheyeHeight / this.m_TextureHeight;
      return var2;
    };
    GridMesh.DEGREETORAD = 0.017453293;
    return GridMesh;
  }());

  var FisheyeConfig = (function () {
    function FisheyeConfig(centerX, centerY, circleMaxFOV, circleFOV, circleRadius) {
      this.m_CenterX = 0;
      this.m_CenterY = 0;
      this.m_CircleFOV = 0;
      this.m_CircleRadius = 0;
      this.m_FOVToRadius = 0;
      this.m_MaxFOV = 0;
      this.m_MaxRadius = 0;
      this.m_RadiusToFOV = 0;
      this.m_CircleFOV = circleFOV;
      this.m_CircleRadius = circleRadius;
      this.m_CenterX = centerX;
      this.m_CenterY = centerY;
      circleFOV = this.m_CircleFOV;
      if (circleFOV > circleMaxFOV) {
        this.m_MaxFOV = circleMaxFOV;
      } else {
        this.m_MaxFOV = circleFOV;
      }
      this.m_MaxRadius = this.m_CircleRadius;
      this.m_RadiusToFOV = this.m_MaxFOV / this.m_MaxRadius;
      this.m_FOVToRadius = this.m_MaxRadius / this.m_MaxFOV;
    }
    FisheyeConfig.prototype.GetCenterX = function () {
      return this.m_CenterX;
    };
    FisheyeConfig.prototype.GetCenterY = function () {
      return this.m_CenterY;
    };
    FisheyeConfig.prototype.GetCircleFOV = function () {
      return this.m_CircleFOV;
    };
    FisheyeConfig.prototype.GetCircleRadius = function () {
      return this.m_CircleRadius;
    };
    FisheyeConfig.prototype.GetFOV = function (var1) {
      return var1 <= this.m_MaxRadius ? this.m_RadiusToFOV * var1 : -1.0;
    };
    FisheyeConfig.prototype.GetHeight = function () {
      return this.GetMaxRadius() * 2.0;
    };
    FisheyeConfig.prototype.GetMaxFOV = function () {
      return this.m_MaxFOV;
    };
    FisheyeConfig.prototype.GetMaxRadius = function () {
      return this.m_MaxRadius;
    };
    FisheyeConfig.prototype.GetRadius = function (var1) {
      return var1 <= this.m_MaxFOV ? this.m_FOVToRadius * var1 : -1.0;
    };
    FisheyeConfig.prototype.GetWidth = function () {
      return this.GetMaxRadius() * 2.0;
    };
    FisheyeConfig.DEFAULT_MAX_FOV = 170.0;
    FisheyeConfig.DEFAULT_MAX_RADIUS = 823.12506;
    return FisheyeConfig;
  }());

  var GEN = (function () {
    function GEN() {
      this.mNumTriangles = 0;
    }
    GEN.prototype.generateVertices = function () {
      var fisheyeConfig = new FisheyeConfig(resol / 2, resol / 2, 170.0, 170.0, resol / 2);
      var gridMesh = new GridMesh();
      gridMesh.GenerateMesh(124.0, fisheyeConfig, resol, resol, resol, resol, false, true);
      this.mNumTriangles = gridMesh.GetTriangleCount();
      var triangles = gridMesh.GetTriangles();
      var numPoints = this.mNumTriangles * 3;
      this.position = new Float32Array(numPoints * 3);
      this.textureCoords = new Float32Array(numPoints * 2);
      for (var i = 0; i < this.mNumTriangles; ++i) {
        this.textureCoords[i * 6 + 0] = triangles[i * 15 + 3];
        this.textureCoords[i * 6 + 1] = triangles[i * 15 + 4];
        this.position[i * 9 + 0] = triangles[i * 15];
        this.position[i * 9 + 1] = triangles[i * 15 + 1];
        this.position[i * 9 + 2] = triangles[i * 15 + 2];
        this.textureCoords[i * 6 + 2] = triangles[i * 15 + 10 + 3];
        this.textureCoords[i * 6 + 3] = triangles[i * 15 + 10 + 4];
        this.position[i * 9 + 3] = triangles[i * 15 + 10];
        this.position[i * 9 + 4] = triangles[i * 15 + 10 + 1];
        this.position[i * 9 + 5] = triangles[i * 15 + 10 + 2];
        this.textureCoords[i * 6 + 4] = triangles[i * 15 + 5 + 3];
        this.textureCoords[i * 6 + 5] = triangles[i * 15 + 5 + 4];
        this.position[i * 9 + 6] = triangles[i * 15 + 5];
        this.position[i * 9 + 7] = triangles[i * 15 + 5 + 1];
        this.position[i * 9 + 8] = triangles[i * 15 + 5 + 2];
      }
    };
    return GEN;
  }());

  function Constructor() {}

  Constructor.prototype = {
    init: function (videoElement) {

      var container, mesh;

      container = document.getElementById('mi-full-camera');

      //camera = new THREE.PerspectiveCamera( initFov, container.clientWidth / container.clientHeight, 1, 4400 );
      camera = new THREE.PerspectiveCamera(initFov, window.innerWidth / window.innerHeight, 1, 4400);
      camera.target = new THREE.Vector3(0, 0, 0);

      scene = new THREE.Scene();

      //var g = new GEN();
      //g.generateVertices();
      var g = function () {
        this.mNumTriangles = 8;
        this.position = [];
        this.textureCoords = [];
        /*
                var numMulti = 4;
                var pw = 2 / numMulti;
                var tw = 1 / numMulti;

                for(var i = 0 ; i < numMulti*2 ; i+=2)
                {
                  var x1 = -1.0 + (pw * i / 2);
                  var u1 = (tw * i / 2);  

                  this.position[i * 9 + 0] = x1;              this.position[i * 9 + 1] =  1.0;        this.position[i * 9 + 2] = 0.0;
                  this.position[i * 9 + 3] = x1;              this.position[i * 9 + 4] = -1.0;        this.position[i * 9 + 5] = 0.0;
                  this.position[i * 9 + 6] = x1 + pw;         this.position[i * 9 + 7] =  1.0;        this.position[i * 9 + 8] = 0.0;

                  this.textureCoords[i * 6 + 0] = u1;         this.textureCoords[i * 6 + 1] = 1.0;
                  this.textureCoords[i * 6 + 2] = u1;         this.textureCoords[i * 6 + 3] = 0.0;
                  this.textureCoords[i * 6 + 4] = u1 + tw;    this.textureCoords[i * 6 + 5] = 1.0;

                  this.position[(i+1) * 9+0] = x1 + pw;       this.position[(i+1) * 9+1] =  1.0;      this.position[(i+1) * 9+2] = 0.0;
                  this.position[(i+1) * 9+3] = x1;            this.position[(i+1) * 9+4] = -1.0;      this.position[(i+1) * 9+5] = 0.0;
                  this.position[(i+1) * 9+6] = x1 + pw;       this.position[(i+1) * 9+7] = -1.0;      this.position[(i+1) * 9+8] = 0.0;
           
                  this.textureCoords[(i+1) * 6+0] = u1 + tw;  this.textureCoords[(i+1) * 6+1] = 1.0;
                  this.textureCoords[(i+1) * 6+2] = u1;       this.textureCoords[(i+1) * 6+3] = 0.0;
                  this.textureCoords[(i+1) * 6+4] = u1 + tw;  this.textureCoords[(i+1) * 6+5] = 0.0;
                }
                */

        var numRect = 32;
        this.mNumTriangles = numRect * 2;

        var RAD_GAP = Math.PI / numRect;
        var ratio = videoElement.height / videoElement.width * Math.PI / 2; // 1.0;
        var texWidth = 1.0 / numRect;
        for (var i = 0; i < numRect; i++) {
          var pos = i * 18;
          var tex = i * 12;

          var radFrom = RAD_GAP * (numRect - i);
          var radTo = RAD_GAP * (numRect - 1 - i);
          var x1 = Math.cos(radFrom);
          var x2 = Math.cos(radTo);
          var z1 = Math.sin(radFrom);
          var z2 = Math.sin(radTo);

          this.position[pos++] = x1;
          this.position[pos++] = ratio;
          this.position[pos++] = -z1;
          this.position[pos++] = x1;
          this.position[pos++] = -ratio;
          this.position[pos++] = -z1;
          this.position[pos++] = x2;
          this.position[pos++] = ratio;
          this.position[pos++] = -z2;

          this.position[pos++] = x2;
          this.position[pos++] = ratio;
          this.position[pos++] = -z2;
          this.position[pos++] = x1;
          this.position[pos++] = -ratio;
          this.position[pos++] = -z1;
          this.position[pos++] = x2;
          this.position[pos++] = -ratio;
          this.position[pos++] = -z2;

          this.textureCoords[tex++] = texWidth * i;
          this.textureCoords[tex++] = 1.0;
          this.textureCoords[tex++] = texWidth * i;
          this.textureCoords[tex++] = 0.0;
          this.textureCoords[tex++] = texWidth * i + texWidth;
          this.textureCoords[tex++] = 1.0;
          this.textureCoords[tex++] = texWidth * i + texWidth;
          this.textureCoords[tex++] = 1.0;
          this.textureCoords[tex++] = texWidth * i;
          this.textureCoords[tex++] = 0.0;
          this.textureCoords[tex++] = texWidth * i + texWidth;
          this.textureCoords[tex++] = 0.0;
        }




        //videoElement.width = 4096;
        //videoElement.height = 1800;
      };



      var geo = new THREE.Geometry();
      geo.verticesNeedUpdate = true;
      geo.elementsNeedUpdate = true;
      geo.uvsNeedUpdate = true;

      for (var i = 0; i < g.mNumTriangles; i++) {
        geo.vertices.push(
          new THREE.Vector3(g.position[i * 9 + 0] * 200, g.position[i * 9 + 1] * 200, g.position[i * 9 + 2] * 200),
          new THREE.Vector3(g.position[i * 9 + 3] * 200, g.position[i * 9 + 4] * 200, g.position[i * 9 + 5] * 200),
          new THREE.Vector3(g.position[i * 9 + 6] * 200, g.position[i * 9 + 7] * 200, g.position[i * 9 + 8] * 200)
        );
        // geo.vertices.push(
        //   new THREE.Vector3( g.textureCoords[i*6 + 1] * 200 - 100 , g.textureCoords[i*6 + 0] * 200 - 100, 0),
        //   new THREE.Vector3( g.textureCoords[i*6 + 3] * 200 - 100 , g.textureCoords[i*6 + 2] * 200 - 100, 0),
        //   new THREE.Vector3( g.textureCoords[i*6 + 5] * 200 - 100 , g.textureCoords[i*6 + 4] * 200 - 100, 0 )
        //   );

        geo.faces.push(new THREE.Face3(i * 3 + 0, i * 3 + 1, i * 3 + 2));

        geo.faceVertexUvs[0].push([
          new THREE.Vector2(g.textureCoords[i * 6 + 0], g.textureCoords[i * 6 + 1]),
          new THREE.Vector2(g.textureCoords[i * 6 + 2], g.textureCoords[i * 6 + 3]),
          new THREE.Vector2(g.textureCoords[i * 6 + 4], g.textureCoords[i * 6 + 5])
        ]);
      }


      var geometry = new THREE.BufferGeometry();
      geometry.fromGeometry(geo);

      var texture;
      if (videoElement instanceof HTMLVideoElement) {
        videoElement.play();

        videoElement.setAttribute('webkit-playsinline', 'webkit-playsinline');
        texture = new THREE.VideoTexture(videoElement);
        tex = null;
      } else {
        texture = new THREE.CanvasTexture(videoElement);
        tex = texture;

      }



      texture.minFilter = THREE.LinearFilter;
      texture.format = THREE.RGBFormat;

      var material = new THREE.MeshBasicMaterial({
        map: texture
      });

      mesh = new THREE.Mesh(geometry, material);
      scene.add(mesh);



      var helper = new THREE.GridHelper(1000, 50, 0xff0000, 0x000000);
      helper.position.y = -199;
      helper.material.opacity = 0.25;
      helper.material.transparent = true;


      scene.add(helper);



      renderer = new THREE.WebGLRenderer();

      //renderer.setFaceCulling( THREE.CullFaceFront );
      //renderer.setClearColor(0x000000);
      //renderer.setClearColor(0xb0b0b0);
      renderer.setClearColor(0xf0f0f0);

      renderer.setPixelRatio(window.devicePixelRatio);
      //renderer.setSize( container.clientWidth , container.clientHeight );
      renderer.setSize(window.innerWidth, window.innerHeight);


      minimapCamera = new THREE.PerspectiveCamera(20, 1, 1, 10000);

      minimapCamera.position.y = 50;
      minimapCamera.position.z = 1800;

      scene.add(minimapCamera);

      renderer.autoClear = false;
      //cameraHelper = new THREE.CameraHelper( camera );      
      //scene.add(  cameraHelper );


      container.appendChild(renderer.domElement);

      document.addEventListener('mousedown', this.onDocumentMouseDown, false);
      document.addEventListener('mousemove', this.onDocumentMouseMove, false);
      document.addEventListener('mouseup', this.onDocumentMouseUp, false);
      document.addEventListener('dblclick', this.onDocumentMouseDbClick, false);
      document.addEventListener('mousewheel', this.onDocumentMouseWheel, false);
      document.addEventListener('MozMousePixelScroll', this.onDocumentMouseWheel, false);

      window.addEventListener('resize', this.onWindowResize, false);

    },
    onWindowResize: function () {
      camera.aspect = container.clientWidth / container.clientHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(container.clientWidth, container.clientHeight);
    },
    onDocumentMouseDown: function (event) {
      event.preventDefault();
      isUserInteracting = true;
      onPointerDownPointerX = event.clientX;
      onPointerDownPointerY = event.clientY;
      onPointerDownLon = lon;
      onPointerDownLat = lat;
    },
    onDocumentMouseMove: function (event) {
      if (isUserInteracting === true) {
        lon = (onPointerDownPointerX - event.clientX) * 0.1 + onPointerDownLon;
        lat = (onPointerDownPointerY - event.clientY) * 0.1 + onPointerDownLat;

      }
    },
    onDocumentMouseUp: function (event) {
      isUserInteracting = false;
    },
    onDocumentMouseDbClick: function (event) {
      if (distance > mindist) {
        distance = mindist;
      } else {
        distance = 500;
      }
    },
    onDocumentMouseWheel: function (event) {
      if (event.wheelDeltaY) {
        distance -= event.wheelDeltaY * 0.005;
      } else if (event.wheelDelta) {
        distance -= event.wheelDelta * 0.005;
      } else if (event.detail) {
        distance += event.detail * 0.5;
      }

      if (distance < mindist) {
        distance = mindist;
        if (fov > 1) {
          fov -= 1;
        }
      } else {
        if (fov < initFov) {
          distance = mindist;
          fov += 1;
        }
      }
    },
    animate: function () {
      window.requestAnimationFrame(this.animate.bind(this));
      this.update();
    },
    update: function () {
      if (tex) {
        tex.needsUpdate = true;
      }

      camera.up.set(0, 1, 0);

      var limit = 0.0;
      if (distance < distanceNear) {
        //limit = (fov * camera.aspect / 2);


        limit = Math.atan(Math.tan(fov * Math.PI / 180 / 2) * camera.aspect) * 180 / Math.PI;
        //limit = (fov / 2);
        if (distance > mindist) {
          limit *= (1.0 - (1.0 * distance / distanceNear));
        }
      }

      lat = Math.max(-75, Math.min(75, lat));
      phi = THREE.Math.degToRad(lat - 90);
      if (limit > 90) lon = 0;
      else lon = Math.max(limit - 90, Math.min(90 - limit, lon));
      //else lon = Math.max(- 90, Math.min( 90, lon ) );
      theta = THREE.Math.degToRad(lon - 90);

      camera.position.x = distance * Math.sin(phi) * Math.cos(theta);
      camera.position.y = distance * Math.cos(phi);
      camera.position.z = distance * Math.sin(phi) * Math.sin(theta);
      if (camera.fov != fov) {
        camera.fov = fov;
        camera.updateProjectionMatrix();
      }

      //console.log("ratio:"+camera.aspect+",\nlimit:"+limit+",\nfov ratio:"+camera.fov * camera.aspect+", \nfov:"+camera.fov+",distance:"+distance+","+Math.sin(THREE.Math.degToRad(90))+","+Math.cos(THREE.Math.degToRad(0))+"\n"+"lon:"+lon.toFixed(3)+" lat:"+lat.toFixed(3)+"\np:" + phi.toFixed(3) +" t:"+ theta.toFixed(3) + "\nx:"+camera.position.x.toFixed(3)+" y:"+camera.position.y.toFixed(3)+" z:"+camera.position.z.toFixed(3));
      camera.lookAt(camera.target);

      renderer.clear();

      //cameraHelper.visible = false;
      //renderer.setViewport( 0, 0, container.clientWidth, container.clientHeight );
      renderer.render(scene, camera);

      //cameraHelper.visible = true;
      //renderer.setViewport( container.clientWidth - 200, container.clientHeight - 200, 200, 200 );
      //renderer.render( scene, minimapCamera );

    }
  };
  return new Constructor();
}
/* global Float32Array, THREE */
function Fisheye3D(_isWallMode) {
  var camera,
    scene,
    renderer,
    texture_placeholder,
    isUserInteracting = false,
    onMouseDownMouseX = 0,
    onMouseDownMouseY = 0,
    onMouseDownLon = 0,
    onMouseDownLat = 0,
    lon = 0,
    lat = 0,
    phi = 0,
    theta = 0,
    distance = 500,
    distanceNear = 500,
    resol = 2992.0,
    initFov = 75,
    fov = initFov,
    mindist = 0.0000000001,
    tex,
    isWallMode = _isWallMode,
    animateId,
    _container;

  var meshVertex = (function () {
    function meshVertex(vertex) {
      var _this = this;
      if (((vertex != null && vertex instanceof meshVertex) || vertex === null)) {
        this.u = 0;
        this.v = 0;
        this.x = 0;
        this.y = 0;
        this.z = 0;
        (function () {
          _this.x = vertex.x;
          _this.y = vertex.y;
          _this.z = vertex.z;
          _this.u = vertex.u;
          _this.v = vertex.v;
        })();
      } else if (typeof vertex === "undefined") {
        this.u = 0;
        this.v = 0;
        this.x = 0;
        this.y = 0;
        this.z = 0;
        (function () {
          _this.v = 0.0;
          _this.u = 0.0;
          _this.z = 0.0;
          _this.y = 0.0;
          _this.x = 0.0;
        })();
      } else {
        throw new Error('invalid overload');
      }
    }
    return meshVertex;
  }());

  var GridMesh = (function () {
    function GridMesh() {
      this.m_InvertX = false;
      this.m_InvertY = false;
      this.m_FisheyeHeight = 0;
      this.m_FisheyeWidth = 0;
      this.m_NumTriangles = 0;
      this.m_TextureHeight = 0;
      this.m_TextureWidth = 0;
    }
    GridMesh.prototype.ClipToCircle = function (vertex) {
      var centerX = this.m_FisheyeConfig.GetCenterX();
      var centerY = this.m_FisheyeConfig.GetCenterY();
      var maxRadius = this.m_FisheyeConfig.GetMaxRadius();
      var var8 = Math.sqrt((vertex.u - centerX) * (vertex.u - centerX) + (vertex.v - centerY) * (vertex.v - centerY));
      var var10;
      if (var8 < maxRadius) {
        var10 = true;
      } else {
        var10 = false;
      }
      if (!var10) {
        maxRadius /= var8;
        vertex.u = (vertex.u - centerX) * maxRadius + centerX;
        vertex.v = (vertex.v - centerY) * maxRadius + centerY;
      }
      return var10;
    };
    GridMesh.prototype.CreateTriangle = function (var1, var2, var3) {
      var1 = new meshVertex(var1);
      var2 = new meshVertex(var2);
      var3 = new meshVertex(var3);

      var v1 = this.ClipToCircle(var1);
      var v2 = this.ClipToCircle(var2);
      var v3 = this.ClipToCircle(var3);
      var n1 = this.Normalize(var1);
      var n2 = this.Normalize(var2);
      var n3 = this.Normalize(var3);

      if ((v1 || v2 || v3) && (n1 || n2 || n3)) {
        this.Find3DPos(var1);
        this.Find3DPos(var2);
        this.Find3DPos(var3);
        this.m_Triangles[this.m_NumTriangles * 5 * 3 + 0 + 0] = var1.x;
        this.m_Triangles[this.m_NumTriangles * 5 * 3 + 0 + 1] = var1.y;
        this.m_Triangles[this.m_NumTriangles * 5 * 3 + 0 + 2] = var1.z;
        this.m_Triangles[this.m_NumTriangles * 5 * 3 + 0 + 3] = var1.u;
        this.m_Triangles[this.m_NumTriangles * 5 * 3 + 0 + 4] = var1.v;
        this.m_Triangles[this.m_NumTriangles * 5 * 3 + 5 + 0] = var2.x;
        this.m_Triangles[this.m_NumTriangles * 5 * 3 + 5 + 1] = var2.y;
        this.m_Triangles[this.m_NumTriangles * 5 * 3 + 5 + 2] = var2.z;
        this.m_Triangles[this.m_NumTriangles * 5 * 3 + 5 + 3] = var2.u;
        this.m_Triangles[this.m_NumTriangles * 5 * 3 + 5 + 4] = var2.v;
        this.m_Triangles[this.m_NumTriangles * 5 * 3 + 10 + 0] = var3.x;
        this.m_Triangles[this.m_NumTriangles * 5 * 3 + 10 + 1] = var3.y;
        this.m_Triangles[this.m_NumTriangles * 5 * 3 + 10 + 2] = var3.z;
        this.m_Triangles[this.m_NumTriangles * 5 * 3 + 10 + 3] = var3.u;
        this.m_Triangles[this.m_NumTriangles * 5 * 3 + 10 + 4] = var3.v;
        ++this.m_NumTriangles;
      }
    };
    GridMesh.prototype.Find3DPos = function (vertex) {
      var var6 = vertex.u;
      var textureWidth = this.m_TextureWidth;
      var var2 = vertex.v;
      var textureHeight = this.m_TextureHeight;
      var6 = var6 * textureWidth - this.m_FisheyeConfig.GetCenterX();
      textureHeight = var2 * textureHeight - this.m_FisheyeConfig.GetCenterY();
      var2 = textureHeight;
      if (this.m_InvertY) {
        var2 = -textureHeight;
      }
      textureHeight = var6;
      if (this.m_InvertX) {
        textureHeight = -var6;
      }
      textureWidth = this.m_FisheyeConfig.GetMaxRadius();
      var var10 = Math.sqrt(textureHeight * textureHeight + var2 * var2);
      var6 = var10;
      if (var10 > textureWidth) {
        var6 = textureWidth;
      }
      var6 = 0.017453293 * this.m_FisheyeConfig.GetFOV(var6) / 2.0;
      var2 = Math.atan2(var2, textureHeight);
      vertex.z = Math.cos(var6);
      vertex.y = Math.sin(var6) * Math.sin(var2);
      vertex.x = Math.sin(var6) * Math.cos(var2);
    };
    GridMesh.prototype.GenerateMesh = function (var1, fisheyeConfig, fisheyeWidth, fisheyeHeight, textureWidth, textureHeight, invertX, invertY) {
      this.m_InvertX = invertX;
      this.m_InvertY = invertY;
      this.m_FisheyeConfig = fisheyeConfig;
      this.m_FisheyeWidth = fisheyeWidth;
      this.m_FisheyeHeight = fisheyeHeight;
      this.m_TextureWidth = textureWidth;
      this.m_TextureHeight = textureHeight;
      var var10 = 3.0 * var1 / 4.0;
      var maxRadius = this.m_FisheyeConfig.GetMaxRadius();
      var var19 = new meshVertex();
      var var16 = new meshVertex();
      var var17 = new meshVertex();
      var var18 = new meshVertex();
      this.m_NumTriangles = 0;
      textureWidth = (Math.ceil(maxRadius / var1 + 0.5) | 0) * 2;
      var var12 = this.m_FisheyeConfig.GetCenterX() - ((textureWidth / 2 | 0)) * var1;
      textureHeight = (Math.ceil(maxRadius / var10) | 0) * 2;
      maxRadius = this.m_FisheyeConfig.GetCenterY() - ((textureHeight / 2 | 0)) * var10;
      this.m_Triangles = new Array(textureWidth * 30 * textureHeight);
      for (fisheyeWidth = 0; fisheyeWidth < textureHeight; ++fisheyeWidth) {
        for (fisheyeHeight = 0; fisheyeHeight < textureWidth; ++fisheyeHeight) {
          var19.v = fisheyeWidth * var10 + maxRadius;
          var16.v = fisheyeWidth * var10 + maxRadius;
          var17.v = (fisheyeWidth + 1) * var10 + maxRadius;
          var18.v = (fisheyeWidth + 1) * var10 + maxRadius;
          if (fisheyeWidth % 2 === 0) {
            var16.u = (fisheyeHeight + 1) * var1 + var12;
            var19.u = fisheyeHeight * var1 + var12;
            var17.u = var1 / 2.0 + fisheyeHeight * var1 + var12;
            var18.u = var1 / 2.0 + (fisheyeHeight + 1) * var1 + var12;
            this.CreateTriangle(var19, var17, var16);
            this.CreateTriangle(var16, var17, var18);
          } else {
            var19.u = var1 / 2.0 + var12 + fisheyeHeight * var1;
            var16.u = var1 / 2.0 + var12 + (fisheyeHeight + 1) * var1;
            var17.u = fisheyeHeight * var1 + var12;
            var18.u = (fisheyeHeight + 1) * var1 + var12;
            this.CreateTriangle(var19, var18, var16);
            this.CreateTriangle(var19, var17, var18);
          }
        }
      }
    };
    GridMesh.prototype.GetTriangleCount = function () {
      return this.m_NumTriangles;
    };
    GridMesh.prototype.GetTriangles = function () {
      return this.m_Triangles;
    };
    GridMesh.prototype.Normalize = function (vertex) {
      var var2 = true;
      vertex.u /= this.m_FisheyeWidth;
      vertex.v /= this.m_FisheyeHeight;
      if (vertex.u < 0.0) {
        vertex.u = 0.0;
        var2 = false;
      }
      if (vertex.u > 1.0) {
        vertex.u = 1.0;
        var2 = false;
      }
      if (vertex.v < 0.0) {
        vertex.v = 0.0;
        var2 = false;
      }
      if (vertex.v > 1.0) {
        vertex.v = 1.0;
        var2 = false;
      }
      vertex.u *= this.m_FisheyeWidth / this.m_TextureWidth;
      vertex.v *= this.m_FisheyeHeight / this.m_TextureHeight;
      return var2;
    };
    GridMesh.DEGREETORAD = 0.017453293;
    return GridMesh;
  }());

  var FisheyeConfig = (function () {
    function FisheyeConfig(centerX, centerY, circleMaxFOV, circleFOV, circleRadius) {
      this.m_CenterX = 0;
      this.m_CenterY = 0;
      this.m_CircleFOV = 0;
      this.m_CircleRadius = 0;
      this.m_FOVToRadius = 0;
      this.m_MaxFOV = 0;
      this.m_MaxRadius = 0;
      this.m_RadiusToFOV = 0;
      this.m_CircleFOV = circleFOV;
      this.m_CircleRadius = circleRadius;
      this.m_CenterX = centerX;
      this.m_CenterY = centerY;
      circleFOV = this.m_CircleFOV;
      if (circleFOV > circleMaxFOV) {
        this.m_MaxFOV = circleMaxFOV;
      } else {
        this.m_MaxFOV = circleFOV;
      }
      this.m_MaxRadius = this.m_CircleRadius;
      this.m_RadiusToFOV = this.m_MaxFOV / this.m_MaxRadius;
      this.m_FOVToRadius = this.m_MaxRadius / this.m_MaxFOV;
    }
    FisheyeConfig.prototype.GetCenterX = function () {
      return this.m_CenterX;
    };
    FisheyeConfig.prototype.GetCenterY = function () {
      return this.m_CenterY;
    };
    FisheyeConfig.prototype.GetCircleFOV = function () {
      return this.m_CircleFOV;
    };
    FisheyeConfig.prototype.GetCircleRadius = function () {
      return this.m_CircleRadius;
    };
    FisheyeConfig.prototype.GetFOV = function (var1) {
      return var1 <= this.m_MaxRadius ? this.m_RadiusToFOV * var1 : -1.0;
    };
    FisheyeConfig.prototype.GetHeight = function () {
      return this.GetMaxRadius() * 2.0;
    };
    FisheyeConfig.prototype.GetMaxFOV = function () {
      return this.m_MaxFOV;
    };
    FisheyeConfig.prototype.GetMaxRadius = function () {
      return this.m_MaxRadius;
    };
    FisheyeConfig.prototype.GetRadius = function (var1) {
      return var1 <= this.m_MaxFOV ? this.m_FOVToRadius * var1 : -1.0;
    };
    FisheyeConfig.prototype.GetWidth = function () {
      return this.GetMaxRadius() * 2.0;
    };
    FisheyeConfig.DEFAULT_MAX_FOV = 170.0;
    FisheyeConfig.DEFAULT_MAX_RADIUS = 823.12506;
    return FisheyeConfig;
  }());

  var GEN = (function () {
    function GEN() {
      this.mNumTriangles = 0;
    }
    GEN.prototype.generateVertices = function () {
      var fisheyeConfig = new FisheyeConfig(resol / 2, resol / 2, 170.0, 170.0, resol / 2);
      var gridMesh = new GridMesh();
      gridMesh.GenerateMesh(124.0, fisheyeConfig, resol, resol, resol, resol, false, true);
      this.mNumTriangles = gridMesh.GetTriangleCount();
      var triangles = gridMesh.GetTriangles();
      var numPoints = this.mNumTriangles * 3;
      this.position = new Float32Array(numPoints * 3);
      this.textureCoords = new Float32Array(numPoints * 2);
      for (var i = 0; i < this.mNumTriangles; ++i) {
        this.textureCoords[i * 6 + 0] = triangles[i * 15 + 3];
        this.textureCoords[i * 6 + 1] = triangles[i * 15 + 4];
        this.position[i * 9 + 0] = triangles[i * 15];
        this.position[i * 9 + 1] = triangles[i * 15 + 1];
        this.position[i * 9 + 2] = triangles[i * 15 + 2];
        this.textureCoords[i * 6 + 2] = triangles[i * 15 + 10 + 3];
        this.textureCoords[i * 6 + 3] = triangles[i * 15 + 10 + 4];
        this.position[i * 9 + 3] = triangles[i * 15 + 10];
        this.position[i * 9 + 4] = triangles[i * 15 + 10 + 1];
        this.position[i * 9 + 5] = triangles[i * 15 + 10 + 2];
        this.textureCoords[i * 6 + 4] = triangles[i * 15 + 5 + 3];
        this.textureCoords[i * 6 + 5] = triangles[i * 15 + 5 + 4];
        this.position[i * 9 + 6] = triangles[i * 15 + 5];
        this.position[i * 9 + 7] = triangles[i * 15 + 5 + 1];
        this.position[i * 9 + 8] = triangles[i * 15 + 5 + 2];
      }
    };
    return GEN;
  }());

  function Constructor() {}

  Constructor.prototype = {
    init: function (videoElement, container) {

      var mesh;
      _container = container;

      camera = new THREE.PerspectiveCamera(initFov, window.innerWidth / window.innerHeight, 1, 4400);
      camera.target = new THREE.Vector3(0, 0, 0);

      scene = new THREE.Scene();

      var g = new GEN();
      g.generateVertices();


      var geo = new THREE.Geometry();
      geo.verticesNeedUpdate = true;
      geo.elementsNeedUpdate = true;
      geo.uvsNeedUpdate = true;

      for (var i = 0; i < g.mNumTriangles; i++) {
        geo.vertices.push(
          new THREE.Vector3(g.position[i * 9 + 0] * 200, g.position[i * 9 + 1] * 200, g.position[i * 9 + 2] * 200),
          new THREE.Vector3(g.position[i * 9 + 3] * 200, g.position[i * 9 + 4] * 200, g.position[i * 9 + 5] * 200),
          new THREE.Vector3(g.position[i * 9 + 6] * 200, g.position[i * 9 + 7] * 200, g.position[i * 9 + 8] * 200)
        );

        geo.faces.push(new THREE.Face3(i * 3 + 0, i * 3 + 1, i * 3 + 2));

        geo.faceVertexUvs[0].push([
          new THREE.Vector2(g.textureCoords[i * 6 + 0], g.textureCoords[i * 6 + 1]),
          new THREE.Vector2(g.textureCoords[i * 6 + 2], g.textureCoords[i * 6 + 3]),
          new THREE.Vector2(g.textureCoords[i * 6 + 4], g.textureCoords[i * 6 + 5])
        ]);
      }


      var geometry = new THREE.BufferGeometry();
      geometry.fromGeometry(geo);

      var texture;
      if (videoElement instanceof HTMLVideoElement) {
        videoElement.play();

        videoElement.setAttribute('webkit-playsinline', 'webkit-playsinline');
        texture = new THREE.VideoTexture(videoElement);
        tex = null;
      } else {
        texture = new THREE.CanvasTexture(videoElement);
        tex = texture;

      }


      texture.minFilter = THREE.LinearFilter;
      texture.format = THREE.RGBFormat;

      var material = new THREE.MeshBasicMaterial({
        map: texture
      });

      mesh = new THREE.Mesh(geometry, material);
      scene.add(mesh);

      renderer = new THREE.WebGLRenderer();
      renderer.setClearColor(0xf0f0f0);

      renderer.setPixelRatio(window.devicePixelRatio);
      renderer.setSize(window.innerWidth, window.innerHeight);

      renderer.autoClear = false;
      renderer.domElement.style.width = "100%";
      renderer.domElement.style.height = "100%";
      //console.info(renderer.domElement);
      container.appendChild(renderer.domElement);

      renderer.domElement.addEventListener('mousedown', this.onDocumentMouseDown, false);
      renderer.domElement.addEventListener('mousemove', this.onDocumentMouseMove, false);
      renderer.domElement.addEventListener('mouseup', this.onDocumentMouseUp, false);
      renderer.domElement.addEventListener('dblclick', this.onDocumentMouseDbClick, false);
      renderer.domElement.addEventListener('mousewheel', this.onDocumentMouseWheel, false);
      renderer.domElement.addEventListener('MozMousePixelScroll', this.onDocumentMouseWheel, false);

      window.addEventListener('resize', this.onWindowResize, false);

    },
    onWindowResize: function () {
      camera.aspect = _container.clientWidth / _container.clientHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(_container.clientWidth, _container.clientHeight);
      //console.info(_container.clientWidth +"," + _container.clientHeight);
    },
    onDocumentMouseDown: function (event) {
      event.preventDefault();
      isUserInteracting = true;
      onPointerDownPointerX = event.clientX;
      onPointerDownPointerY = event.clientY;
      onPointerDownLon = lon;
      onPointerDownLat = lat;
    },
    onDocumentMouseMove: function (event) {
      if (isUserInteracting === true) {
        lon = (onPointerDownPointerX - event.clientX) * 0.1 + onPointerDownLon;
        if (isWallMode === true) {
          lat = (onPointerDownPointerY - event.clientY) * 0.1 + onPointerDownLat;
        } else {
          lat = (event.clientY - onPointerDownPointerY) * 0.1 + onPointerDownLat;
        }
      }
    },
    onDocumentMouseUp: function (event) {
      isUserInteracting = false;
    },
    onDocumentMouseDbClick: function (event) {
      if (distance > mindist) {
        distance = mindist;
      } else {
        distance = 500;
      }
    },
    onDocumentMouseWheel: function (event) {
      if (event.wheelDeltaY) {
        distance -= event.wheelDeltaY * 0.5;
      } else if (event.wheelDelta) {
        distance -= event.wheelDelta * 0.5;
      } else if (event.detail) {
        distance += event.detail * 0.5;
      }

      if (distance < mindist) {
        distance = mindist;
        if (fov > 1) {
          fov -= 1;
        }
      } else {
        if (fov < initFov) {
          distance = mindist;
          fov += 1;
        }
      }
    },
    animate: function () {
      this.animateId = window.requestAnimationFrame(this.animate.bind(this));
      this.update();
    },
    start: function () {
      if (!this.animateId) {
        this.animate();
      }
    },
    stop: function () {
      if (this.animateId) {
        window.cancelAnimationFrame(this.animateId);
        this.animateId = undefined;
      }
      _container.removeChild(renderer.domElement);
      window.removeEventListener('resize', this.onWindowResize, false);
    },
    update: function () {
      if (tex) {
        if (livecanvas.updatedCanvas === true) {
          livecanvas.updatedCanvas = false;
          tex.needsUpdate = true;
        }
      }

      if (isWallMode === true) {
        camera.up.set(0, 1, 0);
      } else {
        camera.up.set(0, 0, -1);
      }

      var limit = 0.0;
      if (distance < distanceNear) {
        if (isWallMode === true) {
          limit = Math.atan(Math.tan(fov * Math.PI / 180 / 2) * camera.aspect) * 180 / Math.PI;
        } else {
          limit = ((fov / 2) + 5);
        }

        if (distance > mindist) {
          limit *= (1.0 - (1.0 * distance / distanceNear));
        }
      }

      if (isWallMode === true) {
        lat = Math.max(-75, Math.min(75, lat));
        phi = THREE.Math.degToRad(lat - 90);
        if (limit > 90) lon = 0;
        else lon = Math.max(limit - 90, Math.min(90 - limit, lon));

        theta = THREE.Math.degToRad(lon + 90);
        camera.position.x = distance * Math.sin(phi) * Math.cos(theta);
        camera.position.y = distance * Math.cos(phi);
        camera.position.z = distance * Math.sin(phi) * Math.sin(theta);
      } else {
        lat = Math.max(0, Math.min(90 - limit, lat));
        phi = THREE.Math.degToRad(lat - 180);
        theta = THREE.Math.degToRad(lon - 90);
        camera.position.x = distance * Math.sin(phi) * Math.cos(theta);
        camera.position.z = distance * Math.cos(phi);
        camera.position.y = distance * Math.sin(phi) * Math.sin(theta);
      }
      if (camera.fov != fov) {
        camera.fov = fov;
        camera.updateProjectionMatrix();
      }

      //console.log("fov:"+camera.fov+",distance:"+distance+","+Math.sin(THREE.Math.degToRad(90))+","+Math.cos(THREE.Math.degToRad(0))+"\n"+"lon:"+lon.toFixed(3)+" lat:"+lat.toFixed(3)+"\np:" + phi.toFixed(3) +" t:"+ theta.toFixed(3) + "\nx:"+camera.position.x.toFixed(3)+" y:"+camera.position.y.toFixed(3)+" z:"+camera.position.z.toFixed(3));
      camera.lookAt(camera.target);
      renderer.clear();
      renderer.render(scene, camera);
    }
  };
  return new Constructor();
}
function H264SPSParser() {
  "use strict";

  var vBitCount = 0;
  var spsMap = null;
  var pSPSBytes = null;

  function Constructor() {
    vBitCount = 0;
    spsMap = new UmpMap();
  }

  function nal_unit_extract_rbsp(src) {
    var dst = [];
    var len = src.byteLength;

    var i = 0;

    while (i < 2 && i < len) {
      dst.push(src[i++]);
    }

    while (i + 2 < len) {
      if (src[i] === 0x00 && src[i + 1] === 0x00 && src[i + 2] === 0x03) {
        dst.push(src[i++]);
        dst.push(src[i++]);
        i++; // remove emulation_prevention_three_byte
      } else {
        dst.push(src[i++]);
      }
    }

    while (i < len) {
      dst.push(src[i++]);
    }

    return new Uint8Array(dst);
  }

  function get_bit(base, offset) {
    var vCurBytes = (vBitCount + offset) >> 3;
    offset = (vBitCount + offset) & 0x00000007;
    return ((base[(vCurBytes)]) >> (0x7 - (offset & 0x7))) & 0x1;
  }

  function read_bits(pBuf, vReadBits) {
    var vCurBytes = vBitCount / 8;
    var vCurBits = vBitCount % 8;
    var vOffset = 0;
    var vTmp = 0,
      vTmp2 = 0;

    if (vReadBits == 1) {
      vTmp = get_bit(pBuf, vOffset);
    } else {
      for (var i = 0; i < vReadBits; i++) {
        vTmp2 = get_bit(pBuf, i);
        vTmp = (vTmp << 1) + vTmp2;
      }
    }

    vBitCount += vReadBits;
    return vTmp;
  }

  function ue(base, offset) {
    var zeros = 0,
      vTmp = 0,
      vReturn = 0;
    var vIdx = offset;

    if (base.length !== vIdx) {
      do {
        vTmp = get_bit(base, vIdx++);
        if (vTmp === 0) {
          zeros++;
        }
        if (base.length === vIdx) {
          break;
        }
      } while (0 === vTmp);
    }

    if (zeros === 0) {
      vBitCount += 1;
      return 0;
    }

    vReturn = 1 << zeros;

    for (var i = zeros - 1; i >= 0; i-- , vIdx++) {
      vTmp = get_bit(base, vIdx);
      vReturn |= vTmp << i;
    }

    vBitCount += zeros * 2 + 1;

    return (vReturn - 1);
  }

  function se(base, offset) {
    var vReturn = ue(base, offset);

    if (vReturn & 0x1) {
      return (vReturn + 1) / 2;
    } else {
      return -vReturn / 2;
    }
  }

  function byte_aligned() {
    if ((vBitCount & 0x00000007) == 0)
      return 1;
    else
      return 0;
  }

  /*
  The HRD parameters define the buffer sizes and bit rates of the operation of 
  the Hypothetical Reference Decoder (HRD) for the bit stream.
  */
  function hrd_parameters(pSPSBytes) {
    spsMap.put("cpb_cnt_minus1", ue(pSPSBytes, 0));
    spsMap.put("bit_rate_scale", read_bits(pSPSBytes, 4));
    spsMap.put("cpb_size_scale", read_bits(pSPSBytes, 4));
    var cpd_cnt_munus1 = spsMap.get("cpb_cnt_minus1");
    var bit_rate_value_minus1 = new Array(cpd_cnt_munus1);
    var cpb_size_value_minus1 = new Array(cpd_cnt_munus1);
    var cbr_flag = new Array(cpd_cnt_munus1);
    for (var i = 0; i <= cpd_cnt_munus1; i++) {
      bit_rate_value_minus1[i] = ue(pSPSBytes, 0);
      cpb_size_value_minus1[i] = ue(pSPSBytes, 0);
      cbr_flag[i] = read_bits(pSPSBytes, 1);
    }
    spsMap.put("bit_rate_value_minus1", bit_rate_value_minus1);
    spsMap.put("cpb_size_value_minus1", cpb_size_value_minus1);
    spsMap.put("cbr_flag", cbr_flag);

    spsMap.put("initial_cpb_removal_delay_length_minus1", read_bits(pSPSBytes, 5));
    spsMap.put("cpb_removal_delay_length_minus1", read_bits(pSPSBytes, 5));
    spsMap.put("dpb_output_delay_length_minus1", read_bits(pSPSBytes, 5));
    spsMap.put("time_offset_length", read_bits(pSPSBytes, 5));
  }

  /*
  The H.264/AVC standard includes optional Video Usability Information (VUI) parameters. 
  As its name implies, these parameters provide information that help makes the sequence 
  useable beyond simple decoding. 
  */
  function vui_parameters(pSPSBytes) {
    spsMap.put("aspect_ratio_info_present_flag", read_bits(pSPSBytes, 1));
    if (spsMap.get("aspect_ratio_info_present_flag")) {
      spsMap.put("aspect_ratio_idc", read_bits(pSPSBytes, 8));
      //Extended_SAR
      if (spsMap.get("aspect_ratio_idc") == 255) {
        spsMap.put("sar_width", read_bits(pSPSBytes, 16));
        spsMap.put("sar_height", read_bits(pSPSBytes, 16));
      }
    }

    spsMap.put("overscan_info_present_flag", read_bits(pSPSBytes, 1));
    if (spsMap.get("overscan_info_present_flag")) {
      spsMap.put("overscan_appropriate_flag", read_bits(pSPSBytes, 1));
    }
    spsMap.put("video_signal_type_present_flag", read_bits(pSPSBytes, 1));
    if (spsMap.get("video_signal_type_present_flag")) {
      spsMap.put("video_format", read_bits(pSPSBytes, 3));
      spsMap.put("video_full_range_flag", read_bits(pSPSBytes, 1));
      spsMap.put("colour_description_present_flag", read_bits(pSPSBytes, 1));
      if (spsMap.get("colour_description_present_flag")) {
        spsMap.put("colour_primaries", read_bits(pSPSBytes, 8));
        spsMap.put("transfer_characteristics", read_bits(pSPSBytes, 8));
        spsMap.put("matrix_coefficients", read_bits(pSPSBytes, 8));
      }
    }
    spsMap.put("chroma_loc_info_present_flag", read_bits(pSPSBytes, 1));
    if (spsMap.get("chroma_loc_info_present_flag")) {
      spsMap.put("chroma_sample_loc_type_top_field", ue(pSPSBytes, 0));
      spsMap.put("chroma_sample_loc_type_bottom_field", ue(pSPSBytes, 0));
    }
    spsMap.put("timing_info_present_flag", read_bits(pSPSBytes, 1));
    if (spsMap.get("timing_info_present_flag")) {
      spsMap.put("num_units_in_tick", read_bits(pSPSBytes, 32));
      spsMap.put("time_scale", read_bits(pSPSBytes, 32));
      spsMap.put("fixed_frame_rate_flag", read_bits(pSPSBytes, 1));
    }
    spsMap.put("nal_hrd_parameters_present_flag", read_bits(pSPSBytes, 1));
    if (spsMap.get("nal_hrd_parameters_present_flag")) {
      hrd_parameters(pSPSBytes);
    }
    spsMap.put("vcl_hrd_parameters_present_flag", read_bits(pSPSBytes, 1));
    if (spsMap.get("vcl_hrd_parameters_present_flag")) {
      hrd_parameters(pSPSBytes);
    }
    if (spsMap.get("nal_hrd_parameters_present_flag") || spsMap.get("vcl_hrd_parameters_present_flag")) {
      spsMap.put("low_delay_hrd_flag", read_bits(pSPSBytes, 1));
    }
    spsMap.put("pic_struct_present_flag", read_bits(pSPSBytes, 1));
    spsMap.put("bitstream_restriction_flag", read_bits(pSPSBytes, 1));
    if (spsMap.get("bitstream_restriction_flag")) {
      spsMap.put("motion_vectors_over_pic_boundaries_flag", read_bits(pSPSBytes, 1));
      spsMap.put("max_bytes_per_pic_denom", ue(pSPSBytes, 0));
      spsMap.put("max_bits_per_mb_denom", ue(pSPSBytes, 0));
      spsMap.put("log2_max_mv_length_horizontal", ue(pSPSBytes, 0));
      spsMap.put("log2_max_mv_length_vertical", ue(pSPSBytes, 0));
      spsMap.put("max_num_reorder_frames", ue(pSPSBytes, 0));
      spsMap.put("max_dec_frame_buffering", ue(pSPSBytes, 0));
    }
  }

  Constructor.prototype = {
    parse: function (spsPayload) {
      pSPSBytes = nal_unit_extract_rbsp(spsPayload);
      var i, j;
      //console.log("=========================SPS START=========================");
      vBitCount = 0;
      spsMap.clear();

      // forbidden_zero_bit, nal_ref_idc, nal_unit_type
      spsMap.put("forbidden_zero_bit", read_bits(pSPSBytes, 1));
      spsMap.put("nal_ref_idc", read_bits(pSPSBytes, 2));
      spsMap.put("nal_unit_type", read_bits(pSPSBytes, 5));

      spsMap.put("profile_idc", read_bits(pSPSBytes, 8));
      spsMap.put("profile_compatibility", read_bits(pSPSBytes, 8));
      spsMap.put("level_idc", read_bits(pSPSBytes, 8));

      spsMap.put("seq_parameter_set_id", ue(pSPSBytes, 0));

      var profile_idc = spsMap.get("profile_idc");
      spsMap.put("chroma_format_idc", 0);
      if ((profile_idc === 100) || (profile_idc === 110) ||
        (profile_idc === 122) || (profile_idc === 244) || (profile_idc === 44) ||
        (profile_idc === 83) || (profile_idc === 86) || (profile_idc === 118) ||
        (profile_idc === 128) || (profile_idc === 138) || (profile_idc === 139) ||
        (profile_idc === 134) || (profile_idc === 135)) {
        spsMap.put("chroma_format_idc", ue(pSPSBytes, 0));
        if (spsMap.get("chroma_format_idc") === 3) {
          spsMap.put("separate_colour_plane_flag", read_bits(pSPSBytes, 1));
        }

        var ChromaArrayType = 0;
        var chroma_format_idc = spsMap.get("chroma_format_idc");
        if (spsMap.get("separate_colour_plane_flag") === 0) {
          ChromaArrayType = chroma_format_idc;
        } else if (spsMap.get("separate_colour_plane_flag") === 1) {
          ChromaArrayType = 0;
        }
        spsMap.put("ChromaArrayType", ChromaArrayType);

        spsMap.put("bit_depth_luma_minus8", ue(pSPSBytes, 0));
        spsMap.put("bit_depth_chroma_minus8", ue(pSPSBytes, 0));
        spsMap.put("qpprime_y_zero_transform_bypass_flag", read_bits(pSPSBytes, 1));
        spsMap.put("seq_scaling_matrix_present_flag", read_bits(pSPSBytes, 1));

        if (spsMap.get("seq_scaling_matrix_present_flag")) {
          var num = spsMap.get("chroma_format_idc") !== 3 ? 8 : 12;
          var seq_scaling_list_present_flag = new Array(num);
          for (i = 0; i < num; i++) {
            seq_scaling_list_present_flag[i] = read_bits(pSPSBytes, 1);

            if (seq_scaling_list_present_flag[i]) {
              var sl_n = i < 6 ? 16 : 64;
              var lastScale = 8;
              var nextScale = 8;
              var delta_scale;
              var useDefaultScalingMatrixFlag;
              var scalingList = new Array(sl_n);

              for (j = 0; j < sl_n; j++) {
                if (nextScale) {
                  delta_scale = se(pSPSBytes, 0);
                  nextScale = (lastScale + delta_scale + 256) % 256;
                  useDefaultScalingMatrixFlag = (j == 0 && nextScale == 0);
                }
                scalingList[j] = (nextScale == 0) ? lastScale : nextScale;
                lastScale = scalingList[j];
              }
            }
          }
          spsMap.put("seq_scaling_list_present_flag", seq_scaling_list_present_flag);
        }
      }
      spsMap.put("log2_max_frame_num_minus4", ue(pSPSBytes, 0));
      spsMap.put("pic_order_cnt_type", ue(pSPSBytes, 0));

      if (spsMap.get("pic_order_cnt_type") == 0) {
        spsMap.put("log2_max_pic_order_cnt_lsb_minus4", ue(pSPSBytes, 0));
      } else if (spsMap.get("pic_order_cnt_type") == 1) {
        spsMap.put("delta_pic_order_always_zero_flag", read_bits(pSPSBytes, 1));
        spsMap.put("offset_for_non_ref_pic", se(pSPSBytes, 0));
        spsMap.put("offset_for_top_to_bottom_field", se(pSPSBytes, 0));
        spsMap.put("num_ref_frames_in_pic_order_cnt_cycle", ue(pSPSBytes, 0));
        var offset_for_ref_frame = [];
        for (i = 0; i < spsMap.get("num_ref_frames_in_pic_order_cnt_cycle"); i++) {
          //spsMap.put("num_ref_frames_in_pic_order_cnt_cycle", se(pSPSBytes, 0));
          offset_for_ref_frame[i] = se(pSPSBytes, 0);
        }
      }
      spsMap.put("num_ref_frames", ue(pSPSBytes, 0));
      spsMap.put("gaps_in_frame_num_value_allowed_flag", read_bits(pSPSBytes, 1));
      spsMap.put("pic_width_in_mbs_minus1", ue(pSPSBytes, 0));
      spsMap.put("pic_height_in_map_units_minus1", ue(pSPSBytes, 0));
      spsMap.put("frame_mbs_only_flag", read_bits(pSPSBytes, 1));

      if (spsMap.get("frame_mbs_only_flag") == 0) {
        spsMap.put("mb_adaptive_frame_field_flag", read_bits(pSPSBytes, 1));
      }
      spsMap.put("direct_8x8_interence_flag", read_bits(pSPSBytes, 1));

      // cropping check information
      spsMap.put("frame_cropping_flag", read_bits(pSPSBytes, 1));
      if (spsMap.get("frame_cropping_flag") == 1) {
        spsMap.put("frame_cropping_rect_left_offset", ue(pSPSBytes, 0));
        spsMap.put("frame_cropping_rect_right_offset", ue(pSPSBytes, 0));
        spsMap.put("frame_cropping_rect_top_offset", ue(pSPSBytes, 0));
        spsMap.put("frame_cropping_rect_bottom_offset", ue(pSPSBytes, 0));
      }

      //vui parameters
      spsMap.put("vui_parameters_present_flag", read_bits(pSPSBytes, 1));
      if (spsMap.get("vui_parameters_present_flag")) {
        vui_parameters(pSPSBytes);
      }

      //console.log("=========================SPS END=========================");


      return true;
    },

    getSizeInfo: function () {
      // video frame size (Advanced video coding for generic audiovisual services standard p.99)
      var SubWidthC = 2;
      var SubHeightC = 2;
      var macroblockSamples = 16;

      if (spsMap.get("chroma_format_idc") === 0 && spsMap.get("separate_colour_plane_flag") === 0) { //monochrome
        SubWidthC = SubHeightC = 0;
      }
      else if (spsMap.get("chroma_format_idc") === 1 && spsMap.get("separate_colour_plane_flag") === 0) { //4:2:0
        SubWidthC = SubHeightC = 2;
      }
      else if (spsMap.get("chroma_format_idc") === 2 && spsMap.get("separate_colour_plane_flag") === 0) { //4:2:2
        SubWidthC = 2;
        SubHeightC = 1;
      }
      else if (spsMap.get("chroma_format_idc") === 3) { //4:4:4
        if (spsMap.get("separate_colour_plane_flag") === 0) {
          SubWidthC = SubHeightC = 1;
        }
        else if (spsMap.get("separate_colour_plane_flag") === 1) {
          SubWidthC = SubHeightC = 0;
        }
      }

      var MbWidthC = macroblockSamples / SubWidthC;
      var MbHeidhtC = macroblockSamples / SubHeightC;

      var cropLeft = 0;
      var cropRight = 0;
      var cropTop = 0;
      var cropBottom = 0;

      var CropUnitX = 0;
      var CropUnitY = 0;

      if (spsMap.get("frame_cropping_flag") === 1) {
        cropLeft = spsMap.get("frame_cropping_rect_left_offset");
        cropRight = spsMap.get("frame_cropping_rect_right_offset");
        cropTop = spsMap.get("frame_cropping_rect_top_offset");
        cropBottom = spsMap.get("frame_cropping_rect_bottom_offset");
      }

      var PicWidthInMbs = spsMap.get("pic_width_in_mbs_minus1") + 1;
      var PicWidthInSamples_luma = PicWidthInMbs * macroblockSamples;
      var PicWidthInSamples_chroma = PicWidthInMbs * macroblockSamples;

      var PicHeightInMapUnits = spsMap.get("pic_height_in_map_units_minus1") + 1;
      var PicSizeInMapUnits = PicWidthInMbs * PicHeightInMapUnits;

      var FrameHeightInMbs = (2 - spsMap.get("frame_mbs_only_flag")) * PicHeightInMapUnits;

      var ChromaArrayType = spsMap.get("ChromaArrayType");

      if (ChromaArrayType === 0) {
        CropUnitX = 1;
        CropUnitY = 2 - spsMap.get("frame_mbs_only_flag");
      }
      CropUnitX = SubWidthC;
      CropUnitY = SubHeightC * (2 - spsMap.get("frame_mbs_only_flag"));

      var width = PicWidthInMbs * 16;
      var height = FrameHeightInMbs * 16;

      var cropWidth = CropUnitX * (cropLeft + cropRight);
      var cropHeight = CropUnitY * (cropTop + cropBottom);

      if (cropWidth) {
        width -= cropWidth;
      } if (cropHeight) {
        height -= cropHeight;
      }

      var decodeSize = width * height;

      var sizeInfo = {
        'width': width,
        'height': height,
        'decodeSize': decodeSize,
        'cropWidth': cropWidth,
        'cropHeight': cropHeight
      };

      return sizeInfo;
    },
    getSpsValue: function (key) {
      return spsMap.get(key);
    },
    getCodecInfo: function () {
      var profileIdc = spsMap.get("profile_idc");
      var profileCompatibility = spsMap.get("profile_compatibility");
      var levelIdc = spsMap.get("level_idc");

      if (typeof profileIdc === "undefined" || typeof profileCompatibility === "undefined" || typeof levelIdc === "undefined") {
        return null;
      }

      profileIdc = (profileIdc <= 0x0f ? "0" : "") + profileIdc.toString(16);
      profileCompatibility = (profileCompatibility <= 0x0f ? "0" : "") + profileCompatibility.toString(16);
      levelIdc = (levelIdc <= 0x0f ? "0" : "") + levelIdc.toString(16);

      var codecInfo = "avc1." + profileIdc + profileCompatibility + levelIdc;
      return codecInfo;
    }
  };
  return new Constructor();
}

function H265SPSParser() {
  "use strict";

  var vBitCount = 0;
  var spsMap = null;
  var pSPSBytes = null;

  function Constructor() {
    vBitCount = 0;
    spsMap = new UmpMap();
  }

  function nal_unit_extract_rbsp(src) {
    var dst = [];
    var len = src.byteLength;

    var i = 0;

    while (i < 2 && i < len) {
      dst.push(src[i++]);
    }

    while (i + 2 < len) {
      if (src[i] === 0x00 && src[i + 1] === 0x00 && src[i + 2] === 0x03) {
        dst.push(src[i++]);
        dst.push(src[i++]);
        i++; // remove emulation_prevention_three_byte
      } else {
        dst.push(src[i++]);
      }
    }

    while (i < len) {
      dst.push(src[i++]);
    }

    return new Uint8Array(dst);
  }

  function get_bit(base, offset) {
    var vCurBytes = (vBitCount + offset) >> 3;
    offset = (vBitCount + offset) & 0x00000007;
    return (((base[(vCurBytes)])) >> (0x7 - (offset & 0x7))) & 0x1;
  }

  function read_bits(pBuf, vReadBits) {
    var vCurBytes = vBitCount / 8;
    var vCurBits = vBitCount % 8;
    var vOffset = 0;
    var vTmp = 0,
      vTmp2 = 0;

    if (vReadBits == 1) {
      vTmp = get_bit(pBuf, vOffset);
    } else {
      for (var i = 0; i < vReadBits; i++) {
        vTmp2 = get_bit(pBuf, i);
        vTmp = (vTmp << 1) + vTmp2;
      }
    }

    vBitCount += vReadBits;
    return vTmp;
  }

  function reverse_bits(bits, size) {
    var binaryString = bits.toString(2).split('').reverse().join('');
    while (binaryString.length < size) {
      binaryString += '0';
    }
    return parseInt(binaryString, 2);
  }

  function ue(base, offset) {
    var zeros = 0,
      vTmp = 0,
      vReturn = 0;
    var vIdx = offset;
    do {
      vTmp = get_bit(base, vIdx++);
      if (vTmp === 0)
        zeros++;
    } while (0 == vTmp);

    if (zeros == 0) {
      vBitCount += 1;
      return 0;
    }

    // insert first 1 bit
    vReturn = 1 << zeros;

    for (var i = zeros - 1; i >= 0; i-- , vIdx++) {
      vTmp = get_bit(base, vIdx);
      vReturn |= vTmp << i;
    }

    vBitCount += zeros * 2 + 1;

    return (vReturn - 1);
  }

  function se(base, offset) {
    var vReturn = ue(base, offset);

    if (vReturn & 0x1) {
      return (vReturn + 1) / 2;
    } else {
      return -vReturn / 2;
    }
  }

  function byte_aligned() {
    if ((vBitCount & 0x00000007) == 0)
      return 1;
    else
      return 0;
  }

  // function profile_tier_level(profilePresentFlag, maxNumSubLayersMinus1) {
  //   var i, j;
  //   if (profilePresentFlag) {
  //     spsMap.put("general_profile_space", read_bits(pSPSBytes, 2));
  //     spsMap.put("general_tier_flag", read_bits(pSPSBytes, 1));
  //     spsMap.put("general_profile_idc", read_bits(pSPSBytes, 5));
  //     var generalProfileCompatibilityFlag = new Array(32);

  //     for (j = 0; j < 32; j++) {
  //       generalProfileCompatibilityFlag[j] = read_bits(pSPSBytes, 1);
  //     }

  //     spsMap.put("general_progressive_source_flag", read_bits(pSPSBytes, 1));
  //     spsMap.put("general_interlaced_source_flag", read_bits(pSPSBytes, 1));
  //     spsMap.put("general_non_packed_constraint_flag", read_bits(pSPSBytes, 1));
  //     spsMap.put("general_frame_only_constraint_flag", read_bits(pSPSBytes, 1));

  //     var generalProfileIdc = spsMap.get("general_profile_idc");
  //     if (generalProfileIdc === 4 || generalProfileCompatibilityFlag[4] ||
  //       generalProfileIdc === 5 || generalProfileCompatibilityFlag[5] ||
  //       generalProfileIdc === 6 || generalProfileCompatibilityFlag[6] ||
  //       generalProfileIdc === 7 || generalProfileCompatibilityFlag[7]) {
  //       spsMap.put("general_max_12bit_constraint_flag", read_bits(pSPSBytes, 1));
  //       spsMap.put("general_max_10bit_constraint_flag", read_bits(pSPSBytes, 1));
  //       spsMap.put("general_max_8bit_constraint_flag", read_bits(pSPSBytes, 1));
  //       spsMap.put("general_max_422chroma_constraint_flag", read_bits(pSPSBytes, 1));
  //       spsMap.put("general_max_420chroma_constraint_flag", read_bits(pSPSBytes, 1));
  //       spsMap.put("general_max_monochrome_constraint_flag", read_bits(pSPSBytes, 1));
  //       spsMap.put("general_intra_constraint_flag", read_bits(pSPSBytes, 1));
  //       spsMap.put("general_one_picture_only_constraint_flag", read_bits(pSPSBytes, 1));
  //       spsMap.put("general_lower_bit_rate_constraint_flag", read_bits(pSPSBytes, 1));
  //       spsMap.put("general_reserved_zero_34bits", read_bits(pSPSBytes, 34));
  //     } else {
  //       spsMap.put("general_reserved_zero_43bits", read_bits(pSPSBytes, 43));
  //     }

  //     if ((generalProfileIdc >= 1 && generalProfileIdc <= 5) ||
  //       generalProfileCompatibilityFlag[1] || generalProfileCompatibilityFlag[2] ||
  //       generalProfileCompatibilityFlag[3] || generalProfileCompatibilityFlag[4] ||
  //       generalProfileCompatibilityFlag[5]) {
  //       /* The number of bits in this syntax structure is not affected by this condition */
  //       spsMap.put("general_inbld_flag", read_bits(pSPSBytes, 1));
  //     } else {
  //       spsMap.put("general_reserved_zero_bit", read_bits(pSPSBytes, 1));
  //     }
  //   }

  //   spsMap.put("general_level_idc", read_bits(pSPSBytes, 8));
  //   var subLayerProfilePresentFlag = new Array(maxNumSubLayersMinus1);
  //   var subLayerLevelPresentFlag = new Array(maxNumSubLayersMinus1);

  //   for (i = 0; i < maxNumSubLayersMinus1; i++) {
  //     subLayerProfilePresentFlag[i] = read_bits(pSPSBytes, 1);
  //     subLayerLevelPresentFlag[i] = read_bits(pSPSBytes, 1);
  //   }

  //   var reservedZero2bits = new Array(8);
  //   var subLayerProfileIdc = new Array(maxNumSubLayersMinus1);

  //   if (maxNumSubLayersMinus1 > 0) {
  //     for (i = maxNumSubLayersMinus1; i < 8; i++) {
  //       reservedZero2bits[i] = read_bits(pSPSBytes, 2);
  //     }
  //   }

  //   for (i = 0; i < maxNumSubLayersMinus1; i++) {
  //     if (subLayerProfilePresentFlag[i]) {
  //       spsMap.put("sub_layer_profile_space", read_bits(pSPSBytes, 2));
  //       spsMap.put("sub_layer_tier_flag", read_bits(pSPSBytes, 1));
  //       subLayerProfileIdc[i] = read_bits(pSPSBytes, 5);

  //       for (j = 0; j < 32; j++) {
  //         subLayerProfileCompatibilityFlag[i][j] = read_bits(pSPSBytes, 1);
  //       }

  //       spsMap.put("sub_layer_progressive_source_flag", read_bits(pSPSBytes, 1));
  //       spsMap.put("sub_layer_interlaced_source_flag", read_bits(pSPSBytes, 1));
  //       spsMap.put("sub_layer_non_packed_constraint_flag", read_bits(pSPSBytes, 1));
  //       spsMap.put("sub_layer_frame_only_constraint_flag", read_bits(pSPSBytes, 1));

  //       if (subLayerProfileIdc[i] === 4 || subLayerProfileCompatibilityFlag[i][4] ||
  //         subLayerProfileIdc[i] === 5 || subLayerProfileCompatibilityFlag[i][5] ||
  //         subLayerProfileIdc[i] === 6 || subLayerProfileCompatibilityFlag[i][6] ||
  //         subLayerProfileIdc[i] === 7 || subLayerProfileCompatibilityFlag[i][7]) {
  //         /* The number of bits in this syntax structure is not affected by this condition */
  //         spsMap.put("sub_layer_max_12bit_constraint_flag", read_bits(pSPSBytes, 1));
  //         spsMap.put("sub_layer_max_10bit_constraint_flag", read_bits(pSPSBytes, 1));
  //         spsMap.put("sub_layer_max_8bit_constraint_flag", read_bits(pSPSBytes, 1));
  //         spsMap.put("sub_layer_max_422chroma_constraint_flag", read_bits(pSPSBytes, 1));
  //         spsMap.put("sub_layer_max_420chroma_constraint_flag", read_bits(pSPSBytes, 1));
  //         spsMap.put("sub_layer_max_monochrome_constraint_flag", read_bits(pSPSBytes, 1));
  //         spsMap.put("sub_layer_intra_constraint_flag", read_bits(pSPSBytes, 1));
  //         spsMap.put("sub_layer_one_picture_only_constraint_flag", read_bits(pSPSBytes, 1));
  //         spsMap.put("sub_layer_lower_bit_rate_constraint_flag", read_bits(pSPSBytes, 1));
  //         spsMap.put("sub_layer_reserved_zero_34bits", read_bits(pSPSBytes, 34));
  //       } else {
  //         spsMap.put("sub_layer_reserved_zero_43bits", read_bits(pSPSBytes, 43));
  //       }

  //       if ((subLayerProfileIdc[i] >= 1 && subLayerProfileIdc[i] <= 5) ||
  //         subLayerProfileCompatibilityFlag[1] || subLayerProfileCompatibilityFlag[2] ||
  //         subLayerProfileCompatibilityFlag[3] || subLayerProfileCompatibilityFlag[4] ||
  //         subLayerProfileCompatibilityFlag[5]) {
  //         /* The number of bits in this syntax structure is not affected by this condition */
  //         spsMap.put("sub_layer_inbld_flag", read_bits(pSPSBytes, 1));
  //       } else {
  //         spsMap.put("sub_layer_reserved_zero_bit", read_bits(pSPSBytes, 1));
  //       }
  //     }

  //     if (subLayerLevelPresentFlag[i]) {
  //       spsMap.put("sub_layer_level_idc", read_bits(pSPSBytes, 8));
  //     }
  //   }
  // }


  // HEVC
  // VPS - Video parameter set
  // SPS - Sequence parameter set
  // PPS - Picture parameter set

  Constructor.prototype = {
    parse: function (spsPayload) {
      pSPSBytes = nal_unit_extract_rbsp(spsPayload);
      // console.log("=========================SPS START=========================");
      vBitCount = 0;
      spsMap.clear();

      // 7.3.1.2 NAL unit header syntax 
      // nal_unit_header( )
      spsMap.put("forbidden_zero_bit", read_bits(pSPSBytes, 1));
      spsMap.put("nal_unit_type", read_bits(pSPSBytes, 6));
      spsMap.put("nuh_layer_id", read_bits(pSPSBytes, 6));
      spsMap.put("nuh_temporal_id_plus1", read_bits(pSPSBytes, 3));

      // 7.3.2.2.1 General sequence parameter set RBSP syntax
      // seq_parameter_set_rbsp( )

      spsMap.put("sps_video_parameter_set_id", read_bits(pSPSBytes, 4));
      spsMap.put("sps_max_sub_layers_minus1", read_bits(pSPSBytes, 3));
      spsMap.put("sps_temporal_id_nesting_flag", read_bits(pSPSBytes, 1));

      // var maxNumSubLayersMinus1 = spsMap.get("sps_max_sub_layers_minus1");
      // profile_tier_level(1, maxNumSubLayersMinus1);

      spsMap.put("general_profile_space", read_bits(pSPSBytes, 2));
      spsMap.put("general_tier_flag", read_bits(pSPSBytes, 1));
      spsMap.put("general_profile_idc", read_bits(pSPSBytes, 5));
      spsMap.put("general_profile_compatibility_flags", read_bits(pSPSBytes, 32));
      spsMap.put("general_constraint_indicator_flags", [read_bits(pSPSBytes, 16), read_bits(pSPSBytes, 16), read_bits(pSPSBytes, 16)]);
      spsMap.put("general_level_idc", read_bits(pSPSBytes, 8));

      spsMap.put("sps_seq_parameter_set_id", ue(pSPSBytes, 0));

      spsMap.put("chroma_format_idc", ue(pSPSBytes, 0));
      if (spsMap.get("chroma_format_idc") === 3) {
        spsMap.put("separate_colour_plane_flag", read_bits(pSPSBytes, 1));
      }

      spsMap.put("pic_width_in_luma_samples", ue(pSPSBytes, 0));
      spsMap.put("pic_height_in_luma_samples", ue(pSPSBytes, 0));

      spsMap.put("conformance_window_flag", read_bits(pSPSBytes, 1));
      if (spsMap.get("conformance_window_flag") === 1) {
        spsMap.put("conf_win_left_offset", ue(pSPSBytes, 0));
        spsMap.put("conf_win_right_offset", ue(pSPSBytes, 0));
        spsMap.put("conf_win_top_offset", ue(pSPSBytes, 0));
        spsMap.put("conf_win_bottom_offset", ue(pSPSBytes, 0));
      }

      // console.log("=========================SPS END=========================");
      return true;
    },
    getSizeInfo: function () {
      var width = spsMap.get("pic_width_in_luma_samples");
      var height = spsMap.get("pic_height_in_luma_samples");

      var SubWidthC = 2;
      var SubHeightC = 2;

      if (spsMap.get("chroma_format_idc") === 0) { //monochrome
        SubWidthC = SubHeightC = 1;
      }
      else if (spsMap.get("chroma_format_idc") === 1) { //4:2:0
        SubWidthC = 2;
        SubHeightC = 2;
      }
      else if (spsMap.get("chroma_format_idc") === 2) { //4:2:2
        SubWidthC = 2;
        SubHeightC = 1;
      }
      else if (spsMap.get("chroma_format_idc") === 3) { //4:4:4
        if (spsMap.get("separate_colour_plane_flag") === 0) {
          SubWidthC = SubHeightC = 1;
        }
        else if (spsMap.get("separate_colour_plane_flag") === 1) {
          SubWidthC = SubHeightC = 1;
        }
      }

      var cropWidth = 0;
      var cropHeight = 0;

      if (spsMap.get("conformance_window_flag") === 1) {
        cropWidth = (SubWidthC * spsMap.get("conf_win_right_offset")) + (SubWidthC * spsMap.get("conf_win_left_offset"));
        cropHeight = (SubHeightC * spsMap.get("conf_win_bottom_offset")) + (SubHeightC * spsMap.get("conf_win_top_offset"));
      }

      if (cropWidth) {
        width -= cropWidth;
      } if (cropHeight) {
        height -= cropHeight;
      }

      var decodeSize = width * height;

      var sizeInfo = {
        'width': width,
        'height': height,
        'decodeSize': decodeSize,
        'cropWidth': cropWidth,
        'cropHeight': cropHeight
      };

      return sizeInfo;
    },
    getSpsValue: function (key) {
      return spsMap.get(key);
    },
    getProfileName: function () {
      var profile = spsMap.get('general_profile_idc');
      switch (profile) {
        case 1: return "Main";
        case 2: return "Main 10";
        case 3: return "Main Still Picture";
        case 4: return "Rext";
        default: return "Unknown";
      }
    },
    getCodecInfo: function () {
      var coding = 'hvc1';
      var profile_space = spsMap.get('general_profile_space');
      if (profile_space > 0 && profile_space <= 3) {
        profile_space = 'A' + (profile_space - 1);
      } else {
        profile_space = '';
      }
      var profile_idc = spsMap.get('general_profile_idc');
      var constraints = (spsMap.get('general_constraint_indicator_flags'))[0];
      while (constraints && ((constraints & 0xff) === 0)) {
        constraints >>= 8;
      }

      return coding + '.' + profile_space + profile_idc + '.' +
        reverse_bits(spsMap.get('general_profile_compatibility_flags'), 32) + '.' +
        (spsMap.get('general_tier_flag') ? 'H' : 'L') + spsMap.get('general_level_idc') + '.' +
        constraints.toString(16);
    },
    getProfileTierLevel: function () {
      var compatibilityFlags = spsMap.get('general_profile_compatibility_flags');
      var constraintFlags = spsMap.get('general_constraint_indicator_flags');

      return [
        (spsMap.get('general_profile_space') << 6 | spsMap.get('general_tier_flag') << 5 | spsMap.get('general_profile_idc')),
        (compatibilityFlags & 0xff000000) >> 24,
        (compatibilityFlags & 0xff0000) >> 16,
        (compatibilityFlags & 0xff00) >> 8,
        (compatibilityFlags & 0xff),
        (constraintFlags[0] & 0xff00) >> 8,
        (constraintFlags[0] & 0xff),
        (constraintFlags[1] & 0xff00) >> 8,
        (constraintFlags[1] & 0xff),
        (constraintFlags[2] & 0xff00) >> 8,
        (constraintFlags[2] & 0xff),
        spsMap.get('general_level_idc'),
      ];
    }
  };
  return new Constructor();
}

function UmpMap() {
  this.map = new Object();
}

UmpMap.prototype = {   
  put : function(key, value){   
    this.map[key] = value;
  },   
  get : function(key){   
    return this.map[key];
  },
  containsKey : function(key){    
    return key in this.map;
  },
  containsValue : function(value){    
    for(var prop in this.map){
      if(this.map[prop] == value) return true;
    }
    return false;
  },
  isEmpty : function(key){    
    return (this.size() == 0);
  },
  clear : function(){   
    for(var prop in this.map){
      delete this.map[prop];
    }
  },
  remove : function(key){    
    delete this.map[key];
  },
  keys : function(){   
    var keys = new Array();   
    for(var prop in this.map){   
      keys.push(prop);
    }   
    return keys;
  },
  values : function(){   
    var values = new Array();   
    for(var prop in this.map){   
      values.push(this.map[prop]);
    }   
    return values;
  },
  size : function(){
    var count = 0;
    for (var prop in this.map) {
      count++;
    }
    return count;
  }
};
function MetaDataParser(callback) {
  "use strict";

  var _version = '1.0.0';
  var metaparser_log = log4javascript.getLogger('meta:parser');

  var updateEvent = null;
  var json_raw = null;
  var xml_raw = null;
  var _self;
  var _nodesLength = 0;

  function Constructor() {
    updateEvent = callback;
    _self = this;
  }

  /**
   *
   * @description onvif data parser
   *      <wsnt:Topic xmlns:wsnt="http://docs.oasis-open.org/wsn/b-2"
   *        Dialect="http://www.onvif.org/ver10/tev/topicExpression/ConcreteSet">tns1:VideoAnalytics/tnssamsung:MotionDetection</wsnt:Topic>
   *        <wsnt:Message xmlns:wsnt="http://docs.oasis-open.org/wsn/b-2">
   *        <tt:Message xmlns:tt="http://www.onvif.org/ver10/schema" UtcTime="2000-01-06T23:24:25.472Z" PropertyOperation="Changed">
   *          <tt:Source>
   *            <tt:SimpleItem Name="VideoSourceToken" Value="85a593ef-e6e0-4e40-9e3d-f4252623e776"/>
   *          </tt:Source>
   *          <tt:Key>
   *            <tt:SimpleItemDescription Name="ROIID" Value="0"/>
   *         </tt:Key>
   *         <tt:Data>
   *           <tt:SimpleItem Name="State" Value="false"/>
   *         </tt:Data>
   *        </tt:Message>
   *      </wsnt:Message>
   * @param {*} nodes
   */
  function extractEventMetadata(nodes) { // MetaDataNodes
    var dataList = [];
    _nodesLength = nodes.length;

    for (var i = 0; i < nodes.length; i++) {
      if (nodes[i].nodeName === "tt:Event") { // event cases
        // parser event nodes
        parseEventNode(nodes[i], dataList);
      } else if (nodes[i].nodeName === "tt:VideoAnalytics") {
        // parser video analytics nodes
        parseVideoAnalyticsNode(nodes[i], dataList);
      } else if (nodes[i].nodeName === "tt:PTZ") {
        // parser ptz nodes
        //parsePTZNode(nodes[i], dataList);
        parsePTZNode(nodes[i]);
      }
      // dataList.json = JSON.stringify(xmlToJson(nodes[i]));
    }
    dataList.json = json_raw;
    dataList.xml = xml_raw;
    updateEvent(dataList, true);
  }

  /**
   *
   * @description onvif ptz data parser
   * MAKE_TIMESTAMP(metadata->ptz.tv);
   *   ADD("<tt:PTZ>");
   *   ADD(    "<tt:PTZStatus>"
   *                 "<tt:Position>"
   *                 "  <tt:PanTilt x=\"%f\" y=\"%f\"/>"
   *                 "  <tt:Zoom x=\"%f\"/>"
   *                 "</tt:Position>",
   * metadata->ptz.panPosition, metadata->ptz.tiltPosition, metadata->ptz.zoomPosition);
   *   ADD(       "<tt:MoveStatus>"
   *                   "<tt:PanTilt>%s</tt:PanTilt>"
   *                   "<tt:Zoom>%s</tt:Zoom>"
   *                 "</tt:MoveStatus>",
   * metadata->ptz.moveStatus.panTilt, metadata->ptz.moveStatus.zoom);
   *   ADD(        "<tt:UtcTime>%s</tt:UtcTime>", timestamp);
   *   ADD(    "</tt:PTZStatus>");
   *   ADD("</tt:PTZ>");
   *
   * @param {*} eventNode
   * @param {*} dataList
   */
  var parsePTZNode = function (eventNode, dataList) {
    var eventDataArray = [];
    var PTZStatusNodes = eventNode.childNodes; // <wsnt:NotificationMessage>

    var topNameFilter = { "PTZStatus": true }, typeNameFilter = { "MoveStatus": true },
      subTypeNameFilter = { "PanTilt": true, "Zoom": true };

    Array.prototype.forEach.call(PTZStatusNodes, function (topNode) {
      if (topNameFilter[topNode.localName] !== true) {
        return;
      }
      Array.prototype.forEach.call(topNode.childNodes, function (typeNode) {
        var typeName = typeNode.localName;
        if (typeNameFilter[typeName] !== true) {
          return;
        }
        Array.prototype.forEach.call(typeNode.childNodes, function (subTypeNode) {
          var subTypeName = subTypeNode.localName;
          if (subTypeNameFilter[subTypeName] !== true) {
            return;
          }
          eventDataArray.push({
            "type": typeName + ":" + subTypeName,
            "value": subTypeNode.textContent,
            "channelId": _self.getChannel()
          });
        });
      });
    });

    eventDataArray.forEach(function (eventData) {
      updateEvent(eventData);
    });

    if (typeof dataList !== "undefined") {
      dataList.concat(eventDataArray);
    }
  }

  /**
   *
   * @param {*} eventNode
   * @param {*} dataList
   */
  var parseEventNode = function (eventNode, dataList) {
    var NotiNodes = eventNode.childNodes, // <wsnt:NotificationMessage>
      data = {},
      tempNodes = null,
      topicXml = null,
      messageXml = null,
      eventName = null,
      value = null,
      eventId = null;

    for (var i = 0; i < NotiNodes.length; i++) {
      tempNodes = NotiNodes[i].childNodes;
      topicXml = tempNodes[0];
      messageXml = tempNodes[1].childNodes[0].childNodes;
      eventName = getEventName(topicXml.childNodes[0].nodeValue);

      for (var j = 0; j < messageXml.length; j++) {
        if (messageXml[j].nodeName === "tt:Source") {
          if (typeof messageXml[j].childNodes[0] !== "undefined") {
            var nodeValue = messageXml[j].childNodes[0].getAttribute("Value").split('-');
            eventId = nodeValue[1];
          } else if (typeof messageXml[j].childNodes[1] !== "undefined") {
            eventId = messageXml[j].childNodes[1].getAttribute("Value");
          }
        } else if (messageXml[j].nodeName === "tt:Data") {
          if (eventName === "SoundClassification") {
            eventId = messageXml[j].childNodes[2].getAttribute("Value");
            value = messageXml[j].childNodes[0].getAttribute("Value");
          } else if (eventName === "BoxTemperatureReading") {
            var maxTemper = messageXml[j].childNodes[0].childNodes[0].getAttribute("MaxTemperature")
            var minTemper = messageXml[j].childNodes[0].childNodes[0].getAttribute("MinTemperature")
            var avgTemper = messageXml[j].childNodes[0].childNodes[0].getAttribute("AverageTemperature")
            eventId = messageXml[j].childNodes[0].childNodes[0].getAttribute("ItemID")
            value = {
              'maxTemperature': maxTemper,
              'minTemperature': minTemper,
              'averageTemperature': avgTemper
            }
          } else {
            value = messageXml[j].childNodes[0].getAttribute("Value");
          }
        }
      }

      if (eventName !== "BoxTemperatureReading") {
        if (value !== null && typeof value !== "undefined") {
          if (value === "inactive" || value === "false") {
            value = "false";
          } else {
            value = "true";
          }
        }
      }

      data = {
        "id": 1,
        "type": eventName,
        "value": value,
        "eventId": eventId,
        "channelId": _self.getChannel()
      };

      dataList.push(data);
    }
  }

  var getEventName = function (event) {
    var eventName = "";
    switch (event) {
      case "tns1:Device/tns1:Trigger/tns1:DigitalInput":
      case "tns1:Device/tns1:Trigger/tnssamsung:DigitalInput":
        eventName = "DigitalInput";
        break;
      case "tns1:VideoSource/tnssamsung:FaceDetection":
        eventName = "FaceDetection";
        break;
      case "tns1:VideoSource/ImageTooBlurry/ImagingService":
      case "tns1:VideoSource/tnssamsung:DefocusDetection":
        eventName = "DefocusDetection";
        break;
      case "tns1:VideoSource/ImageTooBright/ImagingService":
      case "tns1:VideoSource/tnssamsung:Fog":
        eventName = "Fog";
        break;
      case "tns1:RuleEngine/MotionRegionDetector/Motion":
      case "tns1:VideoAnalytics/tnssamsung:MotionDetection":
      case "tns1:VideoAnalytics/tns1:MotionDetection":
        eventName = "MotionDetection";
        break;
      case "tns1:VideoAnalytics/tnssamsung:VideoAnalytics":
        eventName = "VideoAnalytics";
        break;
      case "tns1:VideoSource/GlobalSceneChange/ImagingService":
      case "tns1:VideoSource/tnssamsung:TamperingDetection":
        eventName = "TamperingDetection";
        break;
      case "tns1:AudioSource/tnssamsung:AudioDetection":
        eventName = "AudioDetection";
        break;
      case "tns1:Device/tns1:Trigger/tns1:Relay":
        eventName = "Relay";
        break;
      case "tns1:VideoSource/tnssamsung:DigitalAutoTracking":
        eventName = "DigitalAutoTracking";
        break;
      case "tns1:AudioAnalytics/Audio/DetectedSound":
        eventName = "SoundClassification";
        break;
      case "tns1:VideoSource/tnssamsung:QueueManagement":
        eventName = "Queue";
        break;
      case "tns1:VideoSource/tnssamsung:AutoTracking":
        eventName = "AutoTracking";
        break;
      case "tns1:VideoSource/tnssamsung:ShockDetection":
        eventName = "ShockDetection";
        break;
      case "tns1:VideoSource/tnssamsung:TrackingEnable":
        eventName = "TrackingEnable";
        break;
      case "tns1:Device/tns1:AlarmOut":
        eventName = "AlarmOut";
        break;
      case "tns1:RuleEngine/Radiometry/TemperatureAlarm":
        eventName = "TemperatureChangeDetection";
        break;
      case "tns1:VideoAnalytics/Radiometry/BoxTemperatureReading":
        eventName = "BoxTemperatureReading";
        break;
      case "tns1:VideoSource/RadiometryAlarm":
        eventName = "RadiometryAlarm";
        break;
      default:
        eventName = "Unknown Event";
        break;
    }

    return eventName;
  }
  /**
   *
   * @param {*} videoAnalyticsNode
   * @param {*} dataList
   */
  var parseVideoAnalyticsNode = function (videoAnalyticsNode, dataList) {
    var frameNodes = videoAnalyticsNode.childNodes, // tt:frame
      utcTime = frameNodes[0].getAttribute('UtcTime'),
      tempNodes = frameNodes[0].childNodes, // tt:Transformation or Object
      transformationNode = tempNodes[0],
      objectLength = tempNodes.length;
      metaparser_log.debug("metaParser utcTime " + utcTime);

    if (tempNodes[objectLength - 1].nodeName === "tt:Extension") {
      if (
        tempNodes[objectLength - 1].childNodes[0].nodeName === "tnssamsung:DigitalAutoTracking") {
        objectLength -= 2;
      }
    }

    var translateNode = transformationNode.childNodes[0],
      translate = [
        parseFloat(translateNode.getAttribute('x')),
        parseFloat(translateNode.getAttribute('y'))
      ],
      scaleNode = transformationNode.childNodes[1],
      scale = [
        parseFloat(scaleNode.getAttribute('x')),
        parseFloat(scaleNode.getAttribute('y'))
      ],
      data = null;

    for (var i = 1; i < objectLength; i++) {
      var objectNode = tempNodes[i];
      var objectId = objectNode.getAttribute('ObjectId');
      if (objectNode.attributes.length !== 0) {
        var appearanceNode = objectNode.childNodes[0];

        var shapeNode = appearanceNode.childNodes[0];
        var classNode = appearanceNode.childNodes[1];
        var infoNode = appearanceNode.childNodes[2];
        var imageNode = appearanceNode.childNodes[3];

        var boundingBox = shapeNode.childNodes[0];
        var coordinates = [
          parseFloat(boundingBox.getAttribute('left')),
          parseFloat(boundingBox.getAttribute('right')),
          parseFloat(boundingBox.getAttribute('top')),
          parseFloat(boundingBox.getAttribute('bottom'))
        ];
        var centerOfGravity = shapeNode.childNodes[1];
        var COGCoordinates = [
          parseFloat(centerOfGravity.getAttribute('x')),
          parseFloat(centerOfGravity.getAttribute('y'))
        ];
        var type = "",
          likelihood = "";
        if (typeof classNode === "undefined") {
          type = 'VideoAnalytics';
        } else if (!classNode || classNode.nodeName !== "tt:Class") {
          return;
        } else {
          type = classNode.childNodes[0].childNodes[0].textContent;
          likelihood = parseFloat(classNode.childNodes[0].childNodes[1].textContent);
          type = type === "Face" ? "FaceDetection" : type;
        }

        if (type === "VideoAnalytics") {
          var color = 1;
          if(_nodesLength === 2) {
            color = 0;
          }
          data = {
            "id": 2,
            "scale": scale,
            "translate": translate,
            "coordinates": coordinates,
            "type": type,
            "color": color,
            "channelId": _self.getChannel()
          };
        } else if (type === 'FaceDetection') {
          data = {
            "id": 2,
            "scale": scale,
            "translate": translate,
            "coordinates": coordinates,
            "type": type,
            "color": 0,
            "channelId": _self.getChannel()
          };
        } else {
          data = {
            "id": objectId,
            "scale": scale,
            "translate": translate,
            "coordinates": coordinates,
            "COGCoordinates": COGCoordinates,
            "type": type,
            "likelihood": likelihood,
            "color": 1,
            "utcTime": utcTime,
            "infodata": infoNode ? node2ClassInfo(type, infoNode) : null,
            "image": imageNode ? imageNode.childNodes[0].textContent : null,
            "channelId": _self.getChannel()
          };
        }
        dataList.push(data);
      }
    }
  }

  var node2ClassInfo = function (classType, infoNode) {
    switch (classType) {
      case "Human":
        return {
          "Gender": infoNode.childNodes[0].textContent,
          "Age": infoNode.childNodes[1].textContent,
          "Upper": {
            "color" : infoNode.childNodes[2].getAttribute('color'),
            "type" : infoNode.childNodes[2].getAttribute('type')
          },
          "Lower":{
            "color" : infoNode.childNodes[3].getAttribute('color'),
            "type" : infoNode.childNodes[3].getAttribute('type')
          },
          "Hat": infoNode.childNodes[4].textContent,
          "Bag": infoNode.childNodes[5].textContent
        };
      case "Face":
        return {
          "Gender": infoNode.childNodes[0].textContent,
          "Age": infoNode.childNodes[1].textContent,
          "Hat": infoNode.childNodes[2].textContent,
          "Glasses": infoNode.childNodes[3].textContent
        };
      case "Vehicle":
        return {
          "Type": infoNode.childNodes[0].textContent,
          "Color": infoNode.childNodes[1].textContent
        };
    }
  }

  // Changes XML to JSON
  // Modified version from here: http://davidwalsh.name/convert-xml-json
  function xmlToJson(xml) {

    // Create the return object
    var obj = {};

    if (xml.nodeType == 1) { // element
      // do attributes
      if (xml.attributes.length > 0) {
        obj["@attributes"] = {};
        for (var j = 0; j < xml.attributes.length; j++) {
          var attribute = xml.attributes.item(j);
          obj["@attributes"][attribute.nodeName] = attribute.nodeValue;
        }
      }
    } else if (xml.nodeType == 3) { // text
      obj = xml.nodeValue;
    }

    // do children
    // If just one text node inside
    if (xml.hasChildNodes() && xml.childNodes.length === 1 && xml.childNodes[0].nodeType === 3) {
      obj = xml.childNodes[0].nodeValue;
    } else if (xml.hasChildNodes()) {
      for (var i = 0; i < xml.childNodes.length; i++) {
        var item = xml.childNodes.item(i);
        var nodeName = item.nodeName;
        if (typeof (obj[nodeName]) == "undefined") {
          obj[nodeName] = xmlToJson(item);
        } else {
          if (typeof (obj[nodeName].push) == "undefined") {
            var old = obj[nodeName];
            obj[nodeName] = [];
            obj[nodeName].push(old);
          }
          obj[nodeName].push(xmlToJson(item));
        }
      }
    }
    return obj;
  }

  function arrayCompare(givenArray, searchArray) {
    var i = 0,
      j = 0,
      k = 0;
    while (true) {
      k = givenArray.indexOf(searchArray[j], i);
      if ( k > -1 ) {
        i = k;
      } else {
        return -1;
      }

      while ( givenArray[i++] === searchArray[j++] ) {
      }

      if (j >= searchArray.length){
        return i-1;
      }
      j = 0;
    }
  }

  Constructor.prototype = {
    setChannel: function (channelid) {
      metaparser_log.debug("metaParser::setChannel", channelid);
      Constructor.prototype.channelId = (channelid === null ? 0 : channelid);
    },
    getChannel: function () {
      metaparser_log.debug("metaParser::getChannel ", Constructor.prototype.channelId);
      return Constructor.prototype.channelId;
    },
    parse: function (metaData) {
      // metaparser_log.debug("metaParser::parser", metaData);
      var MetaDataNodes = null,
        xmlDoc = null;

      try {
        var receiveMsg = String.fromCharCode.apply(null, metaData);

        // check the "<?xml" by input string
        if (receiveMsg.indexOf("<?xml") !== -1) {
          // metaparser_log.debug(receiveMsg);
          // if you can use the jquery
          if (window.jQuery) {
              // if (metaData.length > 20000) {
              //   // receiveMsg.substring(receiveMsg.indexOf("<tt:BinaryData>") + 15, receiveMsg.indexOf("</tt:BinaryData>"))
              //   temp1 = receiveMsg.split("<tt:BinaryData>");
              //   temp2 = temp1[1].split("</tt:BinaryData>");
              //   receiveMsg = temp1[0] + temp2[1];
              //   image = temp2[0];
              // }
            metaparser_log.debug("metaParser parsing with jquery on normal");
            xmlDoc = $.parseXML(receiveMsg);
            MetaDataNodes = xmlDoc.documentElement.childNodes;
          } else if (window.DOMParser) {
            // Standard parser using DOMParser
            metaparser_log.debug("metaParser parsing without jquery on normal");
            // reference from
            // https://stackoverflow.com/questions/18538192/parse-xml-with-javascript-without-jquery
            xmlDoc = new DOMParser().parseFromString(receiveMsg, 'text/xml');
            MetaDataNodes = xmlDoc.childNodes[0].childNodes;
            xml_raw = receiveMsg;
            json_raw = JSON.stringify(xmlToJson(xmlDoc));
          } else {
            metaparser_log.debug("error", error);
            throw new umpError({
              channelId: this.getChannel(),
              errorCode: fromHex('0x0907'),
              place: 'metaDataParser.js:432',
              message: "Your web browser is not support DOM Parser, So you have to use the Jquery library"
            });
          }
        }
        xmlDoc = null;
      } catch (error) {
        metaparser_log.debug("error", error);
        throw new umpError({
          channelId: this.getChannel(),
          errorCode: fromHex('0x0907'),
          place: 'metaDataParser.js:443',
          message: "Metadata Parsing Error  [" + error.message + "]"
        });
      }

      if (MetaDataNodes !== null) {
        try {
          extractEventMetadata(MetaDataNodes);
        } catch (error) {
          metaparser_log.debug("error", error);
          throw new umpError({
            channelId: this.getChannel(),
            errorCode: fromHex('0x0907'),
            place: 'metaDataParser.js:458',
            message: "Metadata Parsing Error  [" + error.message + "]"
          });
        }
      }
    }
  };
  return new Constructor();
}
//'use strict';
/**
* mux.js
*
* Copyright (c) 2015 Brightcove
* All rights reserved.
*
* Functions that generate fragmented MP4s suitable for use with Media
* Source Extensions.
*/
var box, dinf, esds, ftyp, mdat, mfhd, minf, moof, moov, mvex, mvhd,
  trak, tkhd, mdia, mdhd, hdlr, sdtp, stbl, stsd, traf, trex,
  trun, types, MAJOR_BRAND, MINOR_VERSION, AVC1_BRAND, VIDEO_HDLR,
  ISO5_BRAND, DASH_BRAND, iods, mehd, trep, free,
  udta, meta, ilst, styp, sidx,
  AUDIO_HDLR, HDLR_TYPES, VMHD, SMHD, DREF, STCO, STSC, STSZ, STTS;

// pre-calculate constants
(function () {
  var i;
  types = {
    avc1: [], // codingname
    avcC: [],
    hvc1: [],
    hvcC: [],
    btrt: [],
    dinf: [],
    dref: [],
    esds: [],
    ftyp: [],
    hdlr: [],
    mdat: [],
    mdhd: [],
    mdia: [],
    mfhd: [],
    minf: [],
    moof: [],
    moov: [],
    mp4a: [], // codingname
    mvex: [],
    mvhd: [],
    iods: [],
    sdtp: [],
    smhd: [],
    stbl: [],
    stco: [],
    stsc: [],
    stsd: [],
    stsz: [],
    stts: [],
    styp: [],
    tfdt: [],
    tfhd: [],
    traf: [],
    trak: [],
    trun: [],
    trex: [],
    trep: [],
    mehd: [],
    tkhd: [],
    vmhd: [],
    udta: [],
    meta: [],
    ilst: [],
    free: [],
    sidx: []
  };

  // In environments where Uint8Array is undefined (e.g., IE8), skip set up so that we
  // don't throw an error
  if (typeof Uint8Array === 'undefined') {
    return;
  }

  for (i in types) {
    if (types.hasOwnProperty(i)) {
      types[i] = [
        i.charCodeAt(0),
        i.charCodeAt(1),
        i.charCodeAt(2),
        i.charCodeAt(3)
      ];
    }
  }

  MAJOR_BRAND = new Uint8Array([
    'i'.charCodeAt(0),
    's'.charCodeAt(0),
    'o'.charCodeAt(0),
    'm'.charCodeAt(0)
  ]);
  AVC1_BRAND = new Uint8Array([
    'a'.charCodeAt(0),
    'v'.charCodeAt(0),
    'c'.charCodeAt(0),
    '1'.charCodeAt(0)
  ]);
  ISO5_BRAND = new Uint8Array([
    'i'.charCodeAt(0),
    's'.charCodeAt(0),
    'o'.charCodeAt(0),
    '5'.charCodeAt(0)
  ]);
  DASH_BRAND = new Uint8Array([
    'd'.charCodeAt(0),
    'a'.charCodeAt(0),
    's'.charCodeAt(0),
    'h'.charCodeAt(0)
  ]);
  MINOR_VERSION = new Uint8Array([0, 0, 0, 1]);
  VIDEO_HDLR = new Uint8Array([
    0x00, // version 0
    0x00, 0x00, 0x00, // flags
    0x00, 0x00, 0x00, 0x00, // pre_defined
    0x76, 0x69, 0x64, 0x65, // handler_type: 'vide'
    0x00, 0x00, 0x00, 0x00, // reserved
    0x00, 0x00, 0x00, 0x00, // reserved
    0x00, 0x00, 0x00, 0x00, // reserved
    0x55, 0x57, 0x41, 0x5F,
    0x36, 0x30, 0x30, 0x70,
    0x5F, 0x33, 0x30, 0x66,
    0x70, 0x73, 0x2E, 0x68,
    0x32, 0x36, 0x34, 0x00
  ]);
  AUDIO_HDLR = new Uint8Array([
    0x00, // version 0
    0x00, 0x00, 0x00, // flags
    0x00, 0x00, 0x00, 0x00, // pre_defined
    0x73, 0x6f, 0x75, 0x6e, // handler_type: 'soun'
    0x00, 0x00, 0x00, 0x00, // reserved
    0x00, 0x00, 0x00, 0x00, // reserved
    0x00, 0x00, 0x00, 0x00, // reserved
    0x53, 0x6f, 0x75, 0x6e,
    0x64, 0x48, 0x61, 0x6e,
    0x64, 0x6c, 0x65, 0x72, 0x00 // name: 'SoundHandler'
  ]);
  HDLR_TYPES = {
    video: VIDEO_HDLR,
    audio: AUDIO_HDLR
  };
  DREF = new Uint8Array([
    0x00, // version 0
    0x00, 0x00, 0x00, // flags
    0x00, 0x00, 0x00, 0x01, // entry_count
    0x00, 0x00, 0x00, 0x0c, // entry_size
    0x75, 0x72, 0x6c, 0x20, // 'url' type
    0x00, // version 0
    0x00, 0x00, 0x01 // entry_flags
  ]);
  SMHD = new Uint8Array([
    0x00,             // version
    0x00, 0x00, 0x00, // flags
    0x00, 0x00,       // balance, 0 means centered
    0x00, 0x00        // reserved
  ]);
  STCO = new Uint8Array([
    0x00, // version
    0x00, 0x00, 0x00, // flags
    0x00, 0x00, 0x00, 0x00 // entry_count
  ]);
  STSC = STCO;
  STSZ = new Uint8Array([
    0x00, // version
    0x00, 0x00, 0x00, // flags
    0x00, 0x00, 0x00, 0x00, // sample_size
    0x00, 0x00, 0x00, 0x00 // sample_count
  ]);
  STTS = STCO;
  VMHD = new Uint8Array([
    0x00, // version
    0x00, 0x00, 0x01, // flags
    0x00, 0x00, // graphicsmode
    0x00, 0x00,
    0x00, 0x00,
    0x00, 0x00 // opcolor
  ]);
}());

box = function (type) {
  var
    payload = [],
    size = 0,
    i,
    result,
    view;

  for (i = 1; i < arguments.length; i++) {
    payload.push(arguments[i]);
  }

  i = payload.length;

  // calculate the total size we need to allocate
  while (i--) {
    size += payload[i].byteLength;
  }
  result = new Uint8Array(size + 8);
  view = new DataView(result.buffer, result.byteOffset, result.byteLength);
  view.setUint32(0, result.byteLength);
  result.set(type, 4);

  // copy the payload into the result
  for (i = 0, size = 8; i < payload.length; i++) {
    result.set(payload[i], size);
    size += payload[i].byteLength;
  }
  return result;
};

dinf = function () {
  return box(types.dinf, box(types.dref, DREF));
};

esds = function (track) {
  return box(types.esds, new Uint8Array([
    0x00, // version
    0x00, 0x00, 0x00, // flags

    // ES_Descriptor
    0x03, // tag, ES_DescrTag
    0x19, // length
    0x00, 0x00, // ES_ID
    0x00, // streamDependenceFlag, URL_flag, reserved, streamPriority

    // DecoderConfigDescriptor
    0x04, // tag, DecoderConfigDescrTag
    0x11, // length
    0x40, // object type
    0x15,  // streamType
    0x00, 0x06, 0x00, // bufferSizeDB
    0x00, 0x00, 0xda, 0xc0, // maxBitrate
    0x00, 0x00, 0xda, 0xc0, // avgBitrate

    // DecoderSpecificInfo
    0x05, // tag, DecoderSpecificInfoTag
    0x02, // length
    // ISO/IEC 14496-3, AudioSpecificConfig
    // for samplingFrequencyIndex see ISO/IEC 13818-7:2006, 8.1.3.2.2, Table 35
    (track.audioobjecttype << 3) | (track.samplingfrequencyindex >>> 1),
    (track.samplingfrequencyindex << 7) | (track.channelcount << 3),
    0x06, 0x01, 0x02 // GASpecificConfig
  ]));
};

ftyp = function () {
  return box(types.ftyp, MAJOR_BRAND, MINOR_VERSION, AVC1_BRAND, ISO5_BRAND, DASH_BRAND);
};

hdlr = function (type) {
  if (type === undefined) {
    var
      bytes = new Uint8Array([
        0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00,
        0x6D, 0x64, 0x69, 0x72,
        0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00,
        0x00
      ]);
    return box(types.hdlr, bytes);
  } else {
    return box(types.hdlr, HDLR_TYPES[type]);
  }
};
mdat = function (data) {
  return box(types.mdat, data);
};
mdhd = function (track) {
  var result = new Uint8Array([
    0x00,                   // version 0
    0x00, 0x00, 0x00,       // flags
    0x00, 0x00, 0x00, 0x02, // creation_time
    0x00, 0x00, 0x00, 0x03, // modification_time
    0x00, 0x00, 0x27, 0x10, // timescale, 10000 "ticks" per second
    (track.duration >>> 24) & 0xFF,
    (track.duration >>> 16) & 0xFF,
    (track.duration >>> 8) & 0xFF,
    track.duration & 0xFF,
    0x55, 0xc4, // 'und' language (undetermined)
    0x00, 0x00
  ]);

  // Use the sample rate from the track metadata, when it is
  // defined. The sample rate can be parsed out of an ADTS header, for
  // instance.
  if (track.samplerate) {
    result[12] = (track.samplerate >>> 24) & 0xFF;
    result[13] = (track.samplerate >>> 16) & 0xFF;
    result[14] = (track.samplerate >>> 8) & 0xFF;
    result[15] = (track.samplerate) & 0xFF;
  }

  return box(types.mdhd, result);
};
mdia = function (track) {
  return box(types.mdia, mdhd(track), hdlr(track.type), minf(track));
};
mfhd = function (sequenceNumber) {
  return box(types.mfhd, new Uint8Array([
    0x00, // version
    0x00, 0x00, 0x00, // flags
    (sequenceNumber & 0xFF000000) >> 24,
    (sequenceNumber & 0xFF0000) >> 16,
    (sequenceNumber & 0xFF00) >> 8,
    sequenceNumber & 0xFF // sequence_number
  ]));
};
minf = function (track) {
  return box(types.minf,
    track.type === 'video' ? box(types.vmhd, VMHD) : box(types.smhd, SMHD),
    dinf(),
    stbl(track));
};
moof = function (sequenceNumber, tracks) {
  var
    trackFragments = [],
    i = tracks.length;
  // build traf boxes for each track fragment
  while (i--) {
    trackFragments[i] = traf(tracks[i]);
  }
  return box.apply(null, [types.moof, mfhd(sequenceNumber)].concat(trackFragments));
};
/**
 * Returns a movie box.
 * @param tracks {array} the tracks associated with this movie
 * @see ISO/IEC 14496-12:2012(E), section 8.2.1
 */
moov = function (tracks) {
  var
    i = tracks.length,
    boxes = [];

  while (i--) {
    boxes[i] = trak(tracks[i]);
  }

  return box.apply(null, [types.moov, mvhd(0x00000000)/*, iods()*/].concat(mvex(tracks)).concat(boxes));
};
mvex = function (tracks, fps) {
  var
    i = tracks.length,
    boxes = [];

  while (i--) {
    boxes[i] = trex(tracks[i], (1000 / tracks[0].fps));
  }
  return box.apply(null, [types.mvex].concat(boxes));
};

udta = function () {
  return box(types.udta, meta());
};

meta = function () {
  var
    bytes = new Uint8Array([
      0x00, 0x00, // version 0
      0x00, 0x00, // flags
    ]);
  return box(types.meta, bytes, hdlr(), ilst());
};

styp = function () {
  var
    bytes = new Uint8Array([
      0x6D, 0x73, 0x64, 0x68,
      0x00, 0x00, 0x00, 0x00,
      0x6D, 0x73, 0x64, 0x68,
      0x6D, 0x73, 0x69, 0x78
    ]);
  return box(types.styp, bytes);
};

sidx = function (size, ept) {
  var
    bytes = new Uint8Array([
      0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x01,
      //0x00, 0x00, 0x27, 0x10, //25000
      0x00, 0x00, 0x27, 0x10, // timescale, 10000 "ticks" per second
      //0x00, 0x00, 0x03, 0xE8, // timescale, 1000 "ticks" per second
      //0x00, 0x01, 0x5F, 0x90, // timescale, 90,000 "ticks" per second
      (ept & 0xFF000000) >> 24,
      (ept & 0xFF0000) >> 16,
      (ept & 0xFF00) >> 8,
      ept & 0xFF, // Earliest presentation time
      0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x01,
      (size & 0xFF000000) >> 24,
      (size & 0xFF0000) >> 16,
      (size & 0xFF00) >> 8,
      size & 0xFF, // size
      //0x00, 0x00, 0x27, 0x10, //20000
      //0x00, 0x01, 0x5F, 0x90, // timescale, 90,000 "ticks" per second
      //0x00, 0x00, 0x03, 0xE8, // timescale, 1000 "ticks" per second
      0x00, 0x00, 0x27, 0x10, // timescale, 10000 "ticks" per second
      0x90, 0x00, 0x00, 0x00
    ]);
  return box(types.sidx, bytes);
};

free = function () {
  var
    bytes = new Uint8Array([
      0x49, 0x73, 0x6F, 0x4D,
      0x65, 0x64, 0x69, 0x61,
      0x20, 0x46, 0x69, 0x6C,
      0x65, 0x20, 0x50, 0x72,
      0x6F, 0x64, 0x75, 0x63,
      0x65, 0x64, 0x20, 0x77,
      0x69, 0x74, 0x68, 0x20,
      0x47, 0x50, 0x41, 0x43,
      0x20, 0x30, 0x2E, 0x36,
      0x2E, 0x32, 0x2D, 0x44,
      0x45, 0x56, 0x2D, 0x72,
      0x65, 0x76, 0x36, 0x32,
      0x37, 0x2D, 0x67, 0x38,
      0x61, 0x39, 0x66, 0x39,
      0x38, 0x33, 0x2D, 0x6D,
      0x61, 0x73, 0x74, 0x65,
      0x72, 0x00
    ]);
  return box(types.free, bytes);
};

ilst = function () {
  var
    bytes = new Uint8Array([
      0x00, 0x00, 0x00, 0x52,
      0xA9, 0x74, 0x6F, 0x6F,
      0x00, 0x00, 0x00, 0x4A,
      0x64, 0x61, 0x74, 0x61,
      0x00, 0x00, 0x00, 0x01,
      0x00, 0x00, 0x00, 0x00,
      0x4D, 0x79, 0x20, 0x4D,
      0x50, 0x34, 0x42, 0x6F,
      0x78, 0x20, 0x47, 0x55,
      0x49, 0x20, 0x30, 0x2E,
      0x36, 0x2E, 0x30, 0x2E,
      0x36, 0x20, 0x3C, 0x68,
      0x74, 0x74, 0x70, 0x3A,
      0x2F, 0x2F, 0x6D, 0x79,
      0x2D, 0x6D, 0x70, 0x34,
      0x62, 0x6F, 0x78, 0x2D,
      0x67, 0x75, 0x69, 0x2E,
      0x7A, 0x79, 0x6D, 0x69,
      0x63, 0x68, 0x6F, 0x73,
      0x74, 0x2E, 0x63, 0x6F,
      0x6D, 0x3E
    ]);
  return box(types.ilst, bytes);
};

mehd = function () {
  var
    bytes = new Uint8Array([
      0x00, 0x00, // version 0
      0x00, 0x00, // flags
      0x00, 0x00,
      0x2C, 0x10 // Fragment duration
    ]);
  return box(types.mehd, bytes);
};

trep = function () {
  var
    bytes = new Uint8Array([
      0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00
    ]);

  return box(types.trep, bytes);
};



mvhd = function (duration) {
  var
    bytes = new Uint8Array([
      0x00, // version 0
      0x00, 0x00, 0x00, // flags
      0x00, 0x00, 0x00, 0x01, // creation_time
      0x00, 0x00, 0x00, 0x02, // modification_time
      //0x00, 0x01, 0x5F, 0x90, // timescale, 90,000 "ticks" per second
      //0x00, 0x00, 0x03, 0xE8, // timescale, 1,000 "ticks" per second
      0x00, 0x00, 0x27, 0x10, // timescale, 10000 "ticks" per second
      0xFF, 0xFF, 0xFF, 0xFF, // duration
      // (duration & 0xFF000000) >> 24,
      // (duration & 0xFF0000) >> 16,
      // (duration & 0xFF00) >> 8,
      // duration & 0xFF, // duration
      0x00, 0x01, 0x00, 0x00, // 1.0 rate
      0x01, 0x00, // 1.0 volume
      0x00, 0x00, // reserved
      0x00, 0x00, 0x00, 0x00, // reserved
      0x00, 0x00, 0x00, 0x00, // reserved
      0x00, 0x01, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00,
      0x00, 0x01, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00,
      0x40, 0x00, 0x00, 0x00, // transformation: unity matrix
      0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, // pre_defined
      0x00, 0x00, 0x00, 0x02 // next_track_ID
    ]);
  return box(types.mvhd, bytes);
};

iods = function () {
  var
    bytes = new Uint8Array([
      0x00, 0x00, // version 0
      0x00, 0x00, // flags
      0x10, // Tag
      0x07, // Tag Size
      0x00, //URL flag
      0x4F, 0xFF, 0xFF, 0xFF,
      0x15, 0xFF
    ]);
  return box(types.iods, bytes);
};

sdtp = function (track) {
  var
    samples = track.samples || [],
    bytes = new Uint8Array(4 + samples.length),
    flags,
    i;

  // leave the full box header (4 bytes) all zero

  // write the sample table
  for (i = 0; i < samples.length; i++) {
    flags = samples[i].flags;

    bytes[i + 4] = (flags.dependsOn << 4) |
      (flags.isDependedOn << 2) |
      (flags.hasRedundancy);
  }

  return box(types.sdtp,
    bytes);
};

stbl = function (track) {
  return box(types.stbl,
    stsd(track),
    box(types.stts, STTS),
    box(types.stsc, STSC),
    box(types.stsz, STSZ),
    box(types.stco, STCO));
};

(function () {
  var videoSample, audioSample;

  stsd = function (track) {

    return box(types.stsd, new Uint8Array([
      0x00, // version 0
      0x00, 0x00, 0x00, // flags
      0x00, 0x00, 0x00, 0x01
    ]), track.type === 'video' ? videoSample(track) : audioSample(track));
  };

  videoSample = function (track) {
    var
      vps = track.vps || [],
      sps = track.sps || [],
      pps = track.pps || [],
      videoParameterSets = [],
      sequenceParameterSets = [],
      pictureParameterSets = [],
      i;

    // assemble the VPSs
    for (i = 0; i < vps.length; i++) {
      videoParameterSets.push((vps[i].byteLength & 0xFF00) >>> 8);
      videoParameterSets.push((vps[i].byteLength & 0xFF)); // videoParameterSetLength
      videoParameterSets = videoParameterSets.concat(Array.prototype.slice.call(vps[i])); // VPS
    }

    // assemble the SPSs
    for (i = 0; i < sps.length; i++) {
      sequenceParameterSets.push((sps[i].byteLength & 0xFF00) >>> 8);
      sequenceParameterSets.push((sps[i].byteLength & 0xFF)); // sequenceParameterSetLength
      sequenceParameterSets = sequenceParameterSets.concat(Array.prototype.slice.call(sps[i])); // SPS
    }

    // assemble the PPSs
    for (i = 0; i < pps.length; i++) {
      pictureParameterSets.push((pps[i].byteLength & 0xFF00) >>> 8);
      pictureParameterSets.push((pps[i].byteLength & 0xFF));
      pictureParameterSets = pictureParameterSets.concat(Array.prototype.slice.call(pps[i]));
    }

    if (track.codecType === "H264") {
      return box(types.avc1, new Uint8Array([
        0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, // reserved
        0x00, 0x01, // data_reference_index
        0x00, 0x00, // pre_defined
        0x00, 0x00, // reserved
        0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, // pre_defined
        (track.width & 0xff00) >> 8,
        track.width & 0xff, // width
        (track.height & 0xff00) >> 8,
        track.height & 0xff, // height
        0x00, 0x48, 0x00, 0x00, // horizresolution
        0x00, 0x48, 0x00, 0x00, // vertresolution
        0x00, 0x00, 0x00, 0x00, // reserved
        0x00, 0x01, // frame_count
        0x13,
        0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, // compressorname
        0x00, 0x18, // depth = 24
        0x11, 0x11 // pre_defined = -1
      ]), box(types.avcC, new Uint8Array([
        0x01, // configurationVersion
        track.profileIdc, // AVCProfileIndication
        track.profileCompatibility, // profile_compatibility
        track.levelIdc, // AVCLevelIndication
        0xff // lengthSizeMinusOne, hard-coded to 4 bytes
      ].concat([
        sps.length // numOfSequenceParameterSets
      ]).concat(sequenceParameterSets).concat([
        pps.length // numOfPictureParameterSets
      ]).concat(pictureParameterSets))));
    } else {
      return box(types.hvc1, new Uint8Array([
        0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, // reserved
        0x00, 0x01, // data_reference_index
        0x00, 0x00, // pre_defined
        0x00, 0x00, // reserved
        0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, // pre_defined
        (track.width & 0xff00) >> 8,
        track.width & 0xff, // width
        (track.height & 0xff00) >> 8,
        track.height & 0xff, // height
        0x00, 0x48, 0x00, 0x00, // horizresolution
        0x00, 0x48, 0x00, 0x00, // vertresolution
        0x00, 0x00, 0x00, 0x00, // reserved
        0x00, 0x01, // frame_count
        0x13,
        0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, // compressorname
        0x00, 0x18, // depth = 24
        0x11, 0x11 // pre_defined = -1
      ]), box(types.hvcC, new Uint8Array([
        0x01,
      ].concat(track.profileTierLevel).concat([
        0xF0, 0x00, 0xFC, 0xFD,
        0xF8, 0xF8, 0x00, 0x00,
        0x0F,
      ]).concat([
        vps.length + sps.length + pps.length
      ]).concat([
        0xA0, 0x00, vps.length // numOfVideoParameterSets
      ]).concat(videoParameterSets).concat([
        0xA1, 0x00, sps.length // numOfSequenceParameterSets
      ]).concat(sequenceParameterSets).concat([
        0xA2, 0x00, pps.length // numOfPictureParameterSets
      ]).concat(pictureParameterSets))));
    }
  };

  audioSample = function (track) {
    return box(types.mp4a, new Uint8Array([

      // SampleEntry, ISO/IEC 14496-12
      0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, // reserved
      0x00, 0x01, // data_reference_index

      // AudioSampleEntry, ISO/IEC 14496-12
      0x00, 0x00, 0x00, 0x00, // reserved
      0x00, 0x00, 0x00, 0x00, // reserved
      (track.channelcount & 0xff00) >> 8,
      (track.channelcount & 0xff), // channelcount

      (track.samplesize & 0xff00) >> 8,
      (track.samplesize & 0xff), // samplesize
      0x00, 0x00, // pre_defined
      0x00, 0x00, // reserved

      (track.samplerate & 0xff00) >> 8,
      (track.samplerate & 0xff),
      0x00, 0x00 // samplerate, 16.16

      // MP4AudioSampleEntry, ISO/IEC 14496-14
    ]), esds(track));
  };
}());

tkhd = function (track) {
  var result = new Uint8Array([
    0x00, // version 0
    0x00, 0x00, 0x01, // flags
    0x00, 0x00, 0x00, 0x00, // creation_time
    0x00, 0x00, 0x00, 0x00, // modification_time
    (track.id & 0xFF000000) >> 24,
    (track.id & 0xFF0000) >> 16,
    (track.id & 0xFF00) >> 8,
    track.id & 0xFF, // track_ID
    0x00, 0x00, 0x00, 0x00, // reserved
    0xFF, 0xFF, 0xFF, 0xFF, // duration
    // (track.duration & 0xFF000000) >> 24,
    // (track.duration & 0xFF0000) >> 16,
    // (track.duration & 0xFF00) >> 8,
    // track.duration & 0xFF, // duration
    0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, // reserved
    0x00, 0x00, // layer
    0x00, 0x00, // alternate_group
    0x01, 0x00, // non-audio track volume
    0x00, 0x00, // reserved
    0x00, 0x01, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00,
    0x00, 0x01, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00,
    0x40, 0x00, 0x00, 0x00, // transformation: unity matrix
    (track.width & 0xFF00) >> 8,
    track.width & 0xFF,
    0x00, 0x00, // width
    (track.height & 0xFF00) >> 8,
    track.height & 0xFF,
    0x00, 0x00 // height
  ]);

  return box(types.tkhd, result);
};

/**
 * Generate a track fragment (traf) box. A traf box collects metadata
 * about tracks in a movie fragment (moof) box.
 */
traf = function (track) {
  var trackFragmentHeader, trackFragmentDecodeTime,
    trackFragmentRun, sampleDependencyTable, dataOffset;

  trackFragmentHeader = box(types.tfhd, new Uint8Array([
    0x00, // version 0
    0x02, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x01
  ]));

  trackFragmentDecodeTime = box(types.tfdt, new Uint8Array([
    0x00, // version 0
    0x00, 0x00, 0x00, // flags
    // baseMediaDecodeTime
    (track.baseMediaDecodeTime >>> 24) & 0xFF,
    (track.baseMediaDecodeTime >>> 16) & 0xFF,
    (track.baseMediaDecodeTime >>> 8) & 0xFF,
    track.baseMediaDecodeTime & 0xFF
  ]));

  // the data offset specifies the number of bytes from the start of
  // the containing moof to the first payload byte of the associated
  // mdat
  dataOffset = (16 + //32 + // tfhd
    16 + // tfdt
    8 +  // traf header
    16 + // mfhd
    8 +  // moof header
    8);  // mdat header

  trackFragmentRun = trun(track,
                          /*sampleDependencyTable.length + */dataOffset);
  return box(types.traf,
    trackFragmentHeader,
    trackFragmentDecodeTime,
    trackFragmentRun
             /*sampleDependencyTable*/);
};

/**
 * Generate a track box.
 * @param track {object} a track definition
 * @return {Uint8Array} the track box
 */
trak = function (track) {
  track.duration = track.duration || 0x00000000;
  return box(types.trak,
    tkhd(track),
    mdia(track));
};

trex = function (track, sampleDuration) {
  var result = new Uint8Array([
    0x00, // version 0
    0x00, 0x00, 0x00, // flags
    (track.id & 0xFF000000) >> 24,
    (track.id & 0xFF0000) >> 16,
    (track.id & 0xFF00) >> 8,
    (track.id & 0xFF), // track_ID
    0x00, 0x00, 0x00, 0x01, // default_sample_description_index
    (sampleDuration & 0xFF000000) >> 24,
    (sampleDuration & 0xFF0000) >> 16,
    (sampleDuration & 0xFF00) >> 8,
    (sampleDuration & 0xFF), // track_ID
    0x00, 0x00, 0x00, 0x00, // default_sample_size
    0x00, 0x01, 0x00, 0x00 // default_sample_flags
  ]);
  // the last two bytes of default_sample_flags is the sample
  // degradation priority, a hint about the importance of this sample
  // relative to others. Lower the degradation priority for all sample
  // types other than video.
  if (track.type !== 'video') {
    result[result.length - 1] = 0x00;
  }

  return box(types.trex, result);
};

(function () {
  var audioTrun, videoTrun, trunHeader, trunHeader1;

  // This method assumes all samples are uniform. That is, if a
  // duration is present for the first sample, it will be present for
  // all subsequent samples.
  // see ISO/IEC 14496-12:2012, Section 8.8.8.1
  //trunHeader for not exiting frame ducation value
  trunHeader = function (samples, offset) {

    return [
      0x00, 0x00, // version 0
      0x02, 0x05, // flags
      (samples.length & 0xFF000000) >>> 24,
      (samples.length & 0xFF0000) >>> 16,
      (samples.length & 0xFF00) >>> 8,
      samples.length & 0xFF, // sample_count
      (offset & 0xFF000000) >>> 24,
      (offset & 0xFF0000) >>> 16,
      (offset & 0xFF00) >>> 8,
      offset & 0xFF, // data_offset
      0x00, 0x00, 0x00, 0x00
    ];
  };
  //trunHeader for existing frame duration value
  trunHeader1 = function (samples, offset) {
    return [
      0x00, 0x00, // version 0
      0x03, 0x05, // flags
      (samples.length & 0xFF000000) >>> 24,
      (samples.length & 0xFF0000) >>> 16,
      (samples.length & 0xFF00) >>> 8,
      samples.length & 0xFF, // sample_count
      (offset & 0xFF000000) >>> 24,
      (offset & 0xFF0000) >>> 16,
      (offset & 0xFF00) >>> 8,
      offset & 0xFF, // data_offset
      0x00, 0x00, 0x00, 0x00
    ];
  };

  videoTrun = function (track, offset) {
    var bytes, samples, sample, i;
    samples = track.samples || [];
    if (samples[0].frameDuration == null) {
      offset += 8 + 12 + 4 + (4 * samples.length); // size
      bytes = trunHeader(samples, offset);
      for (i = 0; i < samples.length; i++) {
        sample = samples[i];
        bytes = bytes.concat([
          (sample.size & 0xFF000000) >>> 24,
          (sample.size & 0xFF0000) >>> 16,
          (sample.size & 0xFF00) >>> 8,
          sample.size & 0xFF, // sample_size

        ]);
      }
    } else {
      offset += 8 + 12 + 4 + (4 * samples.length) + (4 * samples.length); //duration and size
      bytes = trunHeader1(samples, offset);
      for (i = 0; i < samples.length; i++) {
        sample = samples[i];
        bytes = bytes.concat([
          (sample.frameDuration & 0xFF000000) >>> 24,
          (sample.frameDuration & 0xFF0000) >>> 16,
          (sample.frameDuration & 0xFF00) >>> 8,
          sample.frameDuration & 0xFF, // sample_duration
          (sample.size & 0xFF000000) >>> 24,
          (sample.size & 0xFF0000) >>> 16,
          (sample.size & 0xFF00) >>> 8,
          sample.size & 0xFF, // sample_size

        ]);
      }

    }
    return box(types.trun, new Uint8Array(bytes));
  };

  audioTrun = function (track, offset) {
    var bytes, samples, sample, i;

    samples = track.samples || [];
    offset += 8 + 12 + (8 * samples.length);

    bytes = trunHeader(samples, offset);

    for (i = 0; i < samples.length; i++) {
      sample = samples[i];
      bytes = bytes.concat([
        (sample.duration & 0xFF000000) >>> 24,
        (sample.duration & 0xFF0000) >>> 16,
        (sample.duration & 0xFF00) >>> 8,
        sample.duration & 0xFF, // sample_duration
        (sample.size & 0xFF000000) >>> 24,
        (sample.size & 0xFF0000) >>> 16,
        (sample.size & 0xFF00) >>> 8,
        sample.size & 0xFF]); // sample_size
    }

    return box(types.trun, new Uint8Array(bytes));
  };

  trun = function (track, offset) {
    if (track.type === 'audio') {
      return audioTrun(track, offset);
    }

    return videoTrun(track, offset);
  };
}());

function initSegment(tracks) {
  var fileType = ftyp();
  var movie = moov(tracks);
  var result;

  result = new Uint8Array(fileType.byteLength + movie.byteLength);
  result.set(fileType);
  result.set(movie, fileType.byteLength);
  return result;
}

function mediaSegment(sequenceNumber, tracks, data, ept) {
  var moofBox = moof(sequenceNumber, tracks);
  var frameData = mdat(data);
  var result;

  result = new Uint8Array(moofBox.byteLength + frameData.byteLength);
  result.set(moofBox);
  result.set(frameData, moofBox.byteLength);

  return result;
}
/* Creates a new queue. A queue is a first-in-first-out (FIFO) data structure -
 * items are added to the end of the queue and removed from the front.
 */
function Queue(maxSize){
  var version = '1.0.0';
  var log = log4javascript.getLogger();
  var debug = true;

  var MAX_SIZE = Math.pow(2, 53) - 1;
  var maxSize = maxSize || MAX_SIZE;
  // initialise the queue and offset
  var queue  = [];
  var offset = 0;

  function Constructor() { }

  Constructor.prototype = {
  // Returns the length of the queue.
  getLength: function(){
    return (queue.length - offset);
  },
  // Returns true if the queue is empty, and false otherwise.
  isEmpty: function(){
    return (queue.length == 0);
  },
  // Returns true if the queue is full, and false otherwise.
  isFull: function(){
    return ((queue.length - offset) >= maxSize);
  },
  /* Enqueues the specified item. The parameter is:
   *
   * item - the item to enqueue
   */
  enqueue: function(item){
    if (this.isFull()) {
      throw new Error("Queue is full can't add new records");
    }

    queue.push(item);
  },
  /* Dequeues an item and returns it. If the queue is empty, the value
   * 'undefined' is returned.
   */
  dequeue: function(){
    if (this.isEmpty()) {
      throw new Error("Can't remove element from an empty Queue");
    }
    // store the item at the front of the queue
    var item = queue[offset];

    // increment the offset and remove the free space if necessary
    if (++ offset * 2 >= queue.length){
      queue  = queue.slice(offset);
      offset = 0;
    }

    // return the dequeued item
    return item;
  },
  /* Returns the item at the front of the queue (without dequeuing it). If the
   * queue is empty then undefined is returned.
   */
  peek: function () {
    return (queue.length > 0 ? queue[offset] : undefined);
  },
  print: function () {
    console.log("Queue Length: " + (queue.length - offset) + "\r\n");
    for (var i = offset; i < queue.length; i++) {
      console.log(queue[i]);
    }
  }
  };
  return new Constructor(maxSize);
}

//'use strict';

function error(message) {
  console.error(message);
  console.trace();
}

function assert(condition, message) {
  if (!condition) {
    error(message);
  }
}

function isPowerOfTwo(x) {
  return (x & (x - 1)) === 0;
}

/**
 * Joins a list of lines using a newline separator, not the fastest
 * thing in the world but good enough for initialization code.
 */
function text(lines) {
  return lines.join("\n");
}
/**
 * get element by attribute value
 * @param  {} attribute
 * @param  {} value
 * @param  {} element_type
 */
function getElementByAttributeValue(element_type, attribute, value)    {
  element_type = element_type || "*";
  var All = document.getElementsByTagName(element_type);
  for (var i = 0; i < All.length; i++)       {
    if (value !== undefined && All[i].getAttribute(attribute) == value) { return All[i]; }
  }
}

/**
 * Rounds up to the next highest power of two.
 */
function nextHighestPowerOfTwo(x) {
  --x;
  for (var i = 1; i < 32; i <<= 1) {
    x = x | x >> i;
  }
  return x + 1;
}

/**
 *  toHex().  Convert an ASCII string to hexadecimal.
 */
function toHex(decimal) {
  return "0x" + (decimal + 0x10000).toString(16).substr(-4).toUpperCase();
}

/**
 *  fromHex().  Convert a hex string to ascii text.
 */
function fromHex(hex) {
  return parseInt(hex, 16);
}
/**
 *  epochToJsDate().  Convert a epoch to Date.
 */
function epochToJsDate(ts){
  // ts = epoch timestamp
  // returns date obj
  return new Date(ts*1000);
}
/**
 *  jsDateToEpoch().  Convert a Date to epoch.
 */
function jsDateToEpoch(d){
  // d = javascript date obj
  // returns epoch timestamp
  return (d.getTime()-d.getMilliseconds())/1000;
}

/**
 * Define an Enum function for the base Object class
 */
Object.defineProperty(Object.prototype,'Enum', {
	value: function() {
		for(i in arguments) {
			Object.defineProperty(this,arguments[i], {
				value:parseInt(i),
				writable:false,
				enumerable:true,
				configurable:true
			});
		}
  },
  toString: function() {
    return this.value().name.toString();
  },
	writable:false,
	enumerable:false,
	configurable:false
});

/**
 * Define an YYYYMMDDHHMMSS function for the Date object
 */
Object.defineProperty(Date.prototype, 'YYYYMMDDHHMMSS', {
  value: function() {
      function pad2(n) {  // always returns a string
          return (n < 10 ? '0' : '') + n;
      }

      return this.getFullYear() +
             pad2(this.getMonth() + 1) +
             pad2(this.getDate()) +
             pad2(this.getHours()) +
             pad2(this.getMinutes()) +
             pad2(this.getSeconds());
  }
});

Object.defineProperty(Date.prototype, 'YYYYMMDDTHHMMSSZ', {
  value: function() {
      function pad2(n) {  // always returns a string
          return (n < 10 ? '0' : '') + n;
      }

      return this.getFullYear() +
             pad2(this.getMonth() + 1) +
             pad2(this.getDate()) +
             "T" +
             pad2(this.getHours()) +
             pad2(this.getMinutes()) +
             pad2(this.getSeconds()) +
             "Z";
  }
});


Object.defineProperty(Date.prototype, 'format', {
  value: function (f) {
    String.prototype.string = function (len) {
      var s = '',
        i = 0;
      while (i++ < len) {
        s += this;
      }
      return s;
    };
    String.prototype.zf = function (len) {
      return "0".string(len - this.length) + this;
    };
    Number.prototype.zf = function (len) {
      return this.toString().zf(len);
    };

    if (!this.valueOf()) return " ";

    var weekName = ["Sun.", "Mon", "Tue.", "Wed.", "Thu.", "Fri.", "Sat."];
    var d = this;

    return f.replace(/(yyyy|yy|MM|dd|E|hh|mm|ss|sss|a\/p)/gi, function ($1) {
      switch ($1) {
        case "yyyy":
          return d.getFullYear();
        case "yy":
          return (d.getFullYear() % 1000).zf(2);
        case "MM":
          return (d.getMonth() + 1).zf(2);
        case "dd":
          return d.getDate().zf(2);
        case "E":
          return weekName[d.getDay()];
        case "HH":
          return d.getHours().zf(2);
        case "hh":
          return ((h = d.getHours() % 12) ? h : 12).zf(2);
        case "mm":
          return d.getMinutes().zf(2);
        case "sss":
          return (d.getMilliseconds() % 1000).zf(3);
        case "ss":
          return d.getSeconds().zf(2);
        case "a/p":
          return d.getHours() < 12 ? "AM" : "PM";
        default:
          return $1;
      }
    });
  }
});

/**
 * Represents a 2-dimensional size value.
 */
function Size(width, height, viewWidth, viewHeight) {
  function Constructor(width, height, viewWidth, viewHeight) {
    if ( typeof viewWidth !== 'undefined') {
      Constructor.prototype.viewWidth = viewWidth;
    }
    if ( typeof viewHeight !== 'undefined') {
      Constructor.prototype.viewHeight = viewHeight;
    }
    Constructor.prototype.w = width;
    Constructor.prototype.h = height;
  }
  Constructor.prototype = {
    toString: function () {
      return "(" + Constructor.prototype.w + ", " + Constructor.prototype.h + ")";
    },
    getHalfSize: function () {
      return new Size(Constructor.prototype.w >>> 1, Constructor.prototype.h >>> 1);
    },
    length: function () {
      return Constructor.prototype.w * Constructor.prototype.h;
    }
  };
  return new Constructor(width, height, viewWidth, viewHeight);
}

/**
 * Creates a new prototype object derived from another objects prototype along with a list of additional properties.
 *
 * @param base object whose prototype to use as the created prototype object's prototype
 * @param properties additional properties to add to the created prototype object
 */
function inherit(base, properties) {
  var prot = Object.create(base.prototype);
  var keyList = Object.keys(properties);
  for (var i = 0; i < keyList.length; i++) {
    prot[keyList[i]] = properties[keyList[i]];
  }
  return prot;
}

function inheritObject(base, properties) {
  var keyList = Object.keys(properties);
  for (var i = 0; i < keyList.length; i++) {
    base[keyList[i]] = properties[keyList[i]];
  }
  return base;
}

function isApp() {
  var isApplication = false;
  if (document.URL.indexOf("http://") === -1 && document.URL.indexOf("https://") === -1) {
    isApplication = true;
  }
  return isApplication;
}

function BrowserDetect() {
  var agent = navigator.userAgent.toLowerCase(),
    name = navigator.appName,
    browser;

  if (name === 'Microsoft Internet Explorer' || agent.indexOf('trident') > -1 || agent.indexOf('edge/') > -1) {
    browser = 'ie';
    if (name === 'Microsoft Internet Explorer') { // IE old version (IE 10 or Lower)
      agent = /msie ([0-9]{1,}[\.0-9]{0,})/.exec(agent);
      browser += parseInt(agent[1]);
    } else { // IE 11+
      if (agent.indexOf('trident') > -1) { // IE 11 
        browser += 11;
      } else if (agent.indexOf('edge/') > -1) { // Edge
        browser = 'edge';
      }
    }
  } else if (agent.indexOf('safari') > -1) { // Chrome or Safari
    if (agent.indexOf('chrome') > -1) { // Chrome
      browser = 'chrome';
    } else { // Safari
      browser = 'safari';
    }
  } else if (agent.indexOf('firefox') > -1) { // Firefox
    browser = 'firefox';
  }

  return browser;
}

function doCapture(data, filename) {
  var link = document.createElement('a');
  var dataAtob = atob(data.substring("data:image/png;base64,".length));
  var asArray = new Uint8Array(dataAtob.length);

  for (var i = 0, len = dataAtob.length; i < len; ++i) {
    asArray[i] = dataAtob.charCodeAt(i);
  }

  var blob = new Blob([asArray.buffer], {
    type: "image/png"
  });
  saveAs(blob, filename + ".png");
}

var base64ArrayBuffer = function (buffer) {
  var byteString = '';
  var length = buffer.byteLength;
  for (var i = 0; i < length; i++) {
    byteString += String.fromCharCode(buffer[i]);
  }
  return btoa(byteString);
  // var base64 = '';
  // var encodings = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';

  // var bytes = new Uint8Array(arrayBuffer);
  // var byteLength = bytes.byteLength;
  // var byteRemainder = byteLength % 3;
  // var mainLength = byteLength - byteRemainder;

  // var a, b, c, d;
  // var chunk;

  // // Main loop deals with bytes in chunks of 3
  // for (var i = 0; i < mainLength; i = i + 3) {
  //   // Combine the three bytes into a single integer
  //   chunk = (bytes[i] << 16) | (bytes[i + 1] << 8) | bytes[i + 2];

  //   // Use bitmasks to extract 6-bit segments from the triplet
  //   a = (chunk & 16515072) >> 18; // 16515072 = (2^6 - 1) << 18
  //   b = (chunk & 258048) >> 12; // 258048   = (2^6 - 1) << 12
  //   c = (chunk & 4032) >> 6; // 4032     = (2^6 - 1) << 6
  //   d = chunk & 63; // 63       = 2^6 - 1

  //   // Convert the raw binary segments to the appropriate ASCII encoding
  //   base64 += encodings[a] + encodings[b] + encodings[c] + encodings[d];
  // }

  // // Deal with the remaining bytes and padding
  // if (byteRemainder == 1) {
  //   chunk = bytes[mainLength];

  //   a = (chunk & 252) >> 2; // 252 = (2^6 - 1) << 2

  //   // Set the 4 least significant bits to zero
  //   b = (chunk & 3) << 4; // 3   = 2^2 - 1

  //   base64 += encodings[a] + encodings[b] + '==';
  // } else if (byteRemainder == 2) {
  //   chunk = (bytes[mainLength] << 8) | bytes[mainLength + 1];

  //   a = (chunk & 64512) >> 10; // 64512 = (2^6 - 1) << 10
  //   b = (chunk & 1008) >> 4; // 1008  = (2^6 - 1) << 4

  //   // Set the 2 least significant bits to zero
  //   c = (chunk & 15) << 2; // 15    = 2^4 - 1

  //   base64 += encodings[a] + encodings[b] + encodings[c] + '=';
  // }

  // return base64;
};

function cloneArray(array) {
  var bs = array.BYTES_PER_ELEMENT,
    bo = array.byteOffset,
    n = array.length;
  return new array.constructor(array.buffer.slice(bo, bo + bs * n));
}

function BufferQueue() {
  this.first = null;
  this.size = 0;
}

function BufferNode(buffer) {
  this.buffer = buffer; //new Uint8Array(buffer.length);
  //    this.buffer.set(buffer, 0);
  this.previous = null;
  this.next = null;
}

BufferQueue.prototype.enqueue = function (buffer) {
  var node = new BufferNode(buffer);

  if (this.first == null) {
    this.first = node;
  } else {
    var n = this.first;
    while (n.next != null) {
      n = n.next;
    }
    n.next = node;
  }

  this.size += 1;
  return node;
};

BufferQueue.prototype.dequeue = function () {
  var temp = null;
  if (this.first != null) {
    temp = this.first;
    this.first = this.first.next;
    this.size -= 1;
  }

  return temp;
};

BufferQueue.prototype.clear = function () {
  console.log('BufferQueue clear!');
  var temp = null;
  while (this.first != null) {
    temp = this.first;
    this.first = this.first.next;
    this.size -= 1;
    temp.buffer = null;
    temp = null;
  }

  this.size = 0;
  this.first = null;
};

function BufferList() {
  this._length = 0;
  this.head = null;
  this.tail = null;
  this.curIdx = 0;
}

BufferList.prototype.getCurIdx = function () {
  return this.curIdx;
};

BufferList.prototype.push = function (buffer) {
  var node = new BufferNode(buffer);

  if (this._length > 0) {
    this.tail.next = node;
    node.previous = this.tail;
    this.tail = node;
  } else {
    this.head = node;
    this.tail = node;
  }
  this._length += 1;

  return node;
};

BufferList.prototype.pop = function () {
  var node = null;
  if (this._length > 1) {
    node = this.head;
    this.head = this.head.next;
    if (this.head != null) {
      this.head.previous = null;
      // 2nd use-case: there is no second node
    } else {
      this.tail = null;
    }
    this._length -= 1;
  }

  return node;
};

BufferList.prototype.pushPop = function (buffer) {
  var node = null;

  if (buffer != null) {
    node = new BufferNode(buffer);
    if (this._length > 0) {
      this.tail.next = node;
      node.previous = this.tail;
      this.tail = node;
    } else {
      this.head = node;
      this.tail = node;
    }
    this._length += 1;
  } else {
    if (this._length > 1) {
      node = this.head;
      this.head = this.head.next;
      if (this.head != null) {
        this.head.previous = null;
        // 2nd use-case: there is no second node
      } else {
        this.tail = null;
      }
      this._length -= 1;
    }
  }

  return node;
};

BufferList.prototype.searchNodeAt = function (position) {
  var currentNode = this.head,
    length = this._length,
    count = 1,
    message = {
      failure: 'Failure: non-existent node in this list.'
    };

  // 1st use-case: an invalid position
  if (length === 0 || position < 1 || position > length) {
    throw new Error(message.failure);
  }

  // 2nd use-case: a valid position
  while (count < position) {
    currentNode = currentNode.next;
    count++;
  }
  this.curIdx = count;

  console.log('searchNodeAt curIdx ' + this.curIdx + ' count ' + count + ' _length ' + this._length);

  return currentNode;
};

BufferList.prototype.clear = function () {
  console.log('BufferList clear!');
  var node = this.head;
  var nodeToDelete = null;

  while (node != null) {
    nodeToDelete = node;
    node = node.next;
    nodeToDelete.buffer = null;
    nodeToDelete = null;
  }

  this._length = 0;
  this.head = null;
  this.tail = null;
  this.curIdx = 0;
};

BufferList.prototype.remove = function (position) {
  var currentNode = this.head,
    length = this._length,
    count = 1,
    message = {
      failure: 'Failure: non-existent node in this list.'
    },
    beforeNodeToDelete = null,
    nodeToDelete = null,
    afterNodeToDelete = null,
    deletedNode = null;

  // 1st use-case: an invalid position
  if (length === 0 || position < 1 || position > length) {
    throw new Error(message.failure);
  }

  // 2nd use-case: the first node is removed
  if (position === 1) {
    this.head = currentNode.next;

    // 2nd use-case: there is a second node
    if (!this.head) {
      this.head.previous = null;
      // 2nd use-case: there is no second node
    } else {
      this.tail = null;
    }

    // 3rd use-case: the last node is removed
  } else if (position === this._length) {
    this.tail = this.tail.previous;
    this.tail.next = null;
    // 4th use-case: a middle node is removed
  } else {
    while (count < position) {
      currentNode = currentNode.next;
      count++;
    }

    beforeNodeToDelete = currentNode.previous;
    nodeToDelete = currentNode;
    afterNodeToDelete = currentNode.next;

    beforeNodeToDelete.next = afterNodeToDelete;
    afterNodeToDelete.previous = beforeNodeToDelete;
    deletedNode = nodeToDelete;
    nodeToDelete = null;
  }

  this._length--;

  return message.success;
};

BufferList.prototype.removeTillCurrent = function () {
  var currentNode,
    count = 1,
    message = {
      failure: 'Failure: non-existent node in this list.'
    };

  while (count < this.curIdx) {
    currentNode = this.pop();
    if (currentNode != null) {
      delete currentNode.buffer;
      currentNode.buffer = null;
      currentNode.previous = null;
      currentNode.next = null;
    }
    count++;
  }

  console.log('removeTillCurrent curIdx ' + this.curIdx + ' count ' + count + ' _length ' + this._length);
};

/**
 * Create a new object pool of a certain class
 */
var BufferPool = function (size) {
  // metrics for tracking internals
  this.metrics = {};
  this._clearMetrics();
  // [private] the objpool stack
  this._objpool = [];
  this.bufferSize = size;
};

/**
 * Allocate a new object from the pool
 * @return the object
 */
BufferPool.prototype.alloc = function alloc() {
  var obj;
  if (this._objpool.length == 0) {
    // nothing in the free list, so allocate a new object
    obj = new Uint8Array(this.bufferSize);
    this.metrics.totalalloc++;
  } else {
    // grab one from the top of the objpool
    obj = this._objpool.pop();
    this.metrics.totalfree--;
  }
  return obj;
};

/**
 * Return an object to the object pool
 */
BufferPool.prototype.free = function (obj) {
  var k;
  // fix up the free list pointers
  if (obj.length > 0)
    console.log('It is not zero length = ' + obj.length);
  else
    return;

  this._objpool.push(obj);
  this.metrics.totalfree++;
};

/**
 * Allow collection of all objects in the pool
 */
BufferPool.prototype.collect = function (cls) {
  // just forget the list and let the garbage collector reap them
  this._objpool = []; // fresh and new
  // but we might have allocated objects that are in use/not in
  // the pool--track them in the metrics:
  var inUse = this.metrics.totalalloc - this.metrics.totalfree;
  this._clearMetrics(inUse);
};

/**
 * [private] Clear internal metrics
 */
BufferPool.prototype._clearMetrics = function (allocated) {
  this.metrics.totalalloc = allocated || 0;
  this.metrics.totalfree = 0;
};

/**
 * Create a new image pool of a certain class
 */
var ImagePool = function () {
  // metrics for tracking internals
  this.metrics = {};
  this._clearMetrics();
  // [private] the objpool stack
  this._objpool = [];
};

/**
 * Allocate a new object from the pool
 * @return the object
 */
ImagePool.prototype.alloc = function alloc() {
  var obj;
  if (this._objpool.length == 0) {
    // nothing in the free list, so allocate a new object
    obj = new Image();
    this.metrics.totalalloc++;
  } else {
    // grab one from the top of the objpool
    obj = this._objpool.pop();
    this.metrics.totalfree--;
  }
  return obj;
};

/**
 * Return an object to the object pool
 */
ImagePool.prototype.free = function (obj) {
  var k;
  // fix up the free list pointers
  if (obj.length > 0)
    console.log('It is not zero length = ' + obj.length);
  else
    return;

  this._objpool.push(obj);
  this.metrics.totalfree++;
};

/**
 * Allow collection of all objects in the pool
 */
ImagePool.prototype.collect = function (cls) {
  // just forget the list and let the garbage collector reap them
  this._objpool = []; // fresh and new
  // but we might have allocated objects that are in use/not in
  // the pool--track them in the metrics:
  var inUse = this.metrics.totalalloc - this.metrics.totalfree;
  this._clearMetrics(inUse);
};

/**
 * [private] Clear internal metrics
 */
ImagePool.prototype._clearMetrics = function (allocated) {
  this.metrics.totalalloc = allocated || 0;
  this.metrics.totalfree = 0;
};
function videoDigitalPTZ() {
	var videoElement = null,
		zoom = 1,
		rotate = 0,
		downCheck = false,
    curX = 0,
    curY = 0,
    moveX = 0,
    moveY = 0,
    moveScale = 1,
    leftLimit = 0,
    topLimit = 0,
    browserType = BrowserDetect();

	var properties = ['transform', 'WebkitTransform', 'MozTransform',
	                  'msTransform', 'OTransform'],
	prop = properties[0];

	function Constructor() {}

	function eventHandler(event,eventType,element) {
		switch(eventType) {
			case "mousewheel":
        event.stopPropagation();
        event.preventDefault ();
        var delta = event.wheelDelta ? event.wheelDelta : -event.detail;
        delta = delta/120;
        if(delta > 0 && zoom < 16) {
        	zoom = zoom + 0.1;
        } else if (delta < 0 && zoom > 1) {
					zoom = zoom - 0.1;		
					var moveClac = (videoElement.clientWidth * 0.1) / 2;
					if (zoom != 1) {
						if (parseInt(videoElement.style.left,10) < 0) {
							videoElement.style.left = (parseInt(videoElement.style.left,10) + moveClac) + 'px';
						} else {
							videoElement.style.left = (parseInt(videoElement.style.left,10) - moveClac) + 'px';
						}

						if (parseInt(videoElement.style.top,10) < 0) {
							videoElement.style.top = (parseInt(videoElement.style.top,10) + moveClac) + 'px';
						} else {
							videoElement.style.top = (parseInt(videoElement.style.top,10) - moveClac) + 'px';
						}
					} else {
						videoElement.style.left = '0px';
						videoElement.style.top = '0px';
					}
        }

        leftLimit = parseInt(((videoElement.clientWidth * (zoom - 1)) / 2), 10);
        topLimit = parseInt(((videoElement.clientHeight * (zoom - 1)) / 2), 10);

        videoElement.style[prop] = 'scale('+zoom+') rotate('+rotate+'deg)';
				break;
			case "mousedown":
				downCheck = true;
        curX = event.clientX;
        curY = event.clientY;				
				break;
			case "mouseup":
			case "mouseleave":
				downCheck = false;
				break;
			case "mousemove":
				if(downCheck) {
	        moveX = curX - event.clientX;
	        moveY = curY - event.clientY;

	        curX = event.clientX;
	        curY = event.clientY;

					if (moveX < 0 ) { //left -> right
						if (parseInt(videoElement.style.left,10) < leftLimit)
							videoElement.style.left = (parseInt(videoElement.style.left,10) - moveX) + 'px';
						else if (parseInt(videoElement.style.left,10) != leftLimit)
							videoElement.style.left = leftLimit + 'px';
					} else if (moveX > 0) {	//right -> left
						if (parseInt(videoElement.style.left,10) > -leftLimit)
							videoElement.style.left = (parseInt(videoElement.style.left,10) - moveX) + 'px';
						else if (parseInt(videoElement.style.left,10) != -leftLimit)
							videoElement.style.left = -leftLimit + 'px';
					}

					if (moveY < 0 ) { //top -> bottom
						if (parseInt(videoElement.style.top,10) < parseInt(topLimit, 10))
							videoElement.style.top = (parseInt(videoElement.style.top,10) - moveY) + 'px';
						else if (parseInt(videoElement.style.top,10) != topLimit)
							videoElement.style.top = topLimit + 'px';
					} else if (moveY > 0) {	// bottom -> top
						if (parseInt(videoElement.style.top,10) > -topLimit)
							videoElement.style.top = (parseInt(videoElement.style.top,10) - moveY) + 'px';
						else if (parseInt(videoElement.style.top,10) != -topLimit)
							videoElement.style.top = -topLimit + 'px';
					}
				}
				break;
			default:
				break;
		}
	}

	function mouseWheel(event) { eventHandler(event,"mousewheel", null); }
	function mouseDown(event) { eventHandler(event,"mousedown", null); }
	function mouseUp(event) { eventHandler(event,"mouseup", null); }	
	function mouseMove(event) { eventHandler(event,"mousemove", null); }
	function mouseLeave(event) { eventHandler(event,"mouseleave", null); }

  function setElementEvent(element) {
  	if (browserType === "firefox") {
  		element.addEventListener('DOMMouseScroll', mouseWheel);
  	} else {
  		element.addEventListener('mousewheel', mouseWheel);
  	}
    element.addEventListener('mousedown', mouseDown);
    element.addEventListener('mousemove', mouseMove);
    element.addEventListener('mouseup', mouseUp);
    element.addEventListener('mouseleave', mouseLeave);
  }

	Constructor.prototype = {
		setVideoElement: function(elem) {
			videoElement = elem;
		  videoElement.style.left = 0;
		  videoElement.style.top = 0;
		  videoElement.style.position = 'relative';
			setElementEvent(videoElement);
		}
	};
	return new Constructor();
}
/* exported BackupProvider */
/* global FileMaker */
var fileMaker = null;
var callback = null;
/**
 * Processing received message from backupWorker
 * @function backupWorkerMessage
 * @param {Object} event 
 * @param {Object} event.data message data Object
 * @param {string} event.data.type command
 * @param {Object} event.data.data detail info for processing command
 * @param {string} event.data.data.target AVI header type
 * @param {Uint8Array[]} event.data.data.data AVI container
 * @param {Uint8Array[]} event.data.data.streamData frame packet
 */
function backupWorkerMessage(event) {
  "use strict";
  var message = event.data;
  switch (message.type) {
    case 'backup':
      if (fileMaker !== null) {
        fileMaker.processMessage(message.data.target, message.data.data);
      }
      break;
    case 'backupResult':
      if (typeof callback !== "undefined" && callback !== null) {
        callback(message.data);
      }
      break;
    case 'terminate':
      break;
  }
}

function BackupProvider() {
  var MAX_FPS = 60;
  var BACKUP_STATUS = {
    "WAIT": 0,
    "PROCESSING": 1,
    "DONE": 2
  };
  var backupStatus = BACKUP_STATUS.WAIT;
  var backupWorker = null;

  function Constructor() {}

  Constructor.prototype = {
    /**
     * Initialize BackuProvider
     * @function init
     * @memberof BackupProvider
     */
    init: function (backupCallback, _fileName) {
      backupStatus = BACKUP_STATUS.WAIT;
      backupWorker = new Worker('./media/ump/Worker/Backup/backupWorker.js');
      backupWorker.onmessage = backupWorkerMessage;
      callback = backupCallback;
      if (fileMaker === null) {
        fileMaker = new FileMaker();
      }
      var message = {
        'type': 'start',
        'data': {
          'fileName': typeof _fileName === 'undefined' ? '' : _fileName,
        },
      };
      backupWorker.postMessage(message);
    },
    /**
     * Processing with received video data.
     * @function onVideoData
     * @memberof BackupProvider
     * @instance
     * @param {object} streamData streamData object
     * @param {string} streamData.codecType "MJPEG", "H264", "H265"
     * @param {Uint8Array} streamData.frameData Depacketized frame data
     * @param {object} streamData.timeStamp Timestamp data object
     * @param {number} streamData.timeStamp.rtpTimeStamp RTP timeStamp
     * @param {number} streamData.timeStamp.timestamp Frame timestamp
     * @param {number} streamData.timeStamp.timestamp_usec Frame timestamp millisecond
     * @param {number} streamData.timeStamp.timezone timezone.
     * @param {object} videoInfo videoInfo object
     * @param {string} videoInfo.frameType "I" or "P"
     * @param {number} videoInfo.sps sps
     * @param {number} videoInfo.pps pps
     * @param {number} videoInfo.framerate frame rate
     * @param {string} codecInfo codecInfo for MediaSource
     */
    onVideoData: function (streamData, videoInfo, codecInfos) {
      if (backupStatus === BACKUP_STATUS.WAIT) {
        backupStatus = BACKUP_STATUS.PROCESSING;
      }
      if (backupStatus === BACKUP_STATUS.PROCESSING) {
        var frameInfo = {
          'type': 'video',
          'channelId': streamData.channelId,
          'frameType': videoInfo.frameType,
          'codectype': streamData.codecType,
          'PESsize': streamData.frameData.length,
          'framerate': typeof streamData.timeStamp.timestamp_usec !== 'undefined' ?
                      MAX_FPS :
                      videoInfo.framerate,
          'timestamp': streamData.timeStamp.timestamp === null ?
                      streamData.timeStamp.rtpTimestamp :
                      streamData.timeStamp.timestamp,
          'timestamp_usec': streamData.timeStamp.timestamp_usec,
          'width': videoInfo.width,
          'height': videoInfo.height,
        };
        var message = {
          'type': 'sendVideoFrame',
          'data': {
            'frameInfo': frameInfo,
            'streamData': streamData.frameData,
          },
        };
        backupWorker.postMessage(message);
      }
    },
    /**
     * Processing with received audio data.
     * @function receiveAudioData
     * @memberof BackupProvider
     * @instance
     * @param {object} streamData streamData object
     * @param {string} streamData.codecType "G711", "G726", "AAC"
     * @param {Uint8Array} streamData.frameData Depacketized audio data
     * @param {number} streamData.rtpTimeStamp RTP timeStamp
     * @param {object} audioInfo audioInfo
     * @param {number} audioInfo.bitrate bitrate
     */
    receiveAudioData: function (streamData, audioInfo) {
      if (backupStatus === BACKUP_STATUS.PROCESSING &&
        backupWorker !== null) {
        var frameInfo = {
          'type': 'audio',
          'channelId': streamData.channelId,
          'bitrate': audioInfo.bitrate,
          'codectype': streamData.codecType,
          'PESsize': streamData.frameData.length
        };
        var message = {
          'type': 'sendAudioFrame',
          'data': {
            'frameInfo': frameInfo,
            'streamData': streamData.frameData,
          },
        };
        backupWorker.postMessage(message);
      }
    },
    closeStream: function () {
      if (backupWorker !== null) {
        var endMessage = {
          'type': 'stop',
        };
        backupWorker.postMessage(endMessage);
        backupStatus = BACKUP_STATUS.WAIT;
        //close();
      }
    }
  };
  return new Constructor();
}
/* global MSBlobBuilder, saveAs */
var FileMaker = function () {
  'use strict';
  var header = null;
  var parts = null;
  var tails = null;
  var tailHeader = null;
  var blob = null;
  var mainBlobBuilder = null, bodyBlobBuilder = null, tailBlobBuilder = null;
  var supportBolbBuilder = null;

  function Constructor() {
    header = [];
    parts = [];
    tails = [];
    tailHeader = [];
    try {
      if (typeof MSBlobBuilder !== "undefined") {
        console.log("support blob builder");
        supportBolbBuilder = true;
        mainBlobBuilder = new MSBlobBuilder();
        bodyBlobBuilder = new MSBlobBuilder();
        tailBlobBuilder = new MSBlobBuilder();
      }
    } catch (err) {
      supportBolbBuilder = false;
    }
  }

  function addBody(part) {
    if (supportBolbBuilder) {
      bodyBlobBuilder.append(part);
    } else {
      parts.push(part);
    }
    blob = null;
  }

  function addMainHeader(_header) {
    header = _header;
  }

  function addTailHeader(header) {
    tailHeader = header;
  }

  function addTail(tail) {
    if (supportBolbBuilder) {
      tailBlobBuilder.append(tail);
    } else {
      tails.push(tail);
    }
  }

  function clearMemory() {
    header = null;
    tailHeader = null;
    parts = [];
    tails = [];
    blob = null;
  }

  function createAviFile(fileName) {
    if (blob === null) {
      if (supportBolbBuilder) {
        var bodyBlob = bodyBlobBuilder.getBlob();
        var tailBlob = tailBlobBuilder.getBlob();
        var bodyReader = new FileReader();
        var tailReader = new FileReader();
        bodyReader.readAsArrayBuffer(bodyBlob);
        bodyReader.onload = function () {
          mainBlobBuilder.append(header);
          mainBlobBuilder.append(this.result);
          tailReader.readAsArrayBuffer(tailBlob);
        };
        tailReader.onload = function () {
          mainBlobBuilder.append(tailHeader);
          mainBlobBuilder.append(this.result);
          window.navigator.msSaveOrOpenBlob(mainBlobBuilder.getBlob('application/octet-stream'), 
                                            fileName + '.avi');
          console.log("....................msSaveOrOpenBlob");
          bodyReader = null;
          tailReader = null;
          clearMemory();
        };
      } else {
        var whole = [];
        whole.push(header);
        var i=0;
        for (i = 0; i < parts.length; i++) {
          whole.push(parts[i]);
        }
        whole.push(tailHeader);
        for (i = 0; i < tails.length; i++) {
          whole.push(tails[i]);
        }
        blob = new Blob(whole, {
          type: "application/octet-stream",
        });
        saveAs(blob, fileName + '.avi');
        console.log("....................saveAs");
        whole = null;
        clearMemory();
      }
    }
  }
  Constructor.prototype = {
    processMessage: function (target, data) {
      if (target === "body") {
        addBody(data);
      } else if (target === "mainHeader") {
        addMainHeader(data);
      } else if (target === "tailHeader") {
        addTailHeader(data);
      } else if (target === "tailBody") {
        addTail(data);
      } else if (target === "save") {
        createAviFile(data);
      }
    },
  };
  return new Constructor();
};
"use strict";

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _wrapNativeSuper(Class) { var _cache = typeof Map === "function" ? new Map() : undefined; _wrapNativeSuper = function _wrapNativeSuper(Class) { if (Class === null || !_isNativeFunction(Class)) return Class; if (typeof Class !== "function") { throw new TypeError("Super expression must either be null or a function"); } if (typeof _cache !== "undefined") { if (_cache.has(Class)) return _cache.get(Class); _cache.set(Class, Wrapper); } function Wrapper() { return _construct(Class, arguments, _getPrototypeOf(this).constructor); } Wrapper.prototype = Object.create(Class.prototype, { constructor: { value: Wrapper, enumerable: false, writable: true, configurable: true } }); return _setPrototypeOf(Wrapper, Class); }; return _wrapNativeSuper(Class); }

function isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _construct(Parent, args, Class) { if (isNativeReflectConstruct()) { _construct = Reflect.construct; } else { _construct = function _construct(Parent, args, Class) { var a = [null]; a.push.apply(a, args); var Constructor = Function.bind.apply(Parent, a); var instance = new Constructor(); if (Class) _setPrototypeOf(instance, Class.prototype); return instance; }; } return _construct.apply(null, arguments); }

function _isNativeFunction(fn) { return Function.toString.call(fn).indexOf("[native code]") !== -1; }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

// reference:
// https://blog.teamtreehouse.com/create-custom-html-elements-2
// https://codepen.io/matt-west/pen/FtmBL
// https://github.com/shawnbot/custom-elements
// https://github.com/WebReflection/document-register-element/issues/21
// https://stackoverflow.com/questions/29240850/can-life-cycle-callbacks-in-an-html5-custom-element-be-defined-after-registratio
// https://www.smashingmagazine.com/2014/03/introduction-to-custom-elements/
var LOG_TAG = 'ump-player';
var umpplayer_version = '1.0.0';
var umpplayer_log = log4javascript.getLogger(LOG_TAG);
var UmpPlayType = {};
UmpPlayType.Enum('LIVE', // 0
'PLAYBACK', // 1
'BACKUP' // 2
);
var UmpPlayState = {};
UmpPlayState.Enum('STOPPED', // 0
'PLAYING', // 1
'PAUSED', // 2
'STEP' // 2
);
var UmpPlaySpeed = {
  speed_0_25x: {
    value: 0.25,
    name: '0.25x'
  },
  speed_0_50x: {
    value: 0.50,
    name: '0.50x'
  },
  speed_0_75x: {
    value: 0.75,
    name: '0.75x'
  },
  speed_1x: {
    value: 1,
    name: '1x'
  },
  speed_2x: {
    value: 2,
    name: '2x'
  },
  speed_4x: {
    value: 4,
    name: '4x'
  },
  speed_8x: {
    value: 8,
    name: '8x'
  },
  speed_16x: {
    value: 16,
    name: '16x'
  },
  speed_32x: {
    value: 32,
    name: '32x'
  },
  speed_64x: {
    value: 64,
    name: '64x'
  },
  seek_0_25x: {
    value: -0.25,
    name: '-0.25x'
  },
  seek_0_50x: {
    value: -0.50,
    name: '-0.50x'
  },
  seek_0_75x: {
    value: -0.75,
    name: '-0.75x'
  },
  seek_1x: {
    value: -1,
    name: '-1x'
  },
  seek_2x: {
    value: -2,
    name: '-2x'
  },
  seek_4x: {
    value: -4,
    name: '-4x'
  },
  seek_8x: {
    value: -8,
    name: '-8x'
  },
  seek_16x: {
    value: -16,
    name: '-16x'
  },
  seek_32x: {
    value: -32,
    name: '-32x'
  },
  seek_64x: {
    value: -64,
    name: '-64x'
  }
};
/**
 * definition of play type for ump player
 * @typedef {Object} UmpPlayType
 * @property {String} live - live mode
 * @property {String} playvack - playback mode
 * @description definition of play type for ump player
 * @example
 *    var element = document.getElementsByTagName("ump-player");
 *    element.mode = 'live';
 *    element.mode = 'playback';
 */

/**
* definition of play state for ump player
* @typedef {Object} UmpPlayState
* @property {String} STOPPED - stopped state
* @property {String} PLAYING - playing state
* @property {String} PAUSED - pause state
* @property {String} STEP - step play state
* @description definition of play state for ump player
* @example
*    var element = document.getElementsByTagName("ump-player");
*    console.log(element.readyState)
*/

/**
* definition of playback speed for ump player
* @typedef {Object} UmpPlaySpeed
* @property {Number} 0.25 - forward speed 0.25x
* @property {Number} 0.5 - forward speed 0.5x
* @property {Number} 0.75 - forward speed 0.7 5x
* @property {Number} 1 - forward speed 1x
* @property {Number} 2 - forward speed 2x
* @property {Number} 4 - forward speed 4x
* @property {Number} 8 - forward speed 8x
* @property {Number} 16 - forward speed 1 6x
* @property {Number} 32 - forward speed 32x
* @property {Number} 64 - forward speed 64x
* @property {Number} -0.25 - backward speed 0.25x
* @property {Number} -0.5 - backward speed 0.5x
* @property {Number} -0.75 - backward speed 0.75x
* @property {Number} -1 - backward speed 1x
* @property {Number} -2 - backward speed 2x
* @property {Number} -4 - backward speed 4x
* @property {Number} -8 - backward speed 8x
* @property {Number} -16 - backward speed 16x
* @property {Number} -32 - backward speed 32x
* @property {Number} -64 - backward speed 64x
* @description definition of playback speed for ump player
* @example
*    var element = document.getElementsByTagName("ump-player");
*    element.playSpeed = 2;
*    console.log(element.playSpeed)
*/

/**
 * <pre>
 * class UMP Custom Player.
 * This class definition attrubuties and method for UMP Custom player.
 * UMP Custom Player comes from custom elements function for W3C Custom Elements from
 * https://www.w3.org/TR/custom-elements
 * This class support only ES6 code standard. If you want to support IE11, you have to build to ES5 using babel.
 * </pre>
 * @class UmpPlayer
 * @classdesc UMP Custom Elements
 * @param  {String} hostname Camera or NVR host ip or hostname [hostname="192.168.0.1"]
 * @param {Number} port number of port on device web server [port="8080"]
 * @param {String} username user name of device [username="admin"]
 * @param {String} password user password of device [password="password"]
 * @param {String} device type of device [device="camera"]
 * @param {String} profile profile name for camera [profile="H.264"]
 * @param {Number} profile_number number of profile [profile_number="1"]
 * @param {Number} channel number of channel [channel="1"]
 * @param {Number} width number of width [width="1024"]
 * @param {Number} height number of height [height="768"]
 * @param {UmpPlayType} mode number of play mode [mode="playback"]
 * @param {String} proxy RTSP proxy server address [proxy="192.168.1.1"]
 * @param {boolean} secure secure mode [secure]
 * @param {boolean} iframe play iframe only [iframe]
 * @param {boolean} constrols display control user interface [controls]
 * @param {boolean} autoplay auto play flags [autoplay]
 * @property {String} sessionKey session key for multi channel access on NVR devices
 * @property {Object} sunapiClient sunapi client for video play without user password
 * @property {UmpPlayState} readyState The type of play state property. If play state changed, you can check state on live or playback<br>
 *                                              UmpPlayState.STOPPED: stop state<br>
 *                                              UmpPlayState.PLAYING: play state<br>
 *                                              UmpPlayState.PAUSED: pause state
 * @property {UmpPlayType} playType  The type of playmode property. If you change playmode, thi value set to live or playback<br>
 *                                            UmpPlayType.LIVE: live mode<br>
 *                                            UmpPlayType.PLAYBACK: playback mode
 * @property {String} startTime start time for playback. This is ISO type date string without millisecond like YYYY-MM-DDThh:mm:ssZ.
 * @property {String} endTime end time properties. This is ISO type date string without millisecond like YYYY-MM-DDThh:mm:ssZ.
 * @property {String} overlappedId Overlapped Id for playback function on NVR devices
 * @property {UmpPlaySpeed} playSpeed The property of play speed on playback. This property will be change speed automatically. Do not call speed method.
 * @example <caption>default Camera play example.</caption>
 *  <ump-player id="ump-player1" hostname="192.168.0.1" profile="H.264"  device="camera" width="320" height="240" username="username" password="password"></ump-player>
 * <script>
 *     function play() {
 *     // play media
 *     var elements = document.getElementsByTagName("ump-player");
 *     if (elements !== undefined) {
 *      for (i = 0; i < elements.length; i++) {
 *        elements[i].play();
 *      }
 *    }
 *  }
 * </script>
 * @example <caption>default NVR play example.</caption>
 *  <ump-player id="ump-player1" hostname="192.168.0.1" profile_number="2"  channel="1" device="nvr" width="320" height="240"  username="username" password="password"></ump-player>
 * <script>
 *     function play() {
 *     // play media
 *     var elements = document.getElementsByTagName("ump-player");
 *     if (elements !== undefined) {
 *      for (i = 0; i < elements.length; i++) {
 *        elements[i].play();
 *      }
 *    }
 *  }
 * </script>
 *
 */

var UmpPlayer =
/*#__PURE__*/
function (_HTMLElement) {
  _inherits(UmpPlayer, _HTMLElement);

  /**
   * @description UMP Custom Player constructor
   * @constructor UmpPlayer
   */
  function UmpPlayer() {
    var _this;

    _classCallCheck(this, UmpPlayer);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(UmpPlayer).call(this));
    umpplayer_log.info("[ump-player] version: ", _this.version()); //    var shadow = this.attachShadow({mode: 'open'});
    //this.innerText = '<canvas>';
    // attributes variable

    _this._hostname = null;
    _this._channel = null;
    _this._profile = null;
    _this._profile_number = null;
    _this._deviceType = null;
    _this._username = null;
    _this._password = null;
    _this._iframe = false;
    _this._controls = false;
    _this._multicast = false;
    _this._width = 0;
    _this._height = 0;
    _this._background = 'black';
    _this._readyState = UmpPlayState.STOPPED;
    _this._currentTimestamp = null;
    _this._sessionKey = null;
    _this._source = null;
    _this._autoplay = null;
    _this._proxy = null;
    _this._port = null;
    _this._secure = false;
    _this._useIso = null;
    _this.timezone_offset = null;
    _this._filename = null;
    _this._sunapiMng = new sunapiManager(); // default play type is live.

    _this._playType = null;
    _this._playSpeed = UmpPlaySpeed.speed_1x; // add event listener

    _this.listeners = new Map(); // bind this objec to callback function
    // this.onUmpClose = this.onUmpClose.bind(this);
    // this.onUmpError = this.onUmpError.bind(this);
    // this.onUmpStatus = this.onUmpStatus.bind(this);
    // this.onUmpTimestamp  = this.onUmpTimestamp.bind(this);
    // this.onUmpResize = this.onUmpResize.bind(this);
    // this.onUmpMeta = this.onUmpMeta.bind(this);
    // this.onUmpVideoMode = this.onUmpVideoMode.bind(this);
    // this.onUmpStatistics = this.onUmpStatistics.bind(this);
    // this.onUmpStep = this.onUmpStep.bind(this);
    // this.onUmpCapture = this.onUmpCapture.bind(this);
    // initialize callback, device information, media request

    _this.info = {
      callback: {
        close: _this.onUmpClose.bind(_assertThisInitialized(_assertThisInitialized(_this))),
        error: _this.onUmpError.bind(_assertThisInitialized(_assertThisInitialized(_this))),
        status: _this.onUmpStatus.bind(_assertThisInitialized(_assertThisInitialized(_this))),
        time: _this.onUmpTimestamp.bind(_assertThisInitialized(_assertThisInitialized(_this))),
        resize: _this.onUmpResize.bind(_assertThisInitialized(_assertThisInitialized(_this))),
        meta: _this.onUmpMeta.bind(_assertThisInitialized(_assertThisInitialized(_this))),
        vmode: _this.onUmpVideoMode.bind(_assertThisInitialized(_assertThisInitialized(_this))),
        statistics: _this.onUmpStatistics.bind(_assertThisInitialized(_assertThisInitialized(_this))),
        step: _this.onUmpStep.bind(_assertThisInitialized(_assertThisInitialized(_this))),
        capture: _this.onUmpCapture.bind(_assertThisInitialized(_assertThisInitialized(_this))),
        backup: _this.onUmpBackup.bind(_assertThisInitialized(_assertThisInitialized(_this)))
      },
      device: {
        ClientIPAddress: '127.0.0.1',
        hostname: '',
        cameraIp: '',
        port: 80,
        captureName: '',
        protocol: '',
        username: '',
        password: '',
        deviceType: '',
        debug: false,
        async: false,
        channelId: 0,
        proxy: ''
      },
      media: {
        audioOutStatus: false,
        framerate: 30,
        govLength: 60,
        instantPlaybackTime: 30,
        bufferClearInterval: 1,
        needToImmediate: false,
        boxsize: 4,
        mode: null,
        requestInfo: {
          cmd: 'open',
          scale: 1,
          url: null
        },
        transportType: 'rtsp',
        type: 'live'
      }
    };
    _this.player = null;
    _this.backupplayer = null;
    _this.video = document.createElement('canvas');
    return _this;
  }

  _createClass(UmpPlayer, [{
    key: "version",
    value: function version() {
      return umpplayer_version;
    }
  }, {
    key: "attributeChangedCallback",
    value: function attributeChangedCallback(name, oldValue, newValue) {
      // name will always be "country" due to observedAttributes
      if (name === 'autoplay') {
        this._autoplay = true;
      }

      if (name === 'hostname') {
        this._hostname = newValue;
        this.info.device.cameraIp = this._hostname;
        this.info.device.hostname = this._hostname;
      }

      if (name === 'channel') {
        this._channel = newValue;
      }

      if (name === 'profile') {
        this._profile = newValue;
      }

      if (name === 'profile_number') {
        this._profile_number = newValue;
      }

      if (name === 'device') {
        this._deviceType = newValue;
        this.info.device.deviceType = this._deviceType;
      }

      if (name === 'username') {
        this._username = newValue;
        this.info.device.user = this._username;
        this.info.device.username = this._username;
      }

      if (name === 'password') {
        this._password = newValue;
        this.info.device.password = this._password;
      }

      if (name === 'iframe') {
        this._iframe = true;
      }

      if (name === 'controls') {
        this._controls = true;
      }

      if (name === 'multicast') {
        this._multicast = true;
      }

      if (name === 'width') {
        this._width = newValue;
      }

      if (name === 'height') {
        this._height = newValue;
      }

      if (name === 'mode') {
        this.mode = newValue;
      }

      if (name === 'proxy') {
        this._proxy = newValue;
      }

      if (name === 'port') {
        this._port = newValue;
      }

      if (name === 'secure') {
        this._secure = true;
      } //this._updateSunapiManager();
      //    this._updateRendering();

    }
  }, {
    key: "connectedCallback",
    value: function connectedCallback() {
      if (this.getAttribute('autoplay') !== null && this.getAttribute('autoplay') !== undefined) {
        this._autoplay = true;
      }

      if (this.getAttribute('device') !== null && this.getAttribute('device') !== undefined) {
        this.info.device.deviceType = this.getAttribute('device');
      } else {
        this.info.device.deviceType = 'camera';
      }

      if (this.info.device.deviceType === 'camera') {
        if (this.getAttribute('hostname') !== null && this.getAttribute('hostname') !== undefined) {
          this.info.device.cameraIp = this.getAttribute('hostname');
        } else {
          this.info.device.cameraIp = document.location.hostname;
        }
      } else {
        if (this.getAttribute('hostname') !== null && this.getAttribute('hostname') !== undefined) {
          this.info.device.hostname = this.getAttribute('hostname');
        } else {
          this.info.device.hostname = document.location.hostname;
        }
      }

      if (this.getAttribute('username') !== null && this.getAttribute('username') !== undefined) {
        this.info.device.username = this.getAttribute('username');
      }

      if (this.getAttribute('password') !== null && this.getAttribute('password') !== undefined) {
        this.info.device.password = this.getAttribute('password');
      }

      if (this.getAttribute('profile') !== null && this.getAttribute('profile') !== undefined) {
        this._profile = this.getAttribute('profile');
      }

      if (this.getAttribute('profile_number') !== null && this.getAttribute('profile_number') !== undefined) {
        this._profile_number = this.getAttribute('profile_number');
      }

      if (this.getAttribute('controls') !== null && this.getAttribute('controls') !== undefined) {
        this._controls = true;
      }

      if (this.getAttribute('multicast') !== null && this.getAttribute('multicast') !== undefined) {
        this._multicast = true;
      }

      if (this.getAttribute('iframe') !== null && this.getAttribute('iframe') !== undefined) {
        this._iframe = true;
      }

      if (this.getAttribute('secure') !== null && this.getAttribute('secure') !== undefined) {
        this._secure = true;
      }

      if (this.getAttribute('proxy') !== null && this.getAttribute('proxy') !== undefined) {
        this._proxy = this.getAttribute('proxy');
      }

      if (this.getAttribute('port') !== null && this.getAttribute('port') !== undefined) {
        this._port = this.getAttribute('port');
      }

      if (this.getAttribute('channel') === null || this.getAttribute('channel') === undefined) {
        this.video.id = "live" + this.info.media.mode + "1";
        this.info.device.channelId = 0;
      } else {
        this.info.device.channelId = Number(this.getAttribute('channel')) - 1;
      }

      this.video.setAttribute('kind-channel-id', this.info.device.channelId);

      if (this.getAttribute('width') !== null || this.getAttribute('width') !== undefined) {
        this.video.width = this.getAttribute('width');
      }

      if (this.getAttribute('height') !== null || this.getAttribute('height') !== undefined) {
        this.video.height = this.getAttribute('height');
      }

      if (this.getAttribute('id') !== null || this.getAttribute('id') !== undefined) {
        this.video.id = "live-" + this.getAttribute('id');
        this.video.setAttribute('kind-channel-mapped-id', this.getAttribute('id'));
        this.info.media.element = this.getAttribute('id');
      }

      if (this.getAttribute('mode') !== null && this.getAttribute('mode') !== undefined) {
        if (this.getAttribute('mode') === 'live') {
          this._playType = UmpPlayType.LIVE;
        } else if (this.getAttribute('mode') === 'playback') {
          this._playType = UmpPlayType.PLAYBACK;
        } else {
          throw new umpError({
            channelId: this.channel,
            elementId: this.getAttribute('id'),
            errorCode: fromHex('0x0412'),
            place: 'ump-player.js:364',
            message: "play mode is not defined. please! check your mode attribute on your ump-player element."
          });
        }
      }

      if (this._controls === true) {
        this.video.controls = true;
      }

      this.video.style = 'background:' + this._background + ';';

      if (this.info.media.element !== null && this.info.media.element !== null) {
        this._updateSunapiManager();

        this._updateRendering();
      }
    } // properties variable

    /**
     * Type of play mode. live or palyback.
     * @property {String} playType Type of play mode.
     * @type {String}
     * @description The type of playmode property. If you change playmode, thi value set to live or playback<br>
     * @example
     *                  var element = document.getElementsById("ump-player");
     *                  element.playType = UmpPlayType.LIVE;
     *                  element.playType = UmpPlayType.PLAYBACK;
     *                  element.playType = UmpPlayType.BACKUP;
     */

  }, {
    key: "_updateSunapiManager",
    value: function _updateSunapiManager() {
      if (this._hostname !== null && this._hostname !== undefined && this._username !== null && this._username !== undefined && this._password !== null && this._password !== undefined && this._deviceType !== null && this._deviceType !== undefined) {
        this.info.device.cameraIp = this._hostname;
        this.info.device.hostname = this._hostname;
        this.info.device.user = this._username;
        this.info.device.username = this._username;
        this.info.device.password = this._password;
        this.info.device.deviceType = this._deviceType;

        this._sunapiMng.init(this.info.device);
      }
    }
  }, {
    key: "_updateRendering",
    value: function _updateRendering() {
      // Left as an exercise for the reader. But, you'll probably want to
      // check this.ownerDocument.defaultView to see if we've been
      // inserted into a document with a browsing context, and avoid
      // doing any work if not.
      //console.log("update rendering");
      this.classList.add("ump-player");

      if (this._playType === UmpPlayType.LIVE && this._deviceType === 'nvr') {
        var self = this;

        if (this._sunapiMng.getSunapiClient() !== null && this._sunapiMng.getSunapiClient() !== undefined) {
          var channel;

          if (this._deviceType === 'camera') {
            if (this._channel === null) {
              channel = 0;
            } else {
              channel = this._channel - 1;
            }
          } else if (this._deviceType === 'nvr') {
            //if(this._channel === 0) channel = 0;
            //else channel = this._channel - 1;
            channel = this._channel - 1;
          }

          var promise = this._sunapiMng.getSnapshot(1, channel);

          promise.then(function (thumbnail) {
            if (typeof thumbnail !== 'undefined') {
              try {
                console.log(thumbnail);
                var urlCreator = window.URL || window.webkitURL;
                var imageUrl = urlCreator.createObjectURL(thumbnail.data); //               document.querySelector("#image").src = imageUrl;

                var snapshotElement = document.createElement('img');
                snapshotElement.setAttribute('id', 'snapshot');
                snapshotElement.setAttribute('src', imageUrl);
                snapshotElement.setAttribute('width', self._width);
                snapshotElement.setAttribute('height', self._height);
                snapshotElement.classList.add('absolute');
                self.video.classList.add('absolute');
                self.appendChild(snapshotElement);
              } catch (error) {
                console.error("error: ", error.message);
              }
            }
          }).catch(function (error) {
            if (Number.isInteger(error)) {
              //            console.error('Http request error: ' + HTTP_STATUS_CODES[error]);
              event = new CustomEvent('error', {
                bubbles: true,
                detail: {
                  channelId: error.channelId,
                  elementId: self.getAttribute('id'),
                  error: fromHex('0x1002'),
                  message: "HTTP request error: " + HTTP_STATUS_CODES[error],
                  place: 'ump-player.js:89-'
                }
              }); // dispatch event to application

              self.dispatchEvent(event);
            } else {
              console.error("deviceInfo error: ", error.message);
            }
          });
        }
      }

      this.appendChild(this.video);

      if (this._sunapiMng.getSunapiClient() !== null && this._sunapiMng.getSunapiClient() !== undefined) {
        if (this._autoplay === true && (this._profile !== null && this._profile !== undefined || this.profile_number !== null && this._profile_number) && this._deviceType !== null && this._deviceType !== undefined) {
          if (this._deviceType === 'nvr') {
            if (this._channel !== null && this._channel !== undefined) {
              this.play();
            }
          } else {
            this.play();
          }
        }
      }
    }
    /**
     * Add Event Listener for ump-player
     * @memberof UmpPlayer
     * @param  {number} event.channelId channel id of error event
     * @param  {number} event.errorCode error code of error event
     * @param  {string} event.oldErrorCode old error code of error event for old ump module
     * @param  {string} event.currentState if this event happened from rtps client, return current rtsp state
     * @param  {number} event.rtspCode if this event happened from rtsp client, return rtps status code
     * @param  {number} event.description error description
       * @param {string} type Event listener type {error, meta, close, statechange, timestamp, capture, changeplayermode}
     *                                 error: event listener when error occured
     *                                 meta: event listener when meta data occured
     *                                 close: event listener when connection closed
     *                                 resize: event listener when image resized
     *                                 statechange: event listener when state change on play
     *                                 timestamp: event listener when timestamp value on playback mode
     *                                 capture: event listener when image captured data
     *                                 changeplayermode: event listener when player mode changed
     * @param {*} listener Event listener method
     * @example
     *       var element = document.getElementById("ump-player");
     *
     *      element.addEventListener('error', function(evt) { console.log('error event:', JSON.stringfy(evt.detail));} );
     *      element.addEventListener('meta', function(evt) { console.log('meta event:', JSON.stringfy(evt.detail));} );
     *      element.addEventListener('close', function(evt) { console.log('close event:', JSON.stringfy(evt.detail));} );
     *      element.addEventListener('resize', function(evt) { console.log('resize event:', JSON.stringfy(evt.detail));} );
     *      element.addEventListener('statechange', function(evt) { console.log('state change event:', JSON.stringfy(evt.detail));} );
     *      element.addEventListener('timestamp', function(evt) { console.log('time stamp event:', JSON.stringfy(evt.detail));} );
     *      element.addEventListener('capture', function(evt) { console.log('capture event:', JSON.stringfy(evt.detail));} );
     *      element.addEventListener('changeplayermode', function(evt) { console.log('change player mode event:', JSON.stringfy(evt.detail));} );
     *      element.addEventListener('backupstate', function(evt) { console.log('change backup state event:', JSON.stringfy(evt.detail));} );
     */

  }, {
    key: "addEventListener",
    value: function addEventListener(type, listener) {
      this.listeners.set(listener.bind(this), {
        type: type,
        listener: listener
      });
    }
  }, {
    key: "removeEventListener",
    value: function removeEventListener(type, listener) {
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = this.listeners[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var _step$value = _slicedToArray(_step.value, 2),
              key = _step$value[0],
              value = _step$value[1];

          if (value.type !== type || listener !== value.listener) {
            continue;
          }

          this.listeners.delete(key);
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return != null) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }
    }
  }, {
    key: "dispatchEvent",
    value: function dispatchEvent(event) {
      Object.defineProperty(event, 'target', {
        value: this
      });
      this['on' + event.type] && this['on' + event.type](event);
      var _iteratorNormalCompletion2 = true;
      var _didIteratorError2 = false;
      var _iteratorError2 = undefined;

      try {
        for (var _iterator2 = this.listeners[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
          var _step2$value = _slicedToArray(_step2.value, 2),
              key = _step2$value[0],
              value = _step2$value[1];

          if (value.type !== event.type) {
            continue;
          }

          key(event);
        }
      } catch (err) {
        _didIteratorError2 = true;
        _iteratorError2 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion2 && _iterator2.return != null) {
            _iterator2.return();
          }
        } finally {
          if (_didIteratorError2) {
            throw _iteratorError2;
          }
        }
      }
    }
    /**
     * ump player video mode chaned event from ump module
     * @param  {number} event.channelId channel id of error event {default 0}
     * @param  {string} event.elementId element id of DOM object
     * @param  {string} event.mode video mode {video or canvas}
     */

  }, {
    key: "onUmpVideoMode",
    value: function onUmpVideoMode(event) {
      umpplayer_log.debug("onUmpVideoMode", event);
      var oldVideoElement, tagid, umpPlayer;
      tagid = "live-" + event.elementId;
      oldVideoElement = document.getElementById(tagid);
      var classList;

      if (oldVideoElement !== null && oldVideoElement !== undefined) {
        umpPlayer = oldVideoElement.parentElement;
        var width = oldVideoElement.getAttribute('width');
        var height = oldVideoElement.getAttribute('height');
        var kindChannelid = oldVideoElement.getAttribute('kind-channel-id');
        var mappedId = oldVideoElement.getAttribute('kind-channel-mapped-id');
        var styleText = oldVideoElement.getAttribute('style');

        if (this._playType === UmpPlayType.LIVE) {
          classList = oldVideoElement.classList;
        }

        oldVideoElement.remove();
        var newVideoElement = document.createElement(event.mode);

        if (umpPlayer.controls !== undefined && umpPlayer.controls !== null) {
          newVideoElement.controls = true;
        }

        newVideoElement.setAttribute('id', tagid);
        newVideoElement.setAttribute('width', width);
        newVideoElement.setAttribute('height', height);
        newVideoElement.setAttribute('kind-channel-id', kindChannelid);
        newVideoElement.setAttribute("kind-channel-mapped-id", mappedId);
        newVideoElement.setAttribute("style", styleText);

        if (this._playType === UmpPlayType.LIVE) {
          newVideoElement.setAttribute("class", classList);
        }

        umpPlayer.appendChild(newVideoElement);
      } // generate meta custom event


      var event_data = new CustomEvent('changeplayermode', {
        bubbles: true,
        detail: {
          elementId: this.getAttribute('id'),
          mode: event.mode
        }
      }); // dispatch event to application

      this.dispatchEvent(event_data);
    }
    /**
     * ump player close callback function from ump module
     * @param  {number} event.channelId channel id of error event
     */

  }, {
    key: "onUmpClose",
    value: function onUmpClose(event) {
      umpplayer_log.debug("onUmpClose: ", JSON.stringify(event));
    }
    /**
     * ump player error callback function from ump module
     * @memberof UmpPlayer
     * @callback onUmpError
     * @param  {number} event.channelId channel id of error event
     * @param  {number} event.errorCode error code of error event
     * @param  {string} event.oldErrorCode old error code of error event for old ump module
     * @param  {string} event.currentState if this event happened from rtps client, return current rtsp state
     * @param  {number} event.rtspCode if this event happened from rtsp client, return rtps status code
     * @param  {number} event.description error description
     * @throws {umpError}
     */

  }, {
    key: "onUmpError",
    value: function onUmpError(error) {
      umpplayer_log.debug("onUmpError: ", JSON.stringify(error));
      var event;

      switch (toHex(error.errorCode)) {
        case '0x0000':
          {
            umpplayer_log.info("state chaned = playing"); // change state

            if (error.currentState === 'Play' || error.currentState === 'Resume') {
              this._readyState = UmpPlayState.PLAYING;
              var snapshotElement = document.getElementById('snapshot');

              if (snapshotElement !== undefined && snapshotElement !== null) {
                snapshotElement.classList.add('hidden');
              }
            } else if (error.currentState === 'Pause') {
              this._readyState = UmpPlayState.PAUSED;
            } // generate meta custom event


            event = new CustomEvent('statechange', {
              bubbles: true,
              detail: {
                elementId: this.getAttribute('id'),
                readyState: this.readyState
              }
            }); // dispatch event to application

            this.dispatchEvent(event);
            break;
          }

        case '0x0001':
          {
            umpplayer_log.info('state chaned = stopped');
            this._readyState = UmpPlayState.STOPPED;

            var _snapshotElement = document.getElementById('snapshot');

            if (_snapshotElement !== undefined && _snapshotElement !== null) {
              _snapshotElement.classList.remove('hidden');
            } // generate meta custom event


            event = new CustomEvent('statechange', {
              bubbles: true,
              detail: {
                elementId: this.getAttribute('id'),
                readyState: this.readyState
              }
            }); // dispatch event to application

            this.dispatchEvent(event);
            break;
          }

        case '0x0106':
          {
            this.stop(); // set element id to event data
            // generate meta custom event

            event = new CustomEvent('error', {
              bubbles: true,
              detail: {
                channelId: error.channelId,
                elementId: this.getAttribute('id'),
                error: toHex(error.errorCode),
                message: error.description,
                place: error.place
              }
            }); // dispatch event to application

            this.dispatchEvent(event);
            break;
          }

        case '0x0601':
          this.onUmpBackup(error);
          break;

        default:
          {
            // set element id to event data
            // generate meta custom event
            event = new CustomEvent('error', {
              bubbles: true,
              detail: {
                channelId: error.channelId,
                elementId: this.getAttribute('id'),
                error: toHex(error.errorCode),
                message: error.description,
                place: error.place
              }
            }); // dispatch event to application

            this.dispatchEvent(event);
            break;
          }
      }
    }
    /**
     * ump player status callback function from ump module
     */

  }, {
    key: "onUmpStatus",
    value: function onUmpStatus(event) {
      console.log("onUmpStatus: ", event);
    }
    /**
     * ump player resize event callback function from ump module
     * @param  {number} event.channelId channel id of resize event
     * @param  {string} event.elementId element id of resize event
     * @param  {string} event.tagmod tag type of event element
     * @param  {number} event.width width of video
     * @param  {number} event.height height of video
     */

  }, {
    key: "onUmpResize",
    value: function onUmpResize(event) {
      console.log("onUmpResize: ", event); //    var element = document.getElementById(event.elementId);

      var videoElement = getElementByAttributeValue(event.tagmode, 'kind-channel-mapped-id', event.elementId);

      if (videoElement !== undefined) {
        var styleText;
        styleText = videoElement.getAttribute("style", styleText);

        if (videoElement.style.width !== null && videoElement.style.width !== undefined && videoElement.style.width !== "") {
          //videoElement.style.width = videoElement.width;
          return;
        }

        if (videoElement.style.height !== null && videoElement.style.height !== undefined && videoElement.style.height !== "") {
          return;
        }

        styleText += "width:" + videoElement.width + "px;" + "height:" + videoElement.height + "px;";
        videoElement.setAttribute("style", styleText);
      }

      meta.elementId = this.getAttribute('id'); // generate resize custom event

      var event_data = new CustomEvent('resize', {
        bubbles: true,
        detail: {
          width: event.width,
          height: event.height
        }
      }); // dispatch event to application

      this.dispatchEvent(event_data);
    }
    /**
     * @description ump player meta event callback function from ump module
     * @param  {number} event.channelId channel id of resize event
     * @param  {string} event.elementId element id of resize event
     * @param  {string} event.tagmod tag type of event element
     * @param  {number} event.width width of video
     * @param  {number} event.height height of video
     */

  }, {
    key: "onUmpMeta",
    value: function onUmpMeta(meta) {
      umpplayer_log.debug("meta on ump-player: ", meta);

      if (typeof meta.json !== 'undefined' && typeof meta.xml !== 'undefined') {
        // set element id to event data
        meta.elementId = this.getAttribute('id'); // generate meta custom event

        var event = new CustomEvent('meta', {
          bubbles: true,
          detail: {
            json: meta.json,
            xml: meta.xml
          }
        }); // dispatch event to application

        this.dispatchEvent(event);
      }
    }
    /**
     * @description ump player timestamp event callback function from ump module
     * @param  {number} event.channelId channel id of resize event
     * @param  {string} event.elementId element id of resize event
     * @param  {string} event.tagmod tag type of event element
     * @param  {number} event.width width of video
     * @param  {number} event.height height of video
     */

  }, {
    key: "onUmpTimestamp",
    value: function onUmpTimestamp(timestamp) {
      //console.log("timestamp", timestamp);
      var localTimestamp;
      var currentDate = new Date();
      var gmtLocaleOffset = -1 * currentDate.getTimezoneOffset() / 60; //var curDate = new Date(time.timestamp * 1000 - time.timezone * 60000);
      //var curDate = new Date(~~(time.timestamp * 1000 + time.timestamp_usec) - (gmtLocaleOffset * 60000));

      var curDate = new Date(timestamp.timestamp * 1000 + timestamp.timestamp_usec);

      if (timestamp.timezone !== null && timestamp.timezone !== undefined) {
        this.timezone_offset = timestamp.timezone / 60;
        localTimestamp = new Date(curDate + 3600000 * this.timezone_offset);
      }

      this._currentTimestamp = curDate.toISOString(); //    var strDate = curDate.toGMTString();
      //console.log("timestamp", this._currentTimestamp);
      // generate meta custom event

      event = new CustomEvent('timestamp', {
        bubbles: true,
        detail: {
          elementId: this.getAttribute('id'),
          timestamp: this._currentTimestamp,
          local: localTimestamp !== undefined ? localTimestamp.YYYYMMDDHHMMSS() : localTimestamp
        }
      }); // dispatch event to application

      this.dispatchEvent(event);
    }
    /**
     * @description ump player statistics event callback function from ump module
     * @param  {number} event.channelId channel id of resize event
     * @param  {string} event.elementId element id of resize event
     * @param  {string} event.tagmod tag type of event element
     * @param  {number} event.width width of video
     * @param  {number} event.height height of video
     */

  }, {
    key: "onUmpStatistics",
    value: function onUmpStatistics(statictics) {
      umpplayer_log.debug("statictics = ", JSON.stringify(statictics));
      var event = new CustomEvent('statistics', {
        bubbles: true,
        detail: {
          elementId: this.getAttribute('id'),
          statictics: statictics
        }
      }); // dispatch event to application

      this.dispatchEvent(event);
    }
    /**
     * @description ump player step event callback function from ump module on playback
     * @param  {number} event.channelId channel id of resize event
     * @param  {string} event.elementId element id of resize event
     * @param  {string} event.tagmod tag type of event element
     * @param  {number} event.width width of video
     * @param  {number} event.height height of video
     */

  }, {
    key: "onUmpStep",
    value: function onUmpStep(step) {
      umpplayer_log.info("step", JSON.stringify(step));

      switch (step) {
        case 'request':
          if (this._deviceType === 'camera') {
            umpplayer_log.info("request next packet");
            var currentDateTime = new Date(this.currentTimestamp);
            var targetDateTime = new Date(currentDateTime.getTime() - 2000);
            this._seekingTime = targetDateTime.YYYYMMDDHHMMSS();
            this.seeking();
          }

          break;

        case 'complete':
          if (this._deviceType === 'camera') {
            this.pause();
          } // generate meta custom event


          event = new CustomEvent('statechange', {
            bubbles: true,
            detail: {
              elementId: this.getAttribute('id'),
              readyState: UmpPlayState.STEP
            }
          }); // dispatch event to application

          this.dispatchEvent(event);
          break;
      } // if(step === 'request') {
      // }

    }
    /**
     * @description ump player capture event callback function from ump module on playback
     * @param  {number} event.channelId channel id of resize event
     * @param  {string} event.blob blob data
     */

  }, {
    key: "onUmpCapture",
    value: function onUmpCapture(capture) {
      umpplayer_log.info("capture", capture);

      if (capture !== null && capture !== undefined) {
        // generate meta custom event
        event = new CustomEvent('capture', {
          bubbles: true,
          detail: {
            elementId: this.getAttribute('id'),
            blob: capture.blob
          }
        }); // dispatch event to application

        this.dispatchEvent(event);
      }
    }
    /**
       * @description ump player capture event callback function from ump module on playback
       * @param  {number} event.channelId channel id of resize event
       * @param  {string} event.blob blob data
       */

  }, {
    key: "onUmpBackup",
    value: function onUmpBackup(backup) {
      umpplayer_log.info("backup", JSON.stringify(backup));

      if (backup !== null && backup !== undefined) {
        switch (toHex(backup.errorCode)) {
          case '0x0600':
            {
              // generate meta custom event
              var event_data = new CustomEvent('backupstate', {
                bubbles: true,
                detail: {
                  elementId: this.getAttribute('id'),
                  state: backup.errorCode,
                  filename: backup.filename
                }
              }); // dispatch event to application

              this.dispatchEvent(event_data);
              break;
            }

          case '0x0601':
            {
              this.stop(); // generate meta custom event

              var event_data = new CustomEvent('backupstate', {
                bubbles: true,
                detail: {
                  elementId: this.getAttribute('id'),
                  state: backup.errorCode,
                  filename: backup.filename
                }
              }); // dispatch event to application

              this.dispatchEvent(event_data);
              break;
            }

          case '0x0603':
            {
              this.onUmpTimestamp(backup.timeStamp);
              break;
            }

          default:
            break;
        }
      }
    }
    /**
     * ump player play method
     *
     * @memberof UmpPlayer
     * @method  play
     * @throws {Object} umpError
     * @example
     * var element = document.getElementsByTagName("ump-player");
     * element.play();
     */

  }, {
    key: "play",
    value: function play() {
      //    var info = this.info;
      this.info.media.requestInfo.cmd = 'open';

      if (this.mode === null || this.mode === undefined) {
        this.mode = 'live';
      }

      if (this.playType === UmpPlayType.LIVE) {
        this.info.media.type = 'live';
        this.info.media.requestInfo.scale = 1;

        if (this._deviceType === 'camera') {
          this.info.media.boxsize = 4;
        } else {
          this.info.media.boxsize = 10;
        }
      } else {
        this.info.media.type = 'playback';
        this.info.media.requestInfo.scale = 1;
        this.info.media.needToImmediate = false;
        this.info.media.boxsize = 1;

        if (this.startTime === null || this.startTime === undefined) {
          throw new umpError({
            channelId: this.channel,
            elementId: this.getAttribute('id'),
            errorCode: fromHex('0x0411'),
            place: 'ump-player.js:1098',
            message: "start time is empty"
          });
        }

        if (this._currentTimestamp === null || this._currentTimestamp === undefined) {
          this._currentTimestamp = this.startTime;
        }

        if (this._deviceType === 'camera') {// the camera should not sent range clock parameter to rtsp parameter
          //this.info.media.requestInfo.rangeClock = (this.startTime.split('.')[0]+"Z").replace(/-/g, "").replace(/:/gi, "").replace(/T/gi, "").replace(/Z/gi, "").slice(0, 16);
          //this.info.media.requestInfo.rangeClock = (this.currentTimestamp.split('.')[0] + "Z").replace(/-/g, "").replace(/:/gi, "").slice(0, 16);
          // if(this._useIso && this._useIso !== null) {
          //   this.info.media.requestInfo.rangeClock = (this.currentTimestamp).replace(/-/g, "").replace(/:/gi, "").slice(0, 20);
          //   if(this.endTime !== undefined && this.endTime !== null) {
          //     this.info.media.requestInfo.rangeClock += "-" + (this.endTime).replace(/-/g, "").replace(/:/gi, "").slice(0, 20);
          //     } else {
          //       this.info.media.requestInfo.rangeClock += "-";
          //     }
          // }
        } else {
          if (this._useIso && this._useIso !== null) {
            this.info.media.requestInfo.rangeClock = this.currentTimestamp.replace(/-/g, "").replace(/:/gi, "").slice(0, 20);

            if (this.endTime !== undefined && this.endTime !== null) {
              this.info.media.requestInfo.rangeClock += "-" + this.endTime.replace(/-/g, "").replace(/:/gi, "").slice(0, 20);
            } else {
              this.info.media.requestInfo.rangeClock += "-";
            }
          } else {
            this.info.media.requestInfo.rangeClock = this.currentTimestamp.replace(/-/g, "").replace(/:/gi, "").replace(/T/gi, "").replace(/Z/gi, "").slice(0, 16);

            if (this.endTime !== undefined && this.endTime !== null) {
              this.info.media.requestInfo.rangeClock += "-" + this.endTime.replace(/-/g, "").replace(/:/gi, "").replace(/T/gi, "").replace(/Z/gi, "").slice(0, 16);
            } else {
              this.info.media.requestInfo.rangeClock += "-";
            }
          }
        }
      }

      umpplayer_log.debug("playinfo: ", this.info);
      this.info.callback.close = this.onUmpClose.bind(this);
      this.info.callback.error = this.onUmpError.bind(this);
      this.info.callback.status = this.onUmpStatus.bind(this);
      this.info.callback.vmode = this.onUmpVideoMode.bind(this); //this.info.callback.time = this.onUmpTimetamp;
      // check username attribute

      if (this._username === null || this._username === undefined) {
        throw new umpError({
          channelId: this.channel,
          elementId: this.getAttribute('id'),
          errorCode: fromHex('0x0402'),
          place: 'ump-player.js:632',
          message: "username attribute is empty"
        });
      } //check password attribute


      if ((this._password === null || this._password === undefined) && (this._sunapiMng.getSunapiClient() === null || this._sunapiMng.getSunapiClient() === undefined)) {
        throw new umpError({
          channelId: this.channel,
          elementId: this.getAttribute('id'),
          errorCode: fromHex('0x0402'),
          place: 'ump-player.js:632',
          message: "password attribute is empty or sunapi client property is null"
        });
      }

      if (this._source === null || this._source === undefined) {
        // generate rtsp url
        this.info.media.requestInfo.url = this.generateRTSPURL();
      }

      if (this._proxy !== null && this._proxy !== undefined) {
        // set websocket proxy server
        this.info.device.proxy = this._proxy;
      }

      if (this._port !== null && this._port !== undefined) {
        // set websocket server port
        this.info.device.port = this._port;
      }

      if (this._secure) {
        this.info.device.protocol = 'https';

        if (this._port === null || this._port === undefined) {
          this.info.device.port = '443';
        }
      }

      if (this.player === undefined || this.player === null) {
        this.player = new StreamPlayer(this.info, this._sunapiMng.getSunapiClient());
      }

      umpplayer_log.info("request play cmd: ", JSON.stringify(this.info));
      this.player.control(this.info);
    }
    /**
     * generate rtsp url string
     *
     * @memberof UmpPlayer
     * @returns {String} rtsp url
     * @throws {Object} umpError
     */

  }, {
    key: "generateRTSPURL",
    value: function generateRTSPURL() {
      var playType, strStart, strEnd;
      var strRtspURL = '';
      var log = log4javascript.getLogger('ump-player');

      if (this._deviceType === 'camera') {
        // generate rtps uri for camera
        if (this.info.media.type !== null && this.info.media.type !== undefined) {
          this.info.media.type === 'live' ? playType = "" : playType = "recording";
        }

        if (this._channel !== null && this._channel !== undefined) {
          strRtspURL += Number(this._channel - 1) + "/";
        }

        if (this.info.media.type === 'live') {
          if (this._multicast === true) {
            strRtspURL += "multicast/";
          }

          if (this._profile !== null && this._profile !== undefined && this._profile_number !== null && this._profile_number !== undefined) {
            throw new umpError({
              channelId: this.channel,
              elementId: this.getAttribute('id'),
              errorCode: fromHex('0x0406'),
              place: 'ump-player.js:1054',
              message: "profile information is duplicated, you have to use only single attribute from both."
            });
          }

          if (this._profile !== null && this._profile !== undefined) {
            strRtspURL += this._profile;
          } else if (this._profile_number !== null && this._profile_number !== undefined) {
            strRtspURL += "profile" + this._profile_number;
          } else {
            throw new umpError({
              channelId: this.channel,
              elementId: this.getAttribute('id'),
              errorCode: fromHex('0x0406'),
              place: 'ump-player.js:1054',
              message: "profile information is empty, you have to check profile attribute or profile_number attribute."
            });
          }

          strRtspURL += "/media.smp";
        } else if (this.info.media.type === 'playback') {
          strRtspURL += playType + "/";

          if (this._useIso && this._useIso !== null) {// TODO: camera iso time style generate
          } else {
            if (this.startTime !== null && this.startTime !== undefined) {
              strStart = (this.startTime.split('.')[0] + "Z").replace(/-/g, "").replace(/:/gi, "").replace(/T/gi, "").replace(/Z/gi, "").slice(0, 16);
            }

            if (this.seekingTime !== null && this.seekingTime !== undefined) {
              strStart = (this.seekingTime.split('.')[0] + "Z").replace(/-/g, "").replace(/:/gi, "").replace(/T/gi, "").replace(/Z/gi, "").slice(0, 16);
            }

            if (this.endTime !== null && this.endTime !== undefined) {
              strEnd = (this.endTime.split('.')[0] + "Z").replace(/-/g, "").replace(/:/gi, "").replace(/T/gi, "").replace(/Z/gi, "").slice(0, 16);
            } // generate  playback url like a start=20181112T000001Z&overlap=11


            if (strStart !== undefined) {
              strRtspURL += strStart;
            }

            if (strEnd !== undefined) {
              strRtspURL += "-" + strEnd;
            }

            strRtspURL += "/";
          }

          if (this.overlappedId !== null && this.overlappedId !== undefined) {
            strRtspURL += "OverlappedID=" + this.overlappedId;
          }

          strRtspURL += "/play.smp";
        } else if (this.info.media.type === 'backup') {
          strRtspURL += playType + "/";

          if (this._useIso && this._useIso !== null) {// TODO: camera iso time style generate
          } else {
            if (this.startTime !== null && this.startTime !== undefined) {
              strStart = (this.startTime.split('.')[0] + "Z").replace(/-/g, "").replace(/:/gi, "").replace(/T/gi, "").replace(/Z/gi, "").slice(0, 16);
            }

            if (this.seekingTime !== null && this.seekingTime !== undefined) {
              strStart = (this.seekingTime.split('.')[0] + "Z").replace(/-/g, "").replace(/:/gi, "").replace(/T/gi, "").replace(/Z/gi, "").slice(0, 16);
            }

            if (this.endTime !== null && this.endTime !== undefined) {
              strEnd = (this.endTime.split('.')[0] + "Z").replace(/-/g, "").replace(/:/gi, "").replace(/T/gi, "").replace(/Z/gi, "").slice(0, 16);
            } // generate  playback url like a start=20181112T000001Z&overlap=11


            if (strStart !== undefined) {
              strRtspURL += strStart;
            }

            if (strEnd !== undefined) {
              strRtspURL += "-" + strEnd;
            }

            strRtspURL += "/";
          }

          if (this.overlappedId !== null && this.overlappedId !== undefined) {
            strRtspURL += "OverlappedID=" + this.overlappedId;
          }

          strRtspURL += "/backup.smp";
        } else {
          throw new umpError({
            channelId: this.channel,
            elementId: this.getAttribute('id'),
            errorCode: fromHex('0x0906'),
            place: 'ump-player.js:632',
            message: "Invalidate play mode: [" + this.info.media.type + "]"
          });
        }
      } else if (this._deviceType === 'nvr') {
        // generate rtps uri for nvr
        if (this.info.media.type !== null && this.info.media.type !== undefined) {
          switch (this.info.media.type.toLowerCase()) {
            case ' live':
              playType = "LiveChannel";
              break;

            case 'playback':
              playType = "PlaybackChannel";
              break;

            case 'backup':
              playType = "BackupChannel";
              break;

            default:
              playType = "LiveChannel";
              break;
          }
        }

        strRtspURL = playType + "/";

        if (this._channel !== null && this._channel !== undefined) {
          strRtspURL += this._channel - 1 + "/media.smp";
        } else {
          throw new umpError({
            channelId: this.channel,
            elementId: this.getAttribute('id'),
            errorCode: fromHex('0x0408'),
            place: 'ump-player.js:1093',
            message: "channel attribute is empty for nvr device type"
          });
        }

        if (this._sessionKey !== null && this._sessionKey !== undefined) {
          strRtspURL += "/session=" + this._sessionKey + "&";
        } else {
          console.warn("If you do not use session key, you could not play more 10 channel.");
          strRtspURL += "/";
        }

        if (this.info.media.type === 'playback' || this.info.media.type === 'backup') {
          if (this.startTime !== null || this.endTime !== null || this.overlappedId !== null) {
            if (this.startTime !== null && this.startTime !== undefined) {
              //strStart = (this.startTime.split('.')[0] + "Z").replace(/-/g, "").replace(/:/gi, "").slice(0, 16);
              // if (this.startTime.indexOf("-")) { strStart = this.startTime.replace(/-/gi, ""); }
              //
              // if (this.startTime.indexOf(":")) { strStart = strStart.replace(/:/gi, ""); }p
              if (this._useIso && this._useIso !== null) {
                strStart = (this.startTime.split('.')[0] + "Z").replace(/-/g, "").replace(/:/gi, "").slice(0, 20);
              } else {
                //strStart = (this.startTime.split('.')[0] + "Z").replace(/-/g, "").replace(/:/gi, "").replace(/T/gi, "").replace(/Z/gi, "").slice(0, 16);
                strStart = (this.startTime.split('.')[0] + "Z").replace(/-/g, "").replace(/:/gi, "").replace(/Z/gi, "").slice(0, 15);
              }
            }

            if (this.endTime !== null && this.endTime !== undefined) {
              //strEnd = (this.endTime.split('.')[0] + "Z").replace(/-/g, "").replace(/:/gi, "").slice(0, 16);
              // if (this.endTime.indexOf("-")) { strEnd = this.endTime.replace(/-/gi, ""); }
              // if (this.endTime.indexOf(":")) { strEnd = strEnd.replace(/:/gi, ""); }
              if (this._useIso && this._useIso !== null) {
                strEnd = (this.endTime.split('.')[0] + "Z").replace(/-/g, "").replace(/:/gi, "").slice(0, 20);
              } else {
                //strEnd = (this.endTime.split('.')[0] + "Z").replace(/-/g, "").replace(/:/gi, "").replace(/T/gi, "").replace(/Z/gi, "").slice(0, 16);
                strEnd = (this.endTime.split('.')[0] + "Z").replace(/-/g, "").replace(/:/gi, "").replace(/Z/gi, "").slice(0, 15);
              }
            } // generate  playback url like a start=20181112T000001Z&overlap=11


            if (strStart !== undefined) {
              strRtspURL += "start=" + strStart;
            }

            if (strEnd !== undefined) {
              strRtspURL += "&end=" + strEnd;
            }

            if (this.overlappedId !== null && this.overlappedId !== undefined) {
              strRtspURL += "&overlap=" + this.overlappedId;
            }
          }
        } else {
          if (this._sessionKey !== null && this._sessionKey !== undefined) {
            strRtspURL += "&";
          }

          if (this._profile_number !== null && this._profile_number !== undefined) {
            strRtspURL += "profile=" + this._profile_number;
          } else if (this._profile !== null && this._profile !== undefined) {
            strRtspURL += "profile=" + this._profile;
          } else {
            throw new umpError({
              channelId: this.channel,
              elementId: this.getAttribute('id'),
              errorCode: fromHex('0x0406'),
              place: 'ump-player.js:1054',
              message: "profile information is empty	"
            });
          }
        }

        if (this.mode === 'iframe') {
          strRtspURL += "&iframe";
        }
      } else {
        throw new umpError({
          channelId: this.channel,
          elementId: this.getAttribute('id'),
          errorCode: fromHex('0x0404'),
          place: 'ump-player.js:1174',
          message: "device attribute is not define."
        });
      }

      umpplayer_log.debug("genetated rtsp url: ", strRtspURL);
      return strRtspURL;
    }
    /**
     * ump player stop method
     *
     * @memberof UmpPlayer
     * @method  stop
     * @throws {Object} umpError
     * @example
     * var element = document.getElementsByTagName("ump-player");
     * element.stop();
     */

  }, {
    key: "stop",
    value: function stop() {
      var log = log4javascript.getLogger('ump-player');

      if (this.player === undefined || this.player === null) {
        throw new umpError({
          channelId: this.channel,
          elementId: this.getAttribute('id'),
          errorCode: fromHex('0x1000'),
          place: 'ump-player.js:897',
          message: "player object is not exist"
        });
      }

      if (this._source === null || this._source === undefined) {
        // generate rtsp url
        this.info.media.requestInfo.url = this.generateRTSPURL();
      }

      this.info.media.requestInfo.cmd = 'close';
      umpplayer_log.info("request stop cmd: ", this.info);
      this.player.control(this.info);
    }
    /**
     * ump player pause method
     *
     * @memberof UmpPlayer
     * @method  pause
     * @throws {Object} umpError
     * @example
     * var element = document.getElementsByTagName("ump-player");
     * element.pause();
     */

  }, {
    key: "pause",
    value: function pause() {
      var log = log4javascript.getLogger('ump-player');

      if (this.player === undefined || this.player === null) {
        throw new umpError({
          channelId: this.channel,
          elementId: this.getAttribute('id'),
          errorCode: fromHex('0x1000'),
          place: 'ump-player.js:921',
          message: "player object is not exist"
        });
      } // set range clock from current timestamp on playback


      if (this.info.media.type === 'playback') {
        if (this._deviceType === 'camera') {//this.info.media.requestInfo.rangeClock = (this.currentTimestamp.split('.')[0]+"Z").replace(/-/g, "").replace(/:/gi, "").replace(/T/gi, "").replace(/Z/gi, "").slice(0, 16);
          // this.info.media.requestInfo.rangeClock = (this.currentTimestamp.split('.')[0] + "Z").replace(/-/g, "").replace(/:/gi, "").slice(0, 16);
        } else if (this._deviceType === 'nvr') {
          this.info.media.requestInfo.rangeClock = (this.currentTimestamp.split('.')[0] + "Z").replace(/-/g, "").replace(/:/gi, "").slice(0, 16);
        } else {
          throw new umpError({
            channelId: this.channel,
            elementId: this.getAttribute('id'),
            errorCode: fromHex('0x0404'),
            place: 'ump-player.js:983',
            message: "device type is undefined"
          });
        }
      }

      if (this._source === null || this._source === undefined) {
        // generate rtsp url
        this.info.media.requestInfo.url = this.generateRTSPURL();
      }

      this.info.media.requestInfo.cmd = 'pause'; // clear player buffer flag, if you have to clear buffer from player,
      // change to true

      this.info.media.needToImmediate = false;
      umpplayer_log.info("request pause cmd: ", this.info);
      this.player.control(this.info);
    }
    /**
     * ump player resume method
     *
     * @memberof UmpPlayer
     * @method  resume
     * @example
     * var element = document.getElementsByTagName("ump-player");
     * element.resume();
     */

  }, {
    key: "resume",
    value: function resume() {
      var log = log4javascript.getLogger('ump-player');

      if (this.player === undefined || this.player === null) {
        throw new umpError({
          channelId: this.channel,
          elementId: this.getAttribute('id'),
          errorCode: fromHex('0x1000'),
          place: 'ump-player.js:921',
          message: "player object is not exist"
        });
      } // set range clock from current timestamp on playback


      if (this.info.media.type === 'playback') {
        if (this._deviceType === 'camera') {//this.info.media.requestInfo.rangeClock = (this.currentTimestamp.split('.')[0]+"Z").replace(/-/g, "").replace(/:/gi, "").replace(/T/gi, "").replace(/Z/gi, "").slice(0, 16);
          // this.info.media.requestInfo.rangeClock = (this.currentTimestamp.split('.')[0] + "Z").replace(/-/g, "").replace(/:/gi, "").slice(0, 16);
        } else if (this._deviceType === 'nvr') {
          if (this._useIso && this._useIso !== null) {
            this.info.media.requestInfo.rangeClock = this.currentTimestamp.replace(/-/g, "").replace(/:/gi, "").slice(0, 20);
          } else {
            this.info.media.requestInfo.rangeClock = this.currentTimestamp.replace(/-/g, "").replace(/:/gi, "").replace(/Z/gi, "").slice(0, 20);
          }
        } else {
          throw new umpError({
            channelId: this.channel,
            elementId: this.getAttribute('id'),
            errorCode: fromHex('0x0404'),
            place: 'ump-player.js:983',
            message: "device type is undefined"
          });
        }
      }

      if (this._source === null || this._source === undefined) {
        // generate rtsp url
        this.info.media.requestInfo.url = this.generateRTSPURL();
      }

      this.info.media.requestInfo.cmd = 'resume'; // clear player buffer flag, if you have to clear buffer from player,
      // change to true

      this.info.media.needToImmediate = false;
      this.info.media.requestInfo.scale = 1.0;
      umpplayer_log.info("request pause cmd: ", this.info);
      this.player.control(this.info);
    }
    /**
     * ump player check method for play state
     *
     * @memberof UmpPlayer
     * @method  isPlay
     * @returns {boolean} play state  (boolean, true: playing, false: stopped)
     *               if player is not initialize the device, return minus value.
     * @throws {Object} umpError
     * @example
     * var element = document.getElementsByTagName("ump-player");
     * if(element.isPlay()) { element.stop(); }
     */

  }, {
    key: "isPlay",
    value: function isPlay() {
      var log = log4javascript.getLogger('ump-player');
      var rtn;

      if (this.player === undefined || this.player === null) {
        return false; // throw new umpError({
        //   channelId: this.channel,
        //   elementId: this.getAttribute('id'),
        //   errorCode: fromHex('0x1000'),
        //   place: 'ump-player.js:921',
        //   message: "player object is not exist"
        // });
      }

      this.player.getCurrentState() === "Playing" ? rtn = true : rtn = false;
      umpplayer_log.debug("isPlay: ", rtn);
      return rtn;
    }
    /**
     * ump player set session key for multi clients on nvr device
     *
     * @memberof UmpPlayer
     * @method  setSessionKey
     * @deprecated since 2018.11.09<br>
     *                change to sessionKey property
     * @param  {string} sessionkey session key from sunapi API<br>
     *                Chapter 4.6 Get Session Key from SUNAPI Application Programmers Guide<br>
     *                http://hostname or ip address/stw-cgi/media.cgi?msubmenu=sessionkey &action=view
     * @example
     * var element = document.getElementsByTagName("ump-player");
     * element.setSessionKey('123456');
     */

  }, {
    key: "setSessionKey",
    value: function setSessionKey(sessionkey) {
      this._sessionKey = sessionkey;
    }
    /**
     * ump player set sunapi client for safety on device
     *
     * @memberof UmpPlayer
     * @method  setSunapiClient
     * @deprecated since 2018.11.09<br>
     *               change to sunapiClient property
     * @param  {object} client sunapi client object
     * @example
     *  var device = {
     *    ClientIPAddress: '127.0.0.1',
     *    hostname: '<device ip or hostname>',
     *    port: <device port>,
     *    captureName: '',
     *    protocol: '',
     *    username: '<username>',
     *    password: '<password>',
     *    deviceType: '<device type>',
     *    debug: false,
     *    async: false
     * };
     * var element = document.setSunapiClient(sunapiClient);
     * <ump-player id="ump-player1" hostname="192.168.123.240" username="admin">
     */

  }, {
    key: "setSunapiClient",
    value: function setSunapiClient(client) {
      //    if(this._password === undefined || this._password === null) {
      this.sunapiClient = client; // } else {
      //   throw new umpError({
      //     channelId: this.channel,
      //     elementId: this.getAttribute('id'),
      //     errorCode: fromHex('0x1002'),
      //     place: 'ump-player.js:921',
      //     message: "player object is not exist"
      //   });
      // }
    }
    /**
     * ump player unmute audio
     *
     * @memberof UmpPlayer
     * @method  unmute
     * @throws {umpError}
     * @example
     * var element = document.getElementsByTagName("ump-player");
     * element.unmute();
     */

  }, {
    key: "unmute",
    value: function unmute() {
      var log = log4javascript.getLogger('ump-player');

      if (this.player === undefined || this.player === null) {
        throw new umpError({
          channelId: this.channel,
          elementId: this.getAttribute('id'),
          errorCode: fromHex('0x1000'),
          place: 'ump-player.js:921',
          message: "player object is not exist"
        });
      }

      this.info.media.requestInfo.cmd = 'audioIn';
      this.info.media.requestInfo.data = 'unmute';
      umpplayer_log.debug("request unmute cmd: ", this.info);
      this.player.control(this.info);
    }
    /**
     * ump player mute audio
     *
     * @memberof UmpPlayer
     * @method  mute
     * @throws {umpError}
     * @example
     * var element = document.getElementsByTagName("ump-player");
     * element.mute();
     */

  }, {
    key: "mute",
    value: function mute() {
      var log = log4javascript.getLogger('ump-player');

      if (this.player === undefined || this.player === null) {
        throw new umpError({
          channelId: this.channel,
          elementId: this.getAttribute('id'),
          errorCode: fromHex('0x1000'),
          place: 'ump-player.js:921',
          message: "player object is not exist"
        });
      }

      this.info.media.requestInfo.cmd = 'audioIn';
      this.info.media.requestInfo.data = 'mute';
      umpplayer_log.debug("request mute cmd: ", this.info);
      this.player.control(this.info);
    }
    /**
     * ump player get audio volume
     *
     * @memberof UmpPlayer
     * @method  getAudioVolume
     * @return current audio volume
     *              if player is not connect to device, return minus value.
     * @throws {umpError}
     * @example
     * var element = document.getElementsByTagName("ump-player");
     * var volume = element.getAudioVolume();
     */

  }, {
    key: "getAudioVolume",
    value: function getAudioVolume() {
      if (this.player === undefined || this.player === null) {
        throw new umpError({
          channelId: this.channel,
          elementId: this.getAttribute('id'),
          errorCode: fromHex('0x1000'),
          place: 'ump-player.js:921',
          message: "player object is not exist"
        });
      }

      return this.player.getAudioVolume();
    }
    /**
     * ump player set audio volume
     *
     * @memberof UmpPlayer
     * @method  setAudioVolume
     * @throws {umpError}
     * @example
     * var element = document.getElementsByTagName("ump-player");
     * element.setVolume(5);
     */

  }, {
    key: "setAudioVolume",
    value: function setAudioVolume(volume) {
      var log = log4javascript.getLogger('ump-player');

      if (this.player === undefined || this.player === null) {
        throw new umpError({
          channelId: this.channel,
          elementId: this.getAttribute('id'),
          errorCode: fromHex('0x1000'),
          place: 'ump-player.js:921',
          message: "player object is not exist"
        });
      }

      this.info.media.requestInfo.cmd = 'audioIn';
      this.info.media.requestInfo.data = Number(volume);
      umpplayer_log.debug("request set volume cmd: ", this.info);
      this.player.control(this.info);
    }
    /**
     * ump player get mute status
     *
     * @memberof UmpPlayer
     * @method  isMute
     * @throws {umpError}
     * @example
     * var element = document.getElementsByTagName("ump-player");
     * element.isMute();
     */

  }, {
    key: "isMute",
    value: function isMute() {
      if (this.player === undefined || this.player === null) {
        throw new umpError({
          channelId: this.channel,
          elementId: this.getAttribute('id'),
          errorCode: fromHex('0x1000'),
          place: 'ump-player.js:921',
          message: "player object is not exist"
        });
      }

      return this.player.isMute();
    }
    /**
     * ump player speed method
     *
     * @memberof UmpPlayer
     * @method  speed
     * @param {UmpPlaySpeed} speed speed value
     * @throws {umpError} umpError
     * @example
     * var element = document.getElementsByTagName("ump-player");
     * element.playSpeed = 32;
     * element.playSpeed = '32x';
     */

  }, {
    key: "speed",
    value: function speed() {
      var log = log4javascript.getLogger('ump-player');

      if (this.player === undefined || this.player === null) {
        throw new umpError({
          channelId: this.channel,
          elementId: this.getAttribute('id'),
          errorCode: fromHex('0x1000'),
          place: 'ump-player.js:921',
          message: "player object is not exist"
        });
      } // set range clock from current timestamp on playback


      if (this.info.media.type === 'playback') {
        if (this._deviceType === 'camera') {
          //this.info.media.requestInfo.rangeClock = (this.currentTimestamp.split('.')[0]+"Z").replace(/-/g, "").replace(/:/gi, "").replace(/T/gi, "").replace(/Z/gi, "").slice(0, 16);
          this.info.media.requestInfo.rangeClock = this.currentTimestamp.replace(/-/g, "").replace(/:/gi, "").slice(0, 16);
        } else if (this._deviceType === 'nvr') {
          if (this._useIso && this._useIso !== null) {
            if (this._playSpeed.value > 0) {
              this.info.media.requestInfo.rangeClock = this.currentTimestamp.replace(/-/g, "").replace(/:/gi, "").slice(0, 20);

              if (this.endTime !== undefined && this.endTime !== null) {
                this.info.media.requestInfo.rangeClock += "-" + this.endTime.replace(/-/g, "").replace(/:/gi, "").slice(0, 20);
              } else {
                this.info.media.requestInfo.rangeClock += "-";
              }
            } else {
              if (this.endTime !== undefined && this.endTime !== null) {
                this.info.media.requestInfo.rangeClock = this.currentTimestamp.replace(/-/g, "").replace(/:/gi, "").slice(0, 20);
                this.info.media.requestInfo.rangeClock += "-" + this.startTime.replace(/-/g, "").replace(/:/gi, "").slice(0, 20);
              } else {
                this.info.media.requestInfo.rangeClock = this.currentTimestamp.replace(/-/g, "").replace(/:/gi, "").slice(0, 20);
                this.info.media.requestInfo.rangeClock += "-";
              }
            }
          } else {
            if (this._playSpeed.value > 0) {
              this.info.media.requestInfo.rangeClock = this.currentTimestamp.replace(/-/g, "").replace(/:/gi, "").replace(/Z/gi, "").slice(0, 20);

              if (this.endTime !== undefined && this.endTime !== null) {
                this.info.media.requestInfo.rangeClock += "-" + this.endTime.replace(/-/g, "").replace(/:/gi, "").replace(/Z/gi, "").slice(0, 20);
              } else {
                this.info.media.requestInfo.rangeClock += "-";
              }
            } else {
              if (this.endTime !== undefined && this.endTime !== null) {
                this.info.media.requestInfo.rangeClock = this.currentTimestamp.replace(/-/g, "").replace(/:/gi, "").replace(/Z/gi, "").slice(0, 20);
                this.info.media.requestInfo.rangeClock += "-" + this.startTime.replace(/-/g, "").replace(/:/gi, "").replace(/Z/gi, "").slice(0, 20);
              } else {
                this.info.media.requestInfo.rangeClock = this.currentTimestamp.replace(/-/g, "").replace(/:/gi, "").replace(/Z/gi, "").slice(0, 20);
                this.info.media.requestInfo.rangeClock += "-";
              }
            }
          }
        } else {
          throw new umpError({
            channelId: this.channel,
            elementId: this.getAttribute('id'),
            errorCode: fromHex('0x0404'),
            place: 'ump-player.js:983',
            message: "device type is undefined"
          });
        }
      } else {
        throw new umpError({
          channelId: this.channel,
          elementId: this.getAttribute('id'),
          errorCode: fromHex('0x1001'),
          place: 'ump-player.js:1246',
          message: "This function support only placyback mode."
        });
      }

      this.info.media.type = 'playback';

      if (this._playSpeed.value < 0) {
        this.info.media.requestInfo.cmd = 'seek';
      } else {
        this.info.media.requestInfo.cmd = 'speed';
      } // set speed


      this.info.media.requestInfo.scale = this._playSpeed.value;
      this.info.media.needToImmediate = true;
      umpplayer_log.debug("request change speed cmd: ", JSON.stringify(this.info));
      this.player.control(this.info);
    }
    /**
     * ump player forward method
     *
     * @memberof UmpPlayer
     * @method  forward
     * @throws {umpError} umpError
     * @example
     * var element = document.getElementsByTagName("ump-player");
     * element.forward();
     */

  }, {
    key: "forward",
    value: function forward() {
      if (this.player === undefined || this.player === null) {
        throw new umpError({
          channelId: this.channel,
          elementId: this.getAttribute('id'),
          errorCode: fromHex('0x1000'),
          place: 'ump-player.js:921',
          message: "player object is not exist"
        });
      } // set range clock from current timestamp on playback


      if (this.info.media.type === 'playback') {
        var currentDateTime = new Date(this.currentTimestamp);
        var isoTimeString = new Date(currentDateTime.getTime() + 1000).toISOString();

        if (this._deviceType === 'camera') {//this.info.media.requestInfo.rangeClock = (this.currentTimestamp.split('.')[0]+"Z").replace(/-/g, "").replace(/:/gi, "").replace(/T/gi, "").replace(/Z/gi, "").slice(0, 16);
          //this.info.media.requestInfo.rangeClock = isoTimeString.replace(/-/g, "").replace(/:/gi, "").slice(0, 20);
        } else if (this._deviceType === 'nvr') {
          if (this._useIso && this._useIso !== null) {
            this.info.media.requestInfo.rangeClock = isoTimeString.replace(/-/g, "").replace(/:/gi, "").slice(0, 20);
          } else {
            this.info.media.requestInfo.rangeClock = isoTimeString.replace(/-/g, "").replace(/:/gi, "").replace(/Z/gi, "").slice(0, 20);
          }
        } else {
          throw new umpError({
            channelId: this.channel,
            elementId: this.getAttribute('id'),
            errorCode: fromHex('0x0404'),
            place: 'ump-player.js:983',
            message: "device type is undefined"
          });
        }
      }

      this.info.media.type = 'playback';
      this.info.media.needToImmediate = true;
      this.info.media.requestInfo.cmd = 'forward';
      this.info.media.requestInfo.scale = 0.0;

      if (this._source === null || this._source === undefined) {
        // generate rtsp url
        this.info.media.requestInfo.url = this.generateRTSPURL();
      }

      umpplayer_log.debug("request forward cmd: ", JSON.stringify(this.info));
      this.player.control(this.info);
    } // end forward

    /**
     * ump player backward method
     *
     * @memberof UmpPlayer
     * @method  backward
     * @throws {umpError} umpError
     * @example
     * var element = document.getElementsByTagName("ump-player");
     * element.backward();
     */

  }, {
    key: "backward",
    value: function backward() {
      if (this.player === undefined || this.player === null) {
        throw new umpError({
          channelId: this.channel,
          elementId: this.getAttribute('id'),
          errorCode: fromHex('0x1000'),
          place: 'ump-player.js:921',
          message: "player object is not exist"
        });
      } // set range clock from current timestamp on playback


      if (this.info.media.type === 'playback') {
        var currentDateTime = new Date(this.currentTimestamp);
        var isoTimeString = new Date(currentDateTime.getTime() - 1000).toISOString();

        if (this._deviceType === 'camera') {//this.info.media.requestInfo.rangeClock = isoTimeString.replace(/-/g, "").replace(/:/gi, "").slice(0, 20);
        } else if (this._deviceType === 'nvr') {
          if (this._useIso && this._useIso !== null) {
            this.info.media.requestInfo.rangeClock = isoTimeString.replace(/-/g, "").replace(/:/gi, "").slice(0, 20);
          } else {
            this.info.media.requestInfo.rangeClock = isoTimeString.replace(/-/g, "").replace(/:/gi, "").replace(/Z/gi, "").slice(0, 20);
          }
        } else {
          throw new umpError({
            channelId: this.channel,
            elementId: this.getAttribute('id'),
            errorCode: fromHex('0x0404'),
            place: 'ump-player.js:983',
            message: "device type is undefined"
          });
        }
      }

      this.info.media.type = 'playback';
      this.info.media.needToImmediate = true;
      this.info.media.requestInfo.cmd = 'backward';
      this.info.media.requestInfo.scale = 0.0;

      if (this._source === null || this._source === undefined) {
        // generate rtsp url
        this.info.media.requestInfo.url = this.generateRTSPURL();
      }

      umpplayer_log.debug("request backward cmd: ", JSON.stringify(this.info));
      this.player.control(this.info);
    } // end backward

    /**
      * ump player seek method
      *
      * @memberof UmpPlayer
      * @method  seeking
      * @throws {umpError} umpError
      * @example
      * var element = document.getElementsByTagName("ump-player");
      * element.seekingTime = "20190131T000100.000Z"
      * element.seeking();
      */

  }, {
    key: "seeking",
    value: function seeking() {
      if (this.player === undefined || this.player === null) {
        throw new umpError({
          channelId: this.channel,
          elementId: this.getAttribute('id'),
          errorCode: fromHex('0x1000'),
          place: 'ump-player.js:921',
          message: "player object is not exist"
        });
      } // set range clock from current timestamp on playback


      if (this.info.media.type === 'playback') {
        if (this._deviceType === 'camera') {
          //this.info.media.requestInfo.rangeClock = (this.seekingTime.split('.')[0] + "Z").replace(/-/g, "").replace(/:/gi, "").replace(/T/gi, "").replace(/Z/gi, "").slice(0, 16);
          if (this._useIso && this._useIso !== null) {
            this.info.media.requestInfo.rangeClock = this.seekingTime.replace(/-/g, "").replace(/:/gi, "").slice(0, 20);
          } else {// this.info.media.requestInfo.rangeClock = (this.seekingTime.split('.')[0] + "Z").replace(/-/g, "").replace(/:/gi, "").replace(/T/gi, "").replace(/Z/gi, "").slice(0, 16);
          }
        } else if (this._deviceType === 'nvr') {
          if (this._useIso && this._useIso !== null) {
            this.info.media.requestInfo.rangeClock = this.seekingTime.replace(/-/g, "").replace(/:/gi, "").slice(0, 20);
          } else {
            this.info.media.requestInfo.rangeClock = (this.seekingTime.split('.')[0] + "Z").replace(/-/g, "").replace(/:/gi, "").replace(/Z/gi, "").slice(0, 16);
          }
        } else {
          throw new umpError({
            channelId: this.channel,
            elementId: this.getAttribute('id'),
            errorCode: fromHex('0x0404'),
            place: 'ump-player.js:983',
            message: "device type is undefined"
          });
        }
      }

      this.info.media.type = 'playback';
      this.info.media.requestInfo.scale = 1.0;
      this.info.media.needToImmediate = false;
      this.info.media.requestInfo.cmd = 'seek';

      if (this._source === null || this._source === undefined) {
        // generate rtsp url
        this.info.media.requestInfo.url = this.generateRTSPURL();
      }

      umpplayer_log.debug("request seeking cmd: ", this.info);
      this._seekingTime = null;
      this.player.control(this.info);
    } // end seek

    /**
     * ump player capture method
     *
     * @memberof UmpPlayer
     * @method  capture
     * @param {string} filename capture filename, if you do not input filename,
     *                                       it will be return blob to caltpure callback
     * @throws {umpError} umpError
     * @example
     * var filename = 'capturename';
     * var element = document.getElementsByTagName("ump-player");
     * element.addEventListener('capture', oncapture);
     * element.filename = filename; // capture filename
     * element.capture();
     *
     * // if you do not input file name to ump-player element,
     * // capture image will be send to capture listener
     * function oncapture(capture) {
     *   console.log("capture element:", capture.detail.elementId);
     *   //var image = new Image();
     *   image = document.getElementById('capture');
     *   image.src = URL.createObjectURL(capture.detail.blob);
     *   //image.style = 'position:absolute;'
     *   //document.body.appendChild(image);
     * }
     */

  }, {
    key: "capture",
    value: function capture(filename) {
      if (this.player === undefined || this.player === null) {
        throw new umpError({
          channelId: this.channel,
          elementId: this.getAttribute('id'),
          errorCode: fromHex('0x1000'),
          place: 'ump-player.js:921',
          message: "player object is not exist"
        });
      }

      if (filename !== undefined) {
        this._filename = filename;
      }

      this.info.device.channel = this.channel;
      this.info.device.captureName = this._filename;
      this.info.media.requestInfo.cmd = 'capture';
      this.player.control(this.info);
      this._filename = null;
    }
    /**
     * ump player talk method
     *
     * @memberof UmpPlayer
     * @method  talk
     * @param {boolean} flag talk control flag enable/disable,
     * @throws {umpError} umpError
     * @example
     * var element = document.getElementsByTagName("ump-player");
     * element.talk(true);
     */

  }, {
    key: "talk",
    value: function talk(flag) {
      if (this.player === undefined || this.player === null) {
        throw new umpError({
          channelId: this.channel,
          elementId: this.getAttribute('id'),
          errorCode: fromHex('0x1000'),
          place: 'ump-player.js:2611',
          message: "player object is not exist"
        });
      }

      this.info.device.channel = this.channel;
      this.info.media.audioOutStatus = flag;
      this.info.media.requestInfo.cmd = 'audioOut';

      if (flag === true) {
        this.info.media.requestInfo.data = 'on';
      } else {
        this.info.media.requestInfo.data = 'off';
      }

      this.player.control(this.info);
    }
    /**
     * ump player backup method
     *
     * @memberof UmpPlayer
     * @method  backup
     * @param {Boolean} flag back start ot stop flag
     * @param {string} filename backup filename, if you do not input filename,
     *                                       it will be return blob to backup callback
     * @throws {umpError} umpError
     * @description This is backup method for live instant or playback.
     *                    If you want to start the backup video, you have to call backup method with flag which set to true.
     *                    In the other hand, you want to stop the backup video, you have to call backup method with flag which set to false.
     * @example
     *  var filename = "test"; // filename of instant backup (instant backup only)
     *  var element = document.getElementsByTagName("ump-player");
     *  element.addEventListener('backupstate', onbackupstate); // add backup state listener
     *  element.addEventListener('timestamp', ontimestamp); // add backup timestamp listener (playback backup mode only)
     *  element.playType = UmpPlayType.BACKUP; (playback backup mode only)
     *  element.filename = filename; // add file name for backup (instant backup mode only)
     *  element.startTime = 20190410T00:00:00Z; // backup start time (playback backup mode only)
     *  element.endTime = 20190410T00:00:10Z; // backup end time (playback backup mode only)
     *  element.backup(true); // starting backup
     *  element.backup(false); // stopping backup,
     *
     *  // if you add backup state listener to ump-player element,
     *  // backup state will be send to listener function
     *  function onbackupstate(backupstate) {
     *   console.log("backup state:", JSON.stringify(backupstate.detail));
     *
     *   switch(toHex(backupstate.detail.state)) {
    *   case '0x0600':
     *     console.log("backup start!!!, filename: " + backupstate.detail.filename);
    *   break;
    *   case '0x0601':
     *     console.log("backup stop!!!, filename: " + backupstate.detail.filename);
    *   break;
    *   case '0x0602':
    *   console.log("backup error!!!");
    *   break;
     *  }
     * }
     * function ontimestamp(timestamp) {
    *   console.log("timestamp: ", JSON.stringify(timestamp.detail));
     * }
     */

  }, {
    key: "backup",
    value: function backup(flag, filename) {
      // if instant backup mode, it's need current ump player
      if (this._playType !== UmpPlayType.BACKUP && (this.player === undefined || this.player === null)) {
        throw new umpError({
          channelId: this.channel,
          elementId: this.getAttribute('id'),
          errorCode: fromHex('0x1000'),
          place: 'ump-player.js:2691',
          message: "player object is not exist"
        });
      }

      if (this._playType !== UmpPlayType.BACKUP && filename === undefined && this._filename === null) {
        throw new umpError({
          channelId: this.channel,
          elementId: this.getAttribute('id'),
          errorCode: fromHex('0x1003'),
          place: 'ump-player.js:2701',
          message: "The file name is not input for capture."
        });
      }

      if (this._playType !== UmpPlayType.BACKUP && filename !== undefined) {
        this._filename = filename;
      }

      if (this._playType === UmpPlayType.BACKUP) {
        if (flag === true) {
          this.info.media.type = 'backup';
          this.info.media.requestInfo.scale = 1;
          this.info.media.needToImmediate = false;
          this.info.media.boxsize = 1;

          if (this.startTime === null || this.startTime === undefined) {
            throw new umpError({
              channelId: this.channel,
              elementId: this.getAttribute('id'),
              errorCode: fromHex('0x0411'),
              place: 'ump-player.js:1098',
              message: "start time is empty"
            });
          }

          if (this._currentTimestamp === null || this._currentTimestamp === undefined) {
            this._currentTimestamp = this.startTime;
          }

          if (this._deviceType === 'camera') {// the camera should not sent range clock parameter to rtsp parameter
            //this.info.media.requestInfo.rangeClock = (this.startTime.split('.')[0]+"Z").replace(/-/g, "").replace(/:/gi, "").replace(/T/gi, "").replace(/Z/gi, "")  .slice(0, 16);
            //this.info.media.requestInfo.rangeClock = (this.currentTimestamp.split('.')[0] + "Z").replace(/-/g, "").replace(/:/gi, "").slice(0, 16);
            // if(this._useIso && this._useIso !== null) {
            //   this.info.media.requestInfo.rangeClock = (this.currentTimestamp).replace(/-/g, "").replace(/:/gi, "").slice(0, 20);
            //   if(this.endTime !== undefined && this.endTime !== null) {
            //     this.info.media.requestInfo.rangeClock += "-" + (this.endTime).replace(/-/g, "").replace(/:/gi, "").slice(0, 20);
            //     } else {
            //       this.info.media.requestInfo.rangeClock += "-";
            //     }
            // }
          } else {
            if (this._useIso && this._useIso !== null) {
              this.info.media.requestInfo.rangeClock = this.startTime.replace(/-/g, "").replace(/:/gi, "").slice(0, 20);

              if (this.endTime !== undefined && this.endTime !== null) {
                this.info.media.requestInfo.rangeClock += "-" + this.endTime.replace(/-/g, "").replace(/:/gi, "").slice(0, 20);
              } else {
                this.info.media.requestInfo.rangeClock += "-";
              }
            } else {
              this.info.media.requestInfo.rangeClock = this.startTime.replace(/-/g, "").replace(/:/gi, "").replace(/T/gi, "").replace(/Z/gi, "").slice(0, 16);

              if (this.endTime !== undefined && this.endTime !== null) {
                this.info.media.requestInfo.rangeClock += "-" + this.endTime.replace(/-/g, "").replace(/:/gi, "").replace(/T/gi, "").replace(/Z/gi, "").slice(0, 16);
              } else {
                this.info.media.requestInfo.rangeClock += "-";
              }
            }
          }

          this.info.media.requestInfo.cmd = 'backup';
          umpplayer_log.debug("playinfo: ", this.info);
          this.info.callback.close = this.onUmpClose.bind(this);
          this.info.callback.error = this.onUmpError.bind(this);
          this.info.callback.status = this.onUmpStatus.bind(this);
          this.info.callback.vmode = this.onUmpVideoMode.bind(this); //this.info.callback.time = this.onUmpTimetamp;
          // check username attribute

          if (this._username === null || this._username === undefined) {
            throw new umpError({
              channelId: this.channel,
              elementId: this.getAttribute('id'),
              errorCode: fromHex('0x0402'),
              place: 'ump-player.js:632',
              message: "username attribute is empty"
            });
          } //check password attribute


          if ((this._password === null || this._password === undefined) && (this._sunapiMng.getSunapiClient() === null || this._sunapiMng.getSunapiClient() === undefined)) {
            throw new umpError({
              channelId: this.channel,
              elementId: this.getAttribute('id'),
              errorCode: fromHex('0x0402'),
              place: 'ump-player.js:632',
              message: "password attribute is empty or sunapi client property is null"
            });
          }

          if (this._source === null || this._source === undefined) {
            // generate rtsp url
            this.info.media.requestInfo.url = this.generateRTSPURL();
          }

          if (this._proxy !== null && this._proxy !== undefined) {
            // set websocket proxy server
            this.info.device.proxy = this._proxy;
          }

          if (this._port !== null && this._port !== undefined) {
            // set websocket server port
            this.info.device.port = this._port;
          }

          if (this._secure) {
            this.info.device.protocol = 'https';

            if (this._port === null || this._port === undefined) {
              this.info.device.port = '443';
            }
          }

          if (this.player === undefined || this.player === null) {
            this.player = new StreamPlayer(this.info, this._sunapiMng.getSunapiClient());
          }

          umpplayer_log.info("request play cmd: ", JSON.stringify(this.info));
          this.player.control(this.info);
        } else {
          this.stop();
        }
      } else {
        this.info.device.channel = this.channel;
        this.info.device.captureName = this._filename;

        if (flag) {
          this.info.media.requestInfo.cmd = 'backupstart';
        } else {
          this.info.media.requestInfo.cmd = 'backupstop';
        }

        this.player.control(this.info);
      } //    this._filename = null;

    }
  }, {
    key: "playType",
    get: function get() {
      return this._playType;
    },
    set: function set(v) {
      this._playType = v;
    }
    /**
     * Type of play mode. live or palyback.
     * @property {String} mode Type of play mode.
     * @type {String}
     * @description The type of playmode property. If you change playmode, thi value set to live or playback<br>
     * @example
     *                  var element = document.getElementsById("ump-player");
     *                  element.mode = 'live';
     *                  element.mode = 'playback';
     */

  }, {
    key: "mode",
    get: function get() {
      if (this._playType === UmpPlayType.LIVE || this._playType === null) {
        this._playType = UmpPlayType.LIVE;
        return 'live';
      } else {
        this._playType = UmpPlayType.PLAYBACK;
        return 'playback';
      }
    },
    set: function set(v) {
      if (v === 'live') {
        this._playType = UmpPlayType.LIVE;
      } else if (v === 'playback') {
        this._playType = UmpPlayType.PLAYBACK;
      } else {
        this._playType = UmpPlayType.LIVE;
      }
    }
    /**
     * Session Key Properties.
     * @property {String} sessionKey session key for multi channel access on NVR devices
     * @type {String}
     * @description Session Key for Multi user access on NVR deivces<br>
     *                    If you not set the session key on NVR devices, You <br>
     *                    can not access over 10 channel. <br>
     *                    This value referece from {{@link SUNAPI 4.6 Get Session Key on Hanwha Techwin SUNAPI Application Programmers Guide}}
     * @example
     *                    var element = document.getElementsById("ump-player");
     *                    element.sessionKey = httpClient.getSessionKey();
     */

  }, {
    key: "sessionKey",
    get: function get() {
      return this._sessionKey;
    },
    set: function set(v) {
      this._sessionKey = v;
    }
    /**
     * Sunapi Client Properties
     * @property {Object} sunapiClient sunapi client for video play without user password
     * @type {Object}
     * @description Session Key for Multi user access on NVR deivces<br>
     *                    If you not set the session key on NVR devices, You <br>
     *                    can not access over 10 channel
     * @example
     *                    var sunapi = new sunapiClient(deviceInfo);
     *                    var element = document.getElementsById("ump-player");
     *                    element.sunapiClient = sunapi;
     */

  }, {
    key: "sunapiClient",
    get: function get() {
      return this._sunapiMng.getSunapiClient();
    },
    set: function set(v) {
      this._sunapiMng.setSunapiClient(v);
    } // static get UmpPlayState() {
    //   return UmpPlayState;
    // }

    /**
     * Start time properties for playback
     * @property {String} startTime start time for playback
     * @type {String}
     * @description start time properties. This is ISO type date string without millisecond.<br>
     *                    This value referece from {{@link SUNAPI 5.6 Timeline Search on Hanwha Techwin SUNAPI Application Programmers Guide}}
     * @example
     * var element = document.getElementsByTagName("ump-player");
     * element.startTime = '2018-11-29T12:00:00Z';
     */

  }, {
    key: "startTime",
    get: function get() {
      return this._startTime;
    },
    set: function set(v) {
      this._startTime = v;
    }
    /**
     * End time properties for playback
     * @property {String} endTime end time for playback
     * @type {String}
     * @description end time properties. This is ISO type date string without millisecond.<br>
     *                    This value referece from {{@link SUNAPI 5.6 Timeline Search on Hanwha Techwin SUNAPI Application Programmers Guide}}
     * @example
     * var element = document.getElementsByTagName("ump-player");
     * element.endTime = '2018-11-29T24:00:00Z';
     */

  }, {
    key: "endTime",
    get: function get() {
      return this._endTime;
    },
    set: function set(v) {
      this._endTime = v;
    }
    /**
     * seeking time properties for playback
     * @property {String} seekTime seeking time for playback
     * @type {String}
     * @description start time properties. This is ISO type date string without millisecond.<br>
     *                    This value referece from {{@link SUNAPI 5.6 Timeline Search on Hanwha Techwin SUNAPI Application Programmers Guide}}
     * @example
     * var element = document.getElementsByTagName("ump-player");
     * element.seekTime = '2018-11-29T12:00:00Z';
     */

  }, {
    key: "seekingTime",
    get: function get() {
      return this._seekingTime;
    },
    set: function set(v) {
      this._seekingTime = v;

      if (this.isplay && this._seekingTime !== null && this._seekingTime !== undefined) {
        this.seeking();
      }
    }
    /**
     * Overlapped Id for playback function on NVR devices
     * @property {String} overlappedId Overlapped Id for playback function on NVR devices
     * @type {String}
     * @description overlappedId properties
     *                    This value referece from {{@link SUNAPI 5.5 Overlapped IDs on Hanwha Techwin SUNAPI Application Programmers Guide}}
     * @example
     *                    var element = document.getElementsById("ump-player");
     *                    element.overlappedId = '';
     */

  }, {
    key: "overlappedId",
    get: function get() {
      return this._overlappedId;
    },
    set: function set(v) {
      this._overlappedId = v;
    }
    /**
     * current timestamp on playback
     * @property {String} currentTimestamp current timestamp on playback
     * @type {String}
     * @description This is current timestamp on playback. This is ISO type date string without millisecond.<br>
     *                    This value referece from {{@link SUNAPI 5.6 Timeline Search on Hanwha Techwin SUNAPI Application Programmers Guide}}
     * @example
     * var element = document.getElementsByTagName("ump-player");
     * var timestamp = element.currentTimestamp;
     */

  }, {
    key: "currentTimestamp",
    get: function get() {
      return this._currentTimestamp;
    } // set currentTimestamp(v) {
    //   this._currentTimestamp = v;
    // }

    /**
     * hostname or ip address {mandatary}
     *
     * @example <ump-player id="ump-player" hostname="192.168.0.2">
     */

  }, {
    key: "hostname",
    get: function get() {
      return this._hostname;
    },
    set: function set(v) {
      this.setAttribute("hostname", v);
    }
    /**
     * channel number for NVR device or multi-channel camera {optional}
     *
     * @example <ump-player id="ump-player" channel="1">
     */

  }, {
    key: "channel",
    get: function get() {
      return this._channel;
    },
    set: function set(v) {
      this.setAttribute("channel", v);
    }
    /**
     * profile name. If this device type is Camera, this attribute is mandatory.
     * But, If this device type is NVR, this attribute is not mandatory. {mandatary}
     *
     * @example <ump-player id="ump-player" profile="H.264">
     */

  }, {
    key: "profile",
    get: function get() {
      return this._profile;
    },
    set: function set(v) {
      this.setAttribute("profile", v);
    }
    /**
     * camera profile number. If this device type is Camera, this attribute is not mandatory.
     * But, If this device type is NVR, this attribute is mandatory. {mandatary}
     *
     * @example <ump-player id="ump-player" profile_number="5">
     */

  }, {
    key: "profile_number",
    get: function get() {
      return this._profile_number;
    },
    set: function set(v) {
      this.setAttribute("profile_number", v);
    }
    /**
     * device type {mandatary: camera or nvr}
     *
     * @example <ump-player id="ump-player" device="camera">
     */

  }, {
    key: "device",
    get: function get() {
      return this._deviceType;
    },
    set: function set(v) {
      this.setAttribute("device", v);
    }
    /**
     * user account id for access to device {mandatary}
     *
     * @example <ump-player id="ump-player" username="<account id>">
     */

  }, {
    key: "username",
    get: function get() {
      return this._username;
    },
    set: function set(v) {
      this.setAttribute("username", v);
    }
    /**
     * user account password for access to device {mandatary}
     *
     * @example <ump-player id="ump-player" password="<account password>">
     */

  }, {
    key: "password",
    get: function get() {
      return this._password;
    },
    set: function set(v) {
      console.warn("This attribute is not safety. you would be recommand to use the sunapi client for your device safety.");
      this.setAttribute("password", v);
    }
    /**
     * iframe only request for video play {optional}
     *
     * @example <ump-player id="ump-player" iframe>
     */

  }, {
    key: "iframe",
    get: function get() {
      return this._iframe;
    },
    set: function set(v) {
      this.setAttribute("iframe", v);
    }
    /**
     * flags for control display {optional}
     *
     * @example <ump-player id="ump-player" controls>
     */

  }, {
    key: "controls",
    get: function get() {
      return this._controls;
    },
    set: function set(v) {
      this.setAttribute("controls", v);
    }
    /**
     * multicast option {optional}
     *
     * @example <ump-player id="ump-player" multicast>
     */

  }, {
    key: "multicast",
    get: function get() {
      return this._multicast;
    },
    set: function set(v) {
      this.setAttribute("multicast", v);
    }
    /**
     * width of HTML element {optional, but element can not be display }
     *
     * @example <ump-player id="ump-player" width="496">
     */

  }, {
    key: "width",
    get: function get() {
      return this._width;
    },
    set: function set(v) {
      this.setAttribute("width", v);
    }
    /**
     * height of HTML element {optional, but element can not be display }
     *
     * @example <ump-player id="ump-player" height="279">
     */

  }, {
    key: "height",
    get: function get() {
      return this._height;
    },
    set: function set(v) {
      this.setAttribute("height", v);
    }
    /**
     * return play state of HTML element {optional, but element can not be display }
     * @description return play state of ump player element
     * @property {boolean} isplay play state on play
     * @example
     *  var element = document.getElementsByTagName("ump-player");
     *  if(element.isplay) {
     *   console.log("playing");
     *  } else {
     *   console.log("stopped");
     *  }
     */

  }, {
    key: "isplay",
    get: function get() {
      return this.isPlay();
    }
    /**
     * return mute state of HTML element {optional, but element can not be display }
     * @description return mute state of ump player element
     * @property {boolean} ismute mute state on play
     * @example
     *  var element = document.getElementsByTagName("ump-player");
     *  if(element.ismute) {
     *   console.log("muted");
     *  } else {
     *   console.log("unmute");
     *  }
     */

  }, {
    key: "ismute",
    get: function get() {
      return this.isMute();
    }
    /**
     * Type of play state. live or palyback.
     * @property {String} readyState Type of play state
     * @type {Number}
     * @description The type of play state property. If play state changed, you can check state on live or playback<br>
     * @example
     *                    var element = document.getElementsById("ump-player");
     *                    if(element.readyState) {
     *                    }
     */

  }, {
    key: "readyState",
    get: function get() {
      return this._readyState;
    } // set readyState(v) {
    //   this._readyState = v;
    // }

    /**
     * playback speed
     * @property {UmpPlaySpeed} playSpeed The speed of play on playback
     * @description if you change speed on playback mode, you have to change the playSpeed property.
     *                    this property will be change speed automatically.
     * @example
     * var element = document.getElementsByTagName("ump-player");
     * var playSpeed = element.playSpeed;
     * element.playSpeed = 32;
     * element.playSpeed = '32x';
     */

  }, {
    key: "playSpeed",
    get: function get() {
      return this._playSpeed.value;
    },
    set: function set(v) {
      switch (Number(v)) {
        case UmpPlaySpeed.speed_0_25x.value:
        case UmpPlaySpeed.speed_0_25x.name:
          this._playSpeed = UmpPlaySpeed.speed_0_25x;
          break;

        case UmpPlaySpeed.speed_0_50x.value:
        case UmpPlaySpeed.speed_0_50x.name:
          this._playSpeed = UmpPlaySpeed.speed_0_50x;
          break;

        case UmpPlaySpeed.speed_0_75x.value:
        case UmpPlaySpeed.speed_0_75x.name:
          this._playSpeed = UmpPlaySpeed.speed_0_75x;
          break;

        case UmpPlaySpeed.speed_1x.value:
        case UmpPlaySpeed.speed_1x.name:
          this._playSpeed = UmpPlaySpeed.speed_1x;
          break;

        case UmpPlaySpeed.speed_2x.value:
        case UmpPlaySpeed.speed_2x.name:
          this._playSpeed = UmpPlaySpeed.speed_2x;
          break;

        case UmpPlaySpeed.speed_4x.value:
        case UmpPlaySpeed.speed_4x.name:
          this._playSpeed = UmpPlaySpeed.speed_4x;
          break;

        case UmpPlaySpeed.speed_8x.value:
        case UmpPlaySpeed.speed_8x.name:
          this._playSpeed = UmpPlaySpeed.speed_8x;
          break;

        case UmpPlaySpeed.speed_16x.value:
        case UmpPlaySpeed.speed_16x.name:
          this._playSpeed = UmpPlaySpeed.speed_16x;
          break;

        case UmpPlaySpeed.speed_32x.value:
        case UmpPlaySpeed.speed_32x.name:
          this._playSpeed = UmpPlaySpeed.speed_32x;
          break;

        case UmpPlaySpeed.speed_64x.value:
        case UmpPlaySpeed.speed_64x.name:
          this._playSpeed = UmpPlaySpeed.speed_64x;
          break;

        case UmpPlaySpeed.seek_0_25x.value:
        case UmpPlaySpeed.seek_0_25x.name:
          this._playSpeed = UmpPlaySpeed.seek_0_25x;
          break;

        case UmpPlaySpeed.seek_0_50x.value:
        case UmpPlaySpeed.seek_0_50x.name:
          this._playSpeed = UmpPlaySpeed.seek_0_50x;
          break;

        case UmpPlaySpeed.seek_0_75x.value:
        case UmpPlaySpeed.seek_0_75x.name:
          this._playSpeed = UmpPlaySpeed.seek_0_75x;
          break;

        case UmpPlaySpeed.seek_1x.value:
        case UmpPlaySpeed.seek_1x.name:
          this._playSpeed = UmpPlaySpeed.seek_1x;
          break;

        case UmpPlaySpeed.seek_2x.value:
        case UmpPlaySpeed.seek_2x.name:
          this._playSpeed = UmpPlaySpeed.seek_2x;
          break;

        case UmpPlaySpeed.seek_4x.value:
        case UmpPlaySpeed.seek_4x.name:
          this._playSpeed = UmpPlaySpeed.seek_4x;
          break;

        case UmpPlaySpeed.seek_8x.value:
        case UmpPlaySpeed.seek_8x.name:
          this._playSpeed = UmpPlaySpeed.seek_8x;
          break;

        case UmpPlaySpeed.seek_16x.value:
        case UmpPlaySpeed.seek_16x.name:
          this._playSpeed = UmpPlaySpeed.seek_16x;
          break;

        case UmpPlaySpeed.seek_32x.value:
        case UmpPlaySpeed.seek_32x.name:
          this._playSpeed = UmpPlaySpeed.seek_32x;
          break;

        case UmpPlaySpeed.seek_64x.value:
        case UmpPlaySpeed.seek_64x.name:
          this._playSpeed = UmpPlaySpeed.seek_64x;
          break;

        default:
          break;
      }

      this.speed();
    }
    /**
     * If camera or NVR was set https mode, you have to need secure channel mode.
     *
     * @example <ump-player id="ump-player" secure>
     */

  }, {
    key: "secure",
    get: function get() {
      return this._secure;
    },
    set: function set(v) {
      this.setAttribute("secure", v);
    }
    /**
     * height of HTML element {optional, but element can not be display }
     *
     * @example <ump-player id="ump-player" height="279">
     */

  }, {
    key: "src",
    get: function get() {
      return this._source;
    },
    set: function set(v) {
      this._source = v;
    }
    /**
     * use iso time format properties for playback
     * @property {Boolean} useIsoTimeFormat use iso time format properties for playback
     * @type {String}
     * @description use iso time format properties for playback
     * @example
     * var element = document.getElementsByTagName("ump-player");
     * element.useIsoTimeFormat = true;
     */

  }, {
    key: "useIsoTimeFormat",
    get: function get() {
      return this._useIso;
    },
    set: function set(v) {
      this._useIso = v;
    }
    /**
     * talk state
     * @property {boolean} isTalk State of Talk function
     * @type {String}
     * @description This property return state of talk function
     * @example
     * var element = document.getElementsByTagName("ump-player");
     * var stateOfTalk = element.isTalk;
     */

  }, {
    key: "isTalk",
    get: function get() {
      return this.info.media.audioOutStatus;
    }
    /**
     * capture filename {mandatary field to capture and backup}
     *
     * @example
     * var element = document.getElementsByTagName("ump-player");
     * element.filename = "capture.png";
     * element.capture();
     */

  }, {
    key: "filename",
    get: function get() {
      return this._filename;
    },
    set: function set(v) {
      this._filename = v;
    }
  }], [{
    key: "observedAttributes",
    get: function get() {
      return ["hostname", "channel", "profile", "profile_number", "device", "username", "password", "iframe", "controls", "multicast", "width", "height", "autoplay", "mode", "proxy", "port", "secure"];
    }
  }]);

  return UmpPlayer;
}(_wrapNativeSuper(HTMLElement)); // end class UmpPlayer


customElements.define("ump-player", UmpPlayer); //customElements.define("cctv", UmpPlayer);
//customElements.define("nvr", UmpPlayer);
//# sourceMappingURL=ump-player-compiled.js.map

// Create an object type UserException
// Creates user-defined exceptions
var umpError = (function() {
    'use strict';
    var version = '1.0.0';
    var log = log4javascript.getLogger();
  
    //constructor
    function umpError() {
      //enforces 'new' instance
      if (!(this instanceof umpError)) {
        return new umpError(arguments);
      }
      var error,
        //handles the arguments object when is passed by enforcing a 'new' instance
        args = Array.apply(null, typeof arguments[0] === 'object' ? arguments[0] : arguments),
        message;

        if(args.length !== 0) {
          message = args.shift() || 'An exception has occurred';
        } else {
          message = arguments[0].message;
        }
        //channel = arguments[0] === 'object' ? arguments[0].channelId: 0;
        var channel = arguments[0] !== 'object' ? arguments[0].channelId: 0;
        var element = arguments[0] !== 'object' ? arguments[0].elementId: '';
        var errCode = arguments[0] !== 'object' ? arguments[0].errorCode: 0;
        var place = arguments[0] !== 'object' ? arguments[0].place: '';
  
      //builds the message with multiple arguments
      if (~message.indexOf('}')) {
        args.forEach(function (arg, i) {
          message = message.replace(RegExp('\\{' + i + '}', 'g'), arg);
        });
      }

      //gets the exception stack
      error = new Error(message);
      //access to umpError.prototype.name
      error.name = this.name;
  
      //set the properties of the instance
      //in order to resemble an Error instance
      Object.defineProperties(this, {
        stack: {
          enumerable: false,
          get: function() { return error.stack; }
        },
        message: {
          enumerable: false,
          value: message
        },
        channel: {
          enumerable: false,
          value: channel
        },
        element: {
          enumerable: false,
          value: element
        },
        errorCode: {
          enumerable: false,
          value: errCode
        },
        place: {
          enumerable: false,
          value: place
        }
      });
    }
  
    // Creates the prototype and prevents the direct reference to Error.prototype;
    // Not used new Error() here because an exception would be raised here,
    // but we need to raise the exception when umpError instance is created.
    umpError.prototype = Object.create(Error.prototype, {
      //fixes the link to the constructor (ES5)
      constructor: setDescriptor(umpError),
      name: setDescriptor('UMP Error')
    });
  
    function setDescriptor(value) {
      return {
        configurable: false,
        enumerable: false,
        writable: false,
        value: value
      };
    }  
    //returns the constructor
    return umpError;
  }());
var StreamManager = (function () {
    "use strict"; 
    var version = '1.0.0';
	var log = log4javascript.getLogger('streammanager');

    var playerContainer = [];
    var player = null;
    var checkPlayer = false;

    function Constructor() {}

    Constructor.prototype = {
        /**
         * To create a stream player by channelId.
         * @function initStreamPlayer
         * @memberof StreamManager
         * @param {object} info Structrue which has device, callback, media infomation
         * @param {object} sunapiClient sunapiClient class object
         * @example
         *  manager.initStreamPlayer(info, sunapiClient);
         */
        initStreamPlayer: function (info, sunapiClient) {
            var id = (info.device.channelId === null) ? 0: info.device.channelId;
            checkPlayer = false;
            if (!playerContainer[id]) {
                player = new StreamPlayer(info, sunapiClient);
                playerContainer[id] = player;
                checkPlayer = true;
            } else {
                player = playerContainer[id];
                var controlData = {
                    'channelId':id, 
                    'cmd':'reassignCanvas', 
                    'data': null
                };
                player.controlWorker(controlData);
            }
        },
        /**
         * To send control command to player by channelId.
         * @function controlPlayer
         * @memberof StreamManager
         * @param {object} info Structrue which has device, callback, media infomation.
         * @example
         *  manager.controlPlayer(info);
         */
        controlPlayer: function (info) {
            var player,
                id = (info.device.channelId === null) ? 0: info.device.channelId;

            if (playerContainer[id]) {
                player = playerContainer[id];
                player.control(info);
            } else {
                log.error('ERROR: StreamPlayer is not initialized');
            }
        },
        /**
         * To send control command for workerManager to player by channelId.
         * @function controlWorker
         * @memberof StreamManager
         * @param {object} controlData object which has channelId, cmd, data.
         *  controlData = {'channelId':{int}, 'cmd':{string}, 'data': ['data1', 'data2', ...]}
         * @example
         *  manager.controlWorker(controlData);
         */
        controlWorker: function(controlData) {
            var player,
                id = (controlData.channelId === null) ? 0: controlData.channelId;

            if (playerContainer[id]) {
                player = playerContainer[id];
                player.controlWorker(controlData);
            } else {
                log.error('ERROR: StreamPlayer is not initialized controlWorker::cmd = ' + controlData.cmd);
            }
        },
        /**
         * To init  resize callback.
         * @function destroyPlayer
         * @memberof StreamManager
         * @example
         *  manager.destroyPlayer();
         */
        destroyPlayer: function(channelId){
            this.controlWorker({'channelId':channelId, 'cmd':'initVideo', 'data': [false]});
            this.controlWorker({'channelId':channelId, 'cmd':'setLiveMode', 'data': ["canvas"]});
            this.controlWorker({'channelId':channelId, 'cmd':'controlAudioListen', 'data': ['volumn', 0]});
            this.controlWorker({'channelId':channelId, 'cmd':'controlAudioTalk', 'data': ['volumn', 0]});
            playerContainer[channelId] = null;
        },
        /**
         * get current status.
         * @function getCurrentState
         * @memberof StreamManager
         * @example
         *  manager.getCurrentState();
         */
        getCurrentState: function(channelid){
            var player,
                id = (channelid === null) ? 0: channelid;

            if (playerContainer[id]) {
                player = playerContainer[id];
                return player.getCurrentState();
            } else {
                log.error('ERROR: StreamPlayer is not initialized');
            }
        },
        /**
         * get current video width.
         * @function getVideoWidth
         * @memberof StreamManager
         * @example
         *  manager.getVideoWidth();
         */
        getVideoWidth: function(channelid){
            var player,
                id = (channelid === null) ? 0: channelid;

            if (playerContainer[id]) {
                player = playerContainer[id];
                return player.getVideoWidth();
            } else {
                log.error('ERROR: StreamPlayer is not initialized');
            }

        },
        /**
         * get current video height.
         * @function getVideoHeight
         * @memberof StreamManager
         * @example
         *  manager.getVideoHeight();
         */
        getVideoHeight: function(channelid){
            var player,
                id = (channelid === null) ? 0: channelid;

            if (playerContainer[id]) {
                player = playerContainer[id];
                return player.getVideoHeight();
            } else {
                log.error('ERROR: StreamPlayer is not initialized');
            }
        },
        /**
         * get current video codec.
         * @function getVideoHeight
         * @memberof StreamManager
         * @example
         *  manager.getVideoHeight();
         */
        getVideoCodecType: function(channelid){
            var player,
                id = (channelid === null) ? 0: channelid;

            if (playerContainer[id]) {
                player = playerContainer[id];
                return player.getVideoCodecType();
            } else {
                log.error('ERROR: StreamPlayer is not initialized');
            }
        },
        /**
         * get current audio volume.
         * @function getAudioVolume
         * @memberof StreamManager
         * @example
         *  manager.getAudioVolume();
         */
        getAudioVolume: function(channelid){
            var player,
                id = (channelid === null) ? 0: channelid;

            if (playerContainer[id]) {
                player = playerContainer[id];
                return player.getAudioVolume();
            } else {
                log.error('ERROR: StreamPlayer is not initialized');
            }
        },
        /**
         * get current audio volume.
         * @function getAudioVolume
         * @param {number} channelId number of channel
         * @param {number} volume number of volume
         * @memberof StreamManager
         * @examples
         *  manager.setAudioVolume();
         */
        setAudioVolume: function(channelid, volume){
            var player,
                id = (channelid === null) ? 0: channelid;

            if (playerContainer[id]) {
                player = playerContainer[id];
                return player.setAudioVolume(volume);
            } else {
                log.error('ERROR: StreamPlayer is not initialized');
            }
        }
    };
    return Constructor;
})();
function StreamPlayer(configInfo, sunapiClient) {
  "use strict";
  var version = '1.0.0';
	var log = log4javascript.getLogger('streamplayer');

  var channelId = configInfo.device.channelId;

  var connectionInfo = {
    protocol: '',
    hostname: '',
    port: 80,
    proxy: ''
  };

  var profileInfo = {
    device: {
      cameraIp: '',
      hostname: '',
      username: 'admin',
      password: '',
      type: 'camera',
      digest: ''
    },
    media: {
      type: 'live',
      requestInfo: {
        cmd: 'open',
        url: 'profile2',
        scale: 1
      },
      framerate: 0,
      govLength: null,
      mode: null,
      checkDelay: true
    }
  };

  var timeInfo = { startTime: null, endTime: null, };

  var callbackInfo = {
    close: null,
    error: null,
    status: null,
    time: null,
    onResize: null,
    onMetaData: null,
    onVideoMode: null,
    onStatistics: null,
    onStepRequest: null,
    onCapture: null,
    onInstantPlayback: null,
    onBackup: null,
  };

  var rtspClient;
  var mediaRouter;
  var isValidBackupCheck = null;

  function Constructor(configInfo) {
    isValidBackupCheck = null;
    var transportType = configInfo.media.transportType;

    mediaRouter = new MediaRouter();
    mediaRouter.setChannel(configInfo.device.channelId);
    if(typeof configInfo.media.audioInVolume !== 'undefined') {
      mediaRouter.setAudioVolume(configInfo.media.audioInVolume);
    }
    if(typeof configInfo.media.instantPlaybackTime !== 'undefined') {
      mediaRouter.setMaxInstantPlaybackTime(configInfo.media.instantPlaybackTime);
    }
    if(typeof configInfo.media.bufferClearInterval !== 'undefined') {
      mediaRouter.setBufferClearInterval(configInfo.media.bufferClearInterval);
    }

    if(configInfo.media.element !== undefined) {
      mediaRouter.setElement(configInfo.media.element);
    }

    if(configInfo.media.drop !== null && configInfo.media.drop !== undefined && typeof configInfo.media.drop === 'boolean') {
      mediaRouter.useDropPacket(configInfo.media.drop);
    }

    rtspClient = new RtspClient(mediaRouter);
    rtspClient.SetSunapiClient(sunapiClient);
  }

  var open = function (info, audioOutStatus) {
    if (info !== null) {
      // if deviceType is not defined, default is camera
      if (info.device.deviceType !== undefined &&
        info.device.deviceType !== '' &&
        info.device.deviceType !== null) {
        profileInfo.device.type = info.device.deviceType;
      } else {
        console.warn("The device type is not defined, set to 'camera' by default.");
      }

      // check input parameter
      if (profileInfo.device.type === 'nvr' && (info.device.hostname === undefined ||
        info.device.hostname === '' && info.device.hostname === null)) {
        // if hostname is empty, throw invalid parameter
        throw new umpError({
          channelId: channelId,
          errorCode: fromHex('0x0401'),
          place: 'streamPlayer.js:102',
          message: "hostname is empty from input parameter."
        });
      } else if (profileInfo.device.type === 'camera' && (info.device.cameraIp === undefined ||
        info.device.cameraIp === '' || info.device.cameraIp === null)) {
        // if cameraIp is empty, throw invalid parameter
        throw new umpError({
          channelId: channelId,
          errorCode: fromHex('0x0400'),
          place: 'streamPlayer.js:111',
          message: "cameraIP is empty from input parameter."
        });
      }

      connectionInfo.protocol = info.device.protocol;
      connectionInfo.hostname = info.device.hostname;
      connectionInfo.port = info.device.port;
      connectionInfo.ClientIPAddress = info.device.ClientIPAddress;
      if(info.device.serverAddress !== null && info.device.serverAddress !== undefined && info.device.serverAddress !== '') {
        connectionInfo.proxy = info.device.serverAddress;
      } else if (info.device.proxy !== null && info.device.proxy !== undefined && info.device.proxy !== '') {
        connectionInfo.proxy = info.device.proxy;
      }

      profileInfo.device.cameraIp = info.device.cameraIp;
      if(typeof info.device.username !== 'undefined') {
        profileInfo.device.username = info.device.username;
      } else if(typeof info.device.user !== 'undefined') {
        profileInfo.device.username = info.device.user;
      } else {
        throw new umpError({
          channelId: channelId,
          errorCode: fromHex('0x0402'),
          place: 'streamPlayer.js:96',
          message: "username is empty from input parameter."
        });
      }
      if(info.device.password !== undefined) {
        profileInfo.device.password = info.device.password;
      } else {
        console.warn("user password is empty");
      }

      profileInfo.media.type = info.media.type;
      profileInfo.media.requestInfo.cmd = info.media.requestInfo.cmd;
      profileInfo.media.requestInfo.url = info.media.requestInfo.url;
      profileInfo.media.requestInfo.scale = info.media.requestInfo.scale;
      profileInfo.media.element = info.media.element;
      profileInfo.media.framerate = info.media.framerate;
      profileInfo.media.govLength = info.media.govLength;
      profileInfo.media.mode = info.media.mode;
      if ( typeof profileInfo.media.mode !== 'undefined' && profileInfo.media.mode !== null) {
        changeVideoMode(profileInfo.media.mode);
      }
      profileInfo.media.requestInfo.rangeClock = info.media.requestInfo.rangeClock;
      profileInfo.media.checkDelay = (info.media.checkDelay === undefined ? true : false);
      profileInfo.device.digest = info.device.digest;

      if (info.media.audioOutStatus) {
        profileInfo.media.audioOutStatus = 'on';
      } else if (!info.media.audioOutStatus) {
        profileInfo.media.audioOutStatus = 'off';
      }

      if (info.media.type === 'backup') {
        isValidBackupCheck = false;
      }

      if(info.media.boxsize !== undefined && info.media.boxsize !== null) {
        profileInfo.media.boxsize = info.media.boxsize;
      }

      callbackInfo.status = info.callback.status;
      callbackInfo.error = info.callback.error;
      callbackInfo.time = info.callback.time;
      callbackInfo.onResize = info.callback.resize;
      callbackInfo.onMetaData = info.callback.meta;
      callbackInfo.onVideoMode = info.callback.vmode;
      callbackInfo.onStatistics = info.callback.statistics;
      callbackInfo.onStepRequest = info.callback.step;
      callbackInfo.onCapture = info.callback.capture;
      callbackInfo.onInstantPlayback = info.callback.instantplayback;
      callbackInfo.onBackup = info.callback.backup;
      close();
      startStreaming();

      if (info.media.type === 'backup') {
        var backup_callback;
        if(callbackInfo.onBackup !== null && callbackInfo.onBackup !== undefined) {
          backup_callback = callbackInfo.onBackup;
        } else {
          backup_callback = callbackInfo.error;
        }

        mediaRouter.sendCommandData('backup', {
          'command': 'start',
          'fileName': info.device.captureName,
          'callback': backup_callback
        });
        // workerManager.backup('backupstart', info.device.captureName, info.callback.error);
        isValidBackupCheck = true;
      }
    } else {
      profileInfo.media.audioOutStatus = audioOutStatus;
      close();
      startStreaming();
    }
  };

  function startStreaming() {
    var deviceIp;
    var addr;
    if(profileInfo.device.type === 'camera') {
      deviceIp = connectionInfo.hostname ? connectionInfo.hostname : profileInfo.device.cameraIp;
    } else if (profileInfo.device.type === 'nvr') {
      deviceIp = connectionInfo.hostname ? connectionInfo.hostname : profileInfo.device.hostname;
    } else {
      deviceIp = connectionInfo.hostname ? connectionInfo.hostname : profileInfo.device.cameraIp;
    }
    var port = (connectionInfo.port == "") ? connectionInfo.port : (":" + connectionInfo.port);
    var protocol = (connectionInfo.protocol == "http" || connectionInfo.protocol === undefined || connectionInfo.protocol == "") ? "ws://" : "wss://";
    var rtspUrl = 'rtsp://' + deviceIp + '/' + profileInfo.media.requestInfo.url;
    //var rtspUrl = 'rtsp://'+profileInfo.device.user+':'+profileInfo.device.password+'@'+profileInfo.device.cameraIp+'/'+profileInfo.media.requestInfo.url;
    var address;
    var pathName = window.location.pathname;
    if (pathName !== "/") {
      pathName = pathName.replace("/index.html", "/");
      pathName = pathName.replace("/wmf", "");

      var n = pathName.lastIndexOf("/");
      pathName = pathName.substr(0 , n);
    }

    if (((navigator.userAgent.indexOf("Trident") != -1) || (navigator.userAgent.indexOf("Edge") != -1)) && (connectionInfo.proxy.indexOf(':') != -1)) { // if IE,Edge and IPv6 addr
      if(connectionInfo.proxy !== '') {
        addr = connectionInfo.proxy + '' + port;
      } else {
        addr = deviceIp + '' + port;
      }
      addr = addr.replace(/:/gi, "-");
      addr = addr.replace(/::/gi, "--");
      addr = addr.replace("[", "");
      addr = addr.replace("]", "");
      addr = addr + ".ipv6-literal.net";
      address = protocol + addr + "/StreamingServer" + pathName;
    } else {
      if(connectionInfo.proxy !== '') {
        address = protocol + connectionInfo.proxy + port + "/StreamingServer" + pathName;
      } else {
        address = protocol + deviceIp + port + "/StreamingServer" + pathName;
      }
    }

    var deviceInfo = {
      wsUrl: address,
      id: profileInfo.device.username,
      pw: profileInfo.device.password,
      rtspUrl: rtspUrl,
      mode: profileInfo.media.type,
      deviceType: profileInfo.device.type,
      useragent: "UWC[" + connectionInfo.ClientIPAddress + "]",
      audioOutStatus: profileInfo.media.audioOutStatus,
      ip: deviceIp,
      channelId: channelId,
      rangeClock: profileInfo.media.requestInfo.rangeClock,
      scale: profileInfo.media.requestInfo.scale,
      digest: profileInfo.device.digest
    };
    rtspClient.SetDeviceInfo(deviceInfo);
    // workerManager.init(deviceInfo);
    window.setTimeout(function () {
      log.info("Open ", channelId, " Channel!");

      // add event listener
      if(callbackInfo.error !== null && callbackInfo.error !== undefined) {
        rtspClient.addEventListener('error', callbackInfo.error);
        mediaRouter.addListener('error', callbackInfo.error);
      }

      if(callbackInfo.status !== null && callbackInfo.status !== undefined) {
        rtspClient.addEventListener('status', callbackInfo.status);
      }

      if(callbackInfo.time !== null && callbackInfo.time !== undefined) {
        mediaRouter.addListener('timeStamp', callbackInfo.time);
      }

      if(callbackInfo.onResize !== null && callbackInfo.onResize !== undefined) {
        mediaRouter.addListener('resize', callbackInfo.onResize);
      }

      if(callbackInfo.onMetaData !== null && callbackInfo.onMetaData !== undefined) {
        mediaRouter.addListener('metaEvent', callbackInfo.onMetaData);
      }

      if(callbackInfo.onVideoMode !== null && callbackInfo.onVideoMode !== undefined) {
        mediaRouter.addListener('videoMode', callbackInfo.onVideoMode);
      }

      if(callbackInfo.onStepRequest !== null && callbackInfo.onStepRequest !== undefined) {
        mediaRouter.addListener('stepRequest', callbackInfo.onStepRequest);
      }

      if(callbackInfo.onStatistics !== null && callbackInfo.onStatistics !== undefined) {
        mediaRouter.addListener('statistics', callbackInfo.onStatistics);
      }

      if(callbackInfo.onCapture !== null && callbackInfo.onCapture !== undefined) {
        mediaRouter.addListener('capture', callbackInfo.onCapture);
      }

      if(callbackInfo.onInstantPlayback !== null && callbackInfo.onInstantPlayback !== undefined) {
        mediaRouter.addListener('instantplayback', callbackInfo.onInstantPlayback);
      }

      if(profileInfo.media.boxsize !== null && profileInfo.media.boxsize !== undefined) {
        mediaRouter.setBoxSize(profileInfo.media.boxsize);
      }

      // set device type
      mediaRouter.setDeviceType(profileInfo.device.type);
      // workerManager.setCallback('error', callbackInfo.error);
      // workerManager.setCallback('timeStamp', callbackInfo.time);
      // workerManager.SetDeviceInfo(deviceInfo);
      // workerManager.setFPS(profileInfo.media.framerate);
      // workerManager.setGovLength(profileInfo.media.govLength);
      // workerManager.setLiveMode(profileInfo.media.mode);
      // workerManager.setCheckDelay(profileInfo.media.checkDelay);

      rtspClient.Connect();
    }, 500);

  }

  function close(info) {
    log.info("Close ", channelId, "Channel!");
    rtspClient.Disconnect();
    if (isValidBackupCheck === true) {
      mediaRouter.sendCommandData('backup', {
        'command': 'stop'
      });
    }
    if (typeof info !== 'undefined') {
      changeVideoMode(null);
    }
    mediaRouter.terminate();
    // workerManager.terminate();
  }

  function terminate() {
    throw new umpError({
      channelId: channelId,
      errorCode: fromHex('0x090A'),
      place: 'streamPlayer.js:347',
      message: "this method was deplicated."
    });

    // profileInfo.media.requestInfo.cmd = 'close';
    // rtspClient.ControlStream(profileInfo);
    //rtspClient.Disconnect();
  }

  function resume(info) {
    mediaRouter.sendCommandData('resume', info.media.needToImmediate);
    // workerManager.playbackResume();
    if (info.media.streamControl === true ) {
      return;
    }
    profileInfo.media.type = info.media.type;
    profileInfo.media.requestInfo.cmd = 'resume';
    profileInfo.media.requestInfo.url = "rtsp://" + profileInfo.device.cameraIp + ":554" + "/" + info.media.requestInfo.url;
    profileInfo.media.requestInfo.scale = info.media.requestInfo.scale;
    profileInfo.media.needToImmediate = info.media.needToImmediate;
    if(info.media.requestInfo.rangeClock !== null && info.media.requestInfo.rangeClock !== undefined) {
      profileInfo.media.requestInfo.rangeClock = info.media.requestInfo.rangeClock;
    }

    // if play type is 'live', set to false the instant playback mode
    if(info.media.type === 'live') {
      rtspClient.instantplayback = false;
    }

    rtspClient.ControlStream(profileInfo);
  }

  function pause(info) {
    var result = mediaRouter.sendCommandData('pause');
    // workerManager.playbackPause();
    if (result === false) {
      window.setTimeout(function () {
        pause(info);
      }, 1000);
      return;
    }
    if ( info.media.streamControl === true ) {
      return;
    }
    profileInfo.media.type = info.media.type;
    profileInfo.media.requestInfo.cmd = 'pause';
    profileInfo.media.requestInfo.url = "rtsp://" + profileInfo.device.cameraIp + ":554" + "/" + info.media.requestInfo.url;
    profileInfo.media.needToImmediate = info.media.needToImmediate;
    if(info.media.requestInfo.rangeClock !== null && info.media.requestInfo.rangeClock !== undefined) {
      profileInfo.media.requestInfo.rangeClock = info.media.requestInfo.rangeClock;
    }

    // if play type is 'live', set to true the instant playback mode
    if(info.media.type === 'live') {
      rtspClient.instantplayback = true;
    }
    rtspClient.ControlStream(profileInfo);
  }

  function speed(info) {
    var type = profileInfo.media.type;
    if (type === 'live') {
      log.warning("speed is invalid command in live");
      return;
    }
    profileInfo.media.type = info.media.type;
    profileInfo.media.requestInfo.cmd = 'speed';
    profileInfo.media.requestInfo.scale = info.media.requestInfo.scale;
    profileInfo.media.requestInfo.url = "rtsp://" + profileInfo.device.cameraIp + ":554" + "/" + info.media.requestInfo.url;
    profileInfo.media.requestInfo.rangeClock = info.media.requestInfo.rangeClock;
    profileInfo.media.needToImmediate = info.media.needToImmediate;
    if(info.media.requestInfo.rangeClock !== null && info.media.requestInfo.rangeClock !== undefined) {
      profileInfo.media.requestInfo.rangeClock = info.media.requestInfo.rangeClock;
    }

    rtspClient.ControlStream(profileInfo);

    playbackSpeed(info.media.requestInfo.scale);
  }

  function seek(info) {
    var type = profileInfo.media.type;
    if (type === 'live') {
      console.log(cmd, "is invalid command in live");
      return;
    }
    /*
    Todo : call webaudio flushBuffer
    webAudio.flushBuffer();
    */
    profileInfo.media.type = info.media.type;
    profileInfo.media.requestInfo.cmd = 'seek';
    profileInfo.media.requestInfo.scale = info.media.requestInfo.scale;
    profileInfo.media.requestInfo.url = "rtsp://" + profileInfo.device.cameraIp + ":554" + "/" + info.media.requestInfo.url;
    profileInfo.media.requestInfo.rangeClock = info.media.requestInfo.rangeClock;
    profileInfo.media.needToImmediate = info.media.needToImmediate;
    if(info.media.requestInfo.rangeClock !== null && info.media.requestInfo.rangeClock !== undefined) {
      profileInfo.media.requestInfo.rangeClock = info.media.requestInfo.rangeClock;
    }

    rtspClient.ControlStream(profileInfo);

    if (info.media.requestInfo.scale !== 1) {
      playbackSpeed(info.media.requestInfo.scale);
    }

    playbackSeek();
  }

  function stepRequest(info) {
    profileInfo.media.type = info.media.type;
    profileInfo.media.requestInfo.cmd = 'seek';
    profileInfo.media.requestInfo.scale = info.media.requestInfo.scale;
    profileInfo.media.requestInfo.url = "rtsp://" + profileInfo.device.cameraIp + ":554" + "/" + info.media.requestInfo.url;
    rtspClient.ControlStream(profileInfo);
  }

  function backward(info) {
    mediaRouter.sendCommandData('backward');

    if(info.device.deviceType === 'nvr') {
        if (info !== undefined) {
          profileInfo.media.type = info.media.type;
          profileInfo.media.requestInfo.cmd = 'backward';
          profileInfo.media.requestInfo.url = "rtsp://" + profileInfo.device.cameraIp + ":554" + "/" + info.media.requestInfo.url;
          profileInfo.media.requestInfo.rangeClock = info.media.requestInfo.rangeClock;
          profileInfo.media.needToImmediate = info.media.needToImmediate;
          profileInfo.media.requestInfo.scale = info.media.requestInfo.scale;

          rtspClient.ControlStream(profileInfo);
        }
      }
  }

  function forward(info) {
    mediaRouter.sendCommandData('forward');

    if(info.device.deviceType === 'nvr') {
      if (info !== undefined) {
        profileInfo.media.type = info.media.type;
        profileInfo.media.requestInfo.cmd = 'forward';
        profileInfo.media.requestInfo.url = "rtsp://" + profileInfo.device.cameraIp + ":554" + "/" + info.media.requestInfo.url;
        profileInfo.media.requestInfo.rangeClock = info.media.requestInfo.rangeClock;
        profileInfo.media.needToImmediate = info.media.needToImmediate;
        profileInfo.media.requestInfo.scale = info.media.requestInfo.scale;

        rtspClient.ControlStream(profileInfo);
      }
    }
  }

  function step(info) {
    playbackSpeed(1);
    profileInfo.media.type = info.media.type;
    profileInfo.media.requestInfo.cmd = 'seek';
    profileInfo.media.requestInfo.scale = info.media.requestInfo.scale;
    profileInfo.media.requestInfo.url = "rtsp://" + profileInfo.device.cameraIp + ":554" + "/" + info.media.requestInfo.url;
    rtspClient.ControlStream(profileInfo);
  }

  function backup(info) {
    if (info.media.type === 'live') {
      var backup_callback;
      if(callbackInfo.onBackup !== null && callbackInfo.onBackup !== undefined) {
        backup_callback = callbackInfo.onBackup;
      } else {
        backup_callback = callbackInfo.close;
      }

      mediaRouter.sendCommandData('backup', {
        'command': info.media.requestInfo.cmd==='backupstart' ?
                  'start' : 'stop',
        'fileName': info.device.captureName,
        'callback': backup_callback
      });
      // workerManager.backup(info.media.requestInfo.cmd, info.device.captureName, info.callback.close, false);
      isValidBackupCheck = true;
    } else if (info.media.type === 'backup') {
      //TODO : open websocket
      open(info);
    }
  }

  function capture(info) {
    // workerManager.capture(info.device.captureName);
    mediaRouter.sendCommandData(info.media.requestInfo.cmd, info.device.captureName);
  }

  function digitalZoom(info) {
    mediaRouter.sendCommandData('digitalZoom', info.media.requestInfo.data);
  }

  function controlAudioIn(info) {
    var data = info.media.requestInfo.data;
    mediaRouter.sendCommandData("audioIn", data);
  }

  function controlAudioOut(info) {
    var data = info.media.requestInfo.data;
    if (data === 'on' || data === 'off') {
      open(null, data);
      // workerManager.controlAudioTalk('onOff', data);
    } else {
      // workerManager.controlAudioTalk('volumn', data);
    }
  }

  function changeStackCount(info) {
    var data = info.media.requestInfo.data;
    data = parseInt(data, 10);
    // workerManager.setStackCount(data);
  }

  function updateMinimap(info) {
    mediaRouter.sendCommandData('minimap', info.media.requestInfo.data);
  }

  function setCallback(dataArray) {
    if (dataArray.length === 2) {
      mediaRouter.addListener(dataArray[0], dataArray[1]);
    } else {
      mediaRouter.addListener(dataArray[0], dataArray[1], dataArray[2]);
    }
  }

  function timeStamp(dataArray) {
    // workerManager.timeStamp(dataArray[0]);
  }

  function initVideo(dataArray) {
    // workerManager.initVideo(dataArray[0]);
  }

  function playbackSpeed(speed) {
    mediaRouter.sendCommandData('speed', speed);
    // workerManager.playbackSpeed(speed);
  }

  function setLiveMode(dataArray) {
    // workerManager.setLiveMode(dataArray[0]);
  }

  function openFPSmeter(dataArray) {
    // workerManager.openFPSmeter();
  }

  function closeFPSmeter(dataArray) {
    // workerManager.closeFPSmeter();
  }

  function setFpsFrame(dataArray) {
    // workerManager.setFpsFrame(dataArray[0]);
  }

  function playbackSeek(dataArray) {
    mediaRouter.sendCommandData('seek');
    // workerManager.playbackSeek();
  }

  function playToggle(dataArray) {
    // workerManager.playToggle(dataArray[0]);
  }

  function setPlaybackservice(dataArray) {
    // workerManager.setPlaybackservice(dataArray[0]);
  }

  function reassignCanvas() {
    // workerManager.reassignCanvas();
  }

  function clearBuffer() {
    mediaRouter.sendCommandData('clearBuffer');
  }

  function changeVideoMode(data) {
    mediaRouter.sendCommandData('changeVideoMode', data);
  }

  function checkRequestTimeChanged(info) {
    var arr = info.url.split("/");
    if (arr[0] !== "recording" || arr.length < 2) {
      return;
    }
    arr = arr[1].split("-");
    var startTime = arr[0], endTime = arr.length > 1 ? arr[1] : null;
    if (startTime !== timeInfo.startTime || endTime !== timeInfo.endTime) {
      timeInfo.startTime = startTime;
      timeInfo.endTime = endTime || info.endTime;
      mediaRouter.sendCommandData('requestTimeChanged', timeInfo);
    }
  }

  Constructor.prototype = {
    /**
     * To excute control command.
     * @function control
     * @memberof StreamPlayer
     * @param {object} info Structrue which has device, callback, media infomation.<br>
     *  info.media.requestInfo.cmd :<br> 'open', 'close', 'terminate', 'resume', 'pause', 'speed',
     *    'seek', 'capture', 'digitalZoom', 'controlAudioIn', 'controlAudioOut', 'forward', 'backward',
     *    'step', 'backup', 'backupstart', 'backupstop', 'changeStackCount'
     * @example
     *  player.control(info);
     */
    control: function (info) {
      var controlType = info.media.requestInfo.cmd;

      if (typeof info === "undefined") {
        console.log('info is undefined!');
      }
      if (typeof info.callback !== "undefined" && typeof info.callback.error !== "undefined") {
        rtspClient.SetErrorCallback(info.callback.error);
      }
      if (typeof info.callback !== "undefined" && typeof info.callback.close !== "undefined") {
      //   closeCallback = info.callback.close;
      }
      if (info.media.requestInfo.url !== null && typeof info.media.requestInfo.url !== "undefined") {
        checkRequestTimeChanged(info.media.requestInfo);
      }

      switch (controlType) {
        case 'open':
          open(info);
          break;
        case 'close':
          close(info);
          break;
        case 'terminate':
          terminate();
          break;
        case 'resume':
          resume(info);
          break;
        case 'pause':
          pause(info);
          break;
        case 'speed':
          speed(info);
          break;
        case 'seek':
          seek(info);
          break;
        case 'capture':
          capture(info);
          break;
        case 'dZoom':
          digitalZoom(info);
          break;
        case 'audioIn':
          controlAudioIn(info);
          break;
        case 'audioOut':
          controlAudioOut(info);
          break;
        case 'forward':
          forward(info);
          break;
        case 'backward':
          backward(info);
          break;
        case 'step':
          step(info);
          break;
        case 'backup':
        case 'backupstart':
        case 'backupstop':
          backup(info);
          break;
        case 'changeStackCount':
          changeStackCount(info);
          break;
        case 'minimap':
          updateMinimap(info);
          break;
        default:
          console.log('Not Supported Commnad');
          break;
      }
    },
    /**
     * To send control command to workerManager.
     * @function controlWorker
     * @memberof StreamPlayer
     * @param {object} controlData object which has channelId, cmd, data.<br>
     *  {'channelId':{int}, 'cmd':{string}, 'data': ['data1', 'data2', ...]}<br>
     *  cmd : 'setCallback', 'timeStamp', 'initVideo', 'playbackSpeed', 'setLiveMode',
     *    'openFPSmeter', 'closeFPSmeter', 'setFpsFrame', 'playbackSeek', 'playToggle',
     *    'setPlaybackservice', 'reassignCanvas'
     * @example
     *  player.controlWorker(controlData);
     */
    controlWorker: function (controlData) {
      var controlType = controlData.cmd;

      switch (controlType) {
        case 'setCallback':
          setCallback(controlData.data);
          break;
        case 'timeStamp':
          timeStamp(controlData.data);
          break;
        case 'initVideo':
          initVideo(controlData.data);
          break;
        case 'playbackSpeed':
          playbackSpeed(controlData.data);
          break;
        case 'setLiveMode':
          setLiveMode(controlData.data);
          break;
        case 'openFPSmeter':
          openFPSmeter(controlData.data);
          break;
        case 'closeFPSmeter':
          closeFPSmeter(controlData.data);
          break;
        case 'setFpsFrame':
          setFpsFrame(controlData.data);
          break;
        case 'playbackSeek':
          playbackSeek(controlData.data);
          break;
        case 'playToggle':
          playToggle(controlData.data);
          break;
        case 'setPlaybackservice':
          setPlaybackservice(controlData.data);
          break;
        case 'reassignCanvas':
          reassignCanvas();
          break;
        case 'clearBuffer':
          clearBuffer();
          break;
        case 'changeVideoMode':
          changeVideoMode(controlData.data);
          break;
        default:
          log.error("undefined command: [" + controlType + "]");
          break;
      }
    },
    getCurrentState: function () {
      return rtspClient.getCurrentState();
    },
    getVideoWidth: function () {
      return mediaRouter.getVideoWidth();
    },
    getVideoHeight: function () {
      return mediaRouter.getVideoHeight();
    },
    getVideoCodecType: function () {
      return mediaRouter.getVideoCodecType();
    },
    isMute: function() {
      return mediaRouter.mute;
    },
    getAudioVolume: function() {
      return mediaRouter.getAudioVolume();
    },
    setAudioVolume: function(volume) {
      mediaRouter.setAudioVolume(volume);
    }
  };
  /* Prototype Pattern*/

  return new Constructor(configInfo);
}
function AudioDecoder() {
	"use strict";
	function Constructor() {
		Constructor.prototype.channelId = 0;
	}

	Constructor.prototype = {
    setChannel: function (channelid) {
      Constructor.prototype.channelId = (channelid === null ? 0 : channelid);
    },
    getChannel: function() {
      return Constructor.prototype.channelId;
    },		
		decode: function(buffer) {},
		close: function() {}
	};

	return new Constructor();
}
function AACAudioDecoder() {
	"use strict";
	
	//decoder function variables
	var initDecoder = null;
	var decodeAacByFfmpeg = null;
	var closeContext = null;
	var outpicsize = 4096;

	//common variables
	var context = null;
	var outpic = new Float32Array();

	// var bufferSize = 0;
	// var saveBuffer = new Uint8Array(1000000);

	function Constructor() {
		console.log('Construct AAC Codec');

		initDecoder = Module.cwrap('init_aac_jsFFmpeg', 'void', []);
		decodeAacByFfmpeg = Module.cwrap('decode_aac_jsFFmpeg', 'number', ['number', 'array', 'number', 'number', 'number']);
		closeContext = Module.cwrap('close_jsFFmpeg', 'number', ['number']);

		Constructor.prototype.init();
	}

	Constructor.prototype = inheritObject(new AudioDecoder(),{
		/**
		 * This function is init AACAudioDecoder(asm.js decoder).
		 * @function init
		 * @memberof AACAudioDecoder
		 * @example
		 *     example: AACAudioDecoder.init();
		 */
		init: function () {
			console.log("AAC Decoder init");
			if (context !== null) {
				closeContext(context);
				context = null;
			}
			context = initDecoder();

			var outpicptr = Module._malloc(outpicsize);
			outpic = new Float32Array(Module.HEAPF32.buffer, outpicptr, outpicsize);
		},
		/**
		 * This function is decode frame.
		 * @function decode
		 * @memberof AACAudioDecoder
		 * @example
		 *     example: AACAudioDecoder.decode();
		 */
		decode: function (buffer) {
			if (context === null) return null;

			decodeAacByFfmpeg(context, buffer, buffer.length, outpic.byteOffset, outpicsize);
			var rawData = new Float32Array(outpic);
			// if(bufferSize > saveBuffer.length){
			// 	var blob = new Blob([saveBuffer], {type: "application/octet-stream"});
			// 	saveAs(blob, "test.aac");
			// }else{
			// 	if (!(bufferSize+rawData.length > saveBuffer.length)) {
			// 		saveBuffer.set(rawData,bufferSize);
			// 	}
			// }
			// bufferSize += rawData.length;
			var pcmData = new Float32Array(1024);
			pcmData.set(rawData.subarray(0,1024),0);

			return pcmData;
		},
		/**
		 * This function is to close asmjs context.
		 * @function close
		 * @memberof AACAudioDecoder
		 * @example
		 *     example: AACAudioDecoder.close();
		 */		
		close: function() {
			if (context !== null) {
				closeContext(context);
				context = null;
			}
		}
	});

	return new Constructor();
}
function G711AudioDecoder() {
	"use strict";

	var BIAS   =  0x84,
	SIGN_BIT  =  0x80, /* Sign bit for a A-law byte. */
	QUANT_MASK = 0xf,  /* Quantization field mask. */
	NSEGS    =   8,   /* Number of A-law segments. */
	SEG_SHIFT =  4,   /* Left shift for segment number. */
	SEG_MASK  =  0x70;  /* Segment field mask. */
	/* var codecInfo = {
		type: "G.711",
		samplingRate : 8000,
		bitrate : '64000'
	}; */

	function ulaw2linear_pcm(u_val) {
		var t;
		/* Complement to obtain normal u-law value. */
		var u_valc = ~u_val;
		/*
	* Extract and bias the quantization bits. Then
	* shift up by the segment number and subtract out the bias.
	*/
		t = ((u_valc & QUANT_MASK) << 3) + BIAS;
		t <<= (u_valc & SEG_MASK) >> SEG_SHIFT;
		return (((u_valc & SIGN_BIT)) ? (BIAS - t) : (t - BIAS));
	}

	function Constructor() {}

	Constructor.prototype = inheritObject(new AudioDecoder(),{
		decode: function(buffer){
			var rawData = new Uint8Array(buffer);
			var pcmData = new Int16Array(rawData.length);
			for (var i=0, rawData_length = rawData.length; i < rawData_length; i++) {
				pcmData[i]= ulaw2linear_pcm(rawData[i]);
			}
			
			var jsData = new Float32Array(pcmData.length);
			for (var j = 0, pcmData_length = pcmData.length; j < pcmData_length; j++) {
				/* var a1 = pcmData[j]/Math.pow(2,15);
				var a2 = Math.round(a1*100000) / 100000;
				jsData[j] = a2; */
				jsData[j] = pcmData[j] / Math.pow(2,15);
			}
			return jsData;
		}
	});

	return new Constructor();
}


function G726_16_AudioDecoder() {
  "use strict";
  
  var AUDIO_ENCODING_ULAW = 1; /* ISDN u-law */
  var AUDIO_ENCODING_ALAW = 2; /* ISDN A-law */
  var AUDIO_ENCODING_LINEAR = 3; /* PCM 2's-complement (0-center) */

  /*
   * Maps G.723_16 code word to reconstructed scale factor normalized log
   * magnitude values.  Comes from Table 11/G.726
   */
  var _dqlntab = [116, 365, 365, 116]; //short

  /* Maps G.723_16 code word to log of scale factor multiplier.
   *
   * _witab[4] is actually {-22 , 439, 439, -22}, but FILTD wants it
   * as WI << 5  (multiplied by 32), so we'll do that here 
   */
  var _witab = [-704, 14048, 14048, -704]; //short

  /*
   * Maps G.723_16 code words to a set of values whose long and short
   * term averages are computed and then compared to give an indication
   * how stationary (steady state) the signal is.
   */

  /* Comes from FUNCTF */
  var _fitab = [0, 0xE00, 0xE00, 0]; // short

  /* Comes from quantizer decision level tables (Table 7/G.726)
   */
  var qtab_723_16 = [1]; // int 
  var g726_state = {};
  var commonAudioUtil = null;

  //i(int), out_coding(int) 
  function g726_16_decode(i, out_coding) {
    var   sezi; //int
    var   sez;//int     /* ACCUM */
    var   sei;//int
    var   se;//int
    var   y;//int       /* MIX */
    var   dq;//int
    var   sr;//int        /* ADDB */
    var   dqsez;//int

    i &= 0x03;        /* mask to get proper bits */
    sezi = commonAudioUtil.predictor_zero(g726_state);
    sez = sezi >> 1;
    sei = sezi + commonAudioUtil.predictor_pole(g726_state);
    se = sei >> 1;      /* se = estimated signal */

    y = commonAudioUtil.step_size(g726_state); /* dynamic quantizer step size */

    dq = commonAudioUtil.reconstruct(i & 0x02, _dqlntab[i], y); /* quantized diff. */

    sr = (dq < 0) ? (se - (dq & 0x3FFF)) : se + dq; /* reconst. signal */

    dqsez = sr - se + sez;      /* pole prediction diff. */

    g726_state = commonAudioUtil.update(2, y, _witab[i], _fitab[i], dq, sr, dqsez, g726_state);

    switch (out_coding) {
      // case AUDIO_ENCODING_ALAW:
      //   return (commonAudioUtil.tandem_adjust_alaw(sr, se, y, i, 2, qtab_723_16));
      // case AUDIO_ENCODING_ULAW:
      //   return (commonAudioUtil.tandem_adjust_ulaw(sr, se, y, i, 2, qtab_723_16));
      case AUDIO_ENCODING_LINEAR:
        return (sr << 2); /* sr was of 14-bit dynamic range */
      default:
        return (-1);
    }
  }

  function Constructor() {
    commonAudioUtil = new CommonAudioUtil();
    g726_state = commonAudioUtil.g726_init_state();    
  }

  Constructor.prototype = inheritObject(new AudioDecoder(),{
    decode: function(buffer) {
      var decodedBuffer = new Int16Array(buffer.length * 4);
      for(var i = 0, buffer_length = buffer.length, n = 0; i < buffer.length; i++) {
        var res;
        var data;
        data = buffer[i] >> 6;
        res = g726_16_decode(data, AUDIO_ENCODING_LINEAR);
        // decodedBuffer[n] = (res & 0x000000ff);
        // n++;
        decodedBuffer[n] = (res & 0x0000ff00);
        n++;

        data = buffer[i] >> 4;
        res = g726_16_decode(data, AUDIO_ENCODING_LINEAR);
        // decodedBuffer[n] = (res & 0x000000ff);
        // n++;
        decodedBuffer[n] = (res & 0x0000ff00);
        n++;

        data = buffer[i] >> 2;
        res = g726_16_decode(data, AUDIO_ENCODING_LINEAR);
        // decodedBuffer[n] = (res & 0x000000ff);
        // n++;
        decodedBuffer[n] = (res & 0x0000ff00);
        n++;

        data = buffer[i];
        res = g726_16_decode(data, AUDIO_ENCODING_LINEAR);
        // decodedBuffer[n] = (res & 0x000000ff);
        // n++;
        decodedBuffer[n] = (res & 0x0000ff00);
        n++;
      }
      return decodedBuffer;
    }
  });

  return new Constructor();
}

function G726_24_AudioDecoder() {
  var AUDIO_ENCODING_ULAW = 1; /* ISDN u-law */
  var AUDIO_ENCODING_ALAW = 2; /* ISDN A-law */
  var AUDIO_ENCODING_LINEAR = 3; /* PCM 2's-complement (0-center) */

  /*
   * Maps G.723_24 code word to reconstructed scale factor normalized log
   * magnitude values.
   */
  var _dqlntab = [-2048, 135, 273, 373, 373, 273, 135, -2048]; //short[]

  /* Maps G.723_24 code word to log of scale factor multiplier. */
  var _witab = [-128, 960, 4384, 18624, 18624, 4384, 960, -128]; // short[]

  /*
   * Maps G.723_24 code words to a set of values whose long and short
   * term averages are computed and then compared to give an indication
   * how stationary (steady state) the signal is.
   */
  var _fitab = [0, 0x200, 0x400, 0xE00, 0xE00, 0x400, 0x200, 0]; //short[]

  var qtab_723_24 = [8, 218, 331]; //int[]
  var g726_state = {};

  var commonAudioUtil = null;

  /*
   * g723_24_decoder()
   *
   * Decodes a 3-bit CCITT G.723_24 ADPCM code and returns
   * the resulting 16-bit linear PCM, A-law or u-law sample value.
   * -1 is returned if the output coding is unknown.
   * i            int
   * out_coding   int
   */
  function g726_24_decode(i, out_coding) {
    var   sezi;
    var   sez;      /* ACCUM */
    var   sei;
    var   se;
    var   y;        /* MIX */
    var   dq;
    var   sr;       /* ADDB */
    var   dqsez;

    i &= 0x07;        /* mask to get proper bits */
    sezi = commonAudioUtil.predictor_zero(g726_state);
    sez = sezi >> 1;
    sei = sezi + commonAudioUtil.predictor_pole(g726_state);
    se = sei >> 1;      /* se = estimated signal */

    y = commonAudioUtil.step_size(g726_state); /* adaptive quantizer step size */
    dq = commonAudioUtil.reconstruct(i & 0x04, _dqlntab[i], y); /* unquantize pred diff */

    sr = (dq < 0) ? (se - (dq & 0x3FFF)) : (se + dq); /* reconst. signal */

    dqsez = sr - se + sez;      /* pole prediction diff. */

    g726_state = commonAudioUtil.update(3, y, _witab[i], _fitab[i], dq, sr, dqsez, g726_state);

    switch (out_coding) {
    // case AUDIO_ENCODING_ALAW:
    //   return (commonAudioUtil.tandem_adjust_alaw(sr, se, y, i, 4, qtab_723_24));
    // case AUDIO_ENCODING_ULAW:
    //   return (commonAudioUtil.tandem_adjust_ulaw(sr, se, y, i, 4, qtab_723_24));
    case AUDIO_ENCODING_LINEAR:
      return (sr << 2); /* sr was of 14-bit dynamic range */
    default:
      return (-1);
    }
  }

  function Constructor() {
    commonAudioUtil = new CommonAudioUtil();
    g726_state = commonAudioUtil.g726_init_state();    
  }

  Constructor.prototype = inheritObject(new AudioDecoder(),{
    decode: function(buffer) {
      var decodedBuffer = new Int16Array(buffer.length * 8 / 3);
      for(var i = 0, n = 0, buffer_length = buffer.length; i < buffer_length - 3; i += 3) {
        var res;
        var data;
        data = buffer[i] >> 5;
        res = g726_24_decode(data, AUDIO_ENCODING_LINEAR);
        // decodedBuffer[n] = (res & 0x000000ff);
        // n++;
        decodedBuffer[n] = (res & 0x0000ff00);
        n++;

        data = buffer[i] >> 2;
        res = g726_24_decode(data, AUDIO_ENCODING_LINEAR);
        // decodedBuffer[n] = (res & 0x000000ff);
        // n++;
        decodedBuffer[n] = (res & 0x0000ff00);
        n++;

        data = (buffer[i] << 1) | (buffer[i + 1] >> 7);
        res = g726_24_decode(data, AUDIO_ENCODING_LINEAR);
        // decodedBuffer[n] = (res & 0x000000ff);
        // n++;
        decodedBuffer[n] = (res & 0x0000ff00);
        n++;

        data = buffer[i + 1] >> 4;
        res = g726_24_decode(data, AUDIO_ENCODING_LINEAR);
        // decodedBuffer[n] = (res & 0x000000ff);
        // n++;
        decodedBuffer[n] = (res & 0x0000ff00);
        n++;

        data = buffer[i + 1] >> 1;
        res = g726_24_decode(data, AUDIO_ENCODING_LINEAR);
        // decodedBuffer[n] = (res & 0x000000ff);
        // n++;
        decodedBuffer[n] = (res & 0x0000ff00);
        n++;

        data = (buffer[i + 1] << 2) | (buffer[i + 2] >> 6);
        res = g726_24_decode(data, AUDIO_ENCODING_LINEAR);
        // decodedBuffer[n] = (res & 0x000000ff);
        // n++;
        decodedBuffer[n] = (res & 0x0000ff00);
        n++;

        data = buffer[i + 2] >> 3;
        res = g726_24_decode(data, AUDIO_ENCODING_LINEAR);
        // decodedBuffer[n] = (res & 0x000000ff);
        // n++;
        decodedBuffer[n] = (res & 0x0000ff00);
        n++;

        data = buffer[i + 2] >> 0;
        res = g726_24_decode(data, AUDIO_ENCODING_LINEAR);
        // decodedBuffer[n] = (res & 0x000000ff);
        // n++;
        decodedBuffer[n] = (res & 0x0000ff00);
        n++;
      }
      return decodedBuffer;      
    }
  });

  return new Constructor();
}

function G726_32_AudioDecoder() {

  var AUDIO_ENCODING_ULAW = 1; /* ISDN u-law */
  var AUDIO_ENCODING_ALAW = 2; /* ISDN A-law */
  var AUDIO_ENCODING_LINEAR = 3; /* PCM 2's-complement (0-center) */

  var qtab_723_32 = [-124, 80, 178, 246, 300, 349, 400]; //int[]

  /*
 * Maps G.721 code word to reconstructed scale factor normalized log
 * magnitude values.
 */
  var _dqlntab = [-2048, 4, 135, 213, 273, 323, 373, 425,
        425, 373, 323, 273, 213, 135, 4, -2048]; //short[]

  /* Maps G.721 code word to log of scale factor multiplier. */
  var _witab = [-12, 18, 41, 64, 112, 198, 355, 1122,
        1122, 355, 198, 112, 64, 41, 18, -12]; //short[]

  /*
   * Maps G.721 code words to a set of values whose long and short
   * term averages are computed and then compared to give an indication
   * how stationary (steady state) the signal is.
   */
  var _fitab = [0, 0, 0, 0x200, 0x200, 0x200, 0x600, 0xE00,
        0xE00, 0x600, 0x200, 0x200, 0x200, 0, 0, 0];

  var g726_state = {};
  var self = this;
  var commonAudioUtil = null;
 
  //i(int), out_coding(int) 
  function g726_32_decode(i, out_coding) {
    var   sezi; //int
    var   sez;//int     /* ACCUM */
    var   sei;//int
    var   se;//int
    var   y;//int       /* MIX */
    var   dq;//int
    var   sr;//int        /* ADDB */
    var   dqsez;//int
    var lino; //long

    i &= 0x0f;        /* mask to get proper bits */
    sezi = commonAudioUtil.predictor_zero(g726_state);
    sez = sezi >> 1;
    sei = sezi + commonAudioUtil.predictor_pole(g726_state);
    se = sei >> 1;      /* se = estimated signal */

    y = commonAudioUtil.step_size(g726_state); /* dynamic quantizer step size */

    dq = commonAudioUtil.reconstruct(i & 0x08, _dqlntab[i], y); /* quantized diff. */

    sr = (dq < 0) ? (se - (dq & 0x3FFF)) : se + dq; /* reconst. signal */

    dqsez = sr - se + sez;      /* pole prediction diff. */

    g726_state = commonAudioUtil.update(4, y, _witab[i] << 5, _fitab[i], dq, sr, dqsez, g726_state);

    switch (out_coding) {
      // case AUDIO_ENCODING_ALAW:
      //   return (commonAudioUtil.tandem_adjust_alaw(sr, se, y, i, 8, qtab_723_32));
      // case AUDIO_ENCODING_ULAW:
      //   return (commonAudioUtil.tandem_adjust_ulaw(sr, se, y, i, 8, qtab_723_32));
      case AUDIO_ENCODING_LINEAR:
            lino = sr << 2;  /* this seems to overflow a short*/
        lino = lino > 32767 ? 32767 : lino;
        lino = lino < -32768 ? -32768 : lino;
        return lino;//(sr << 2);  /* sr was 14-bit dynamic range */
      default:
        return (-1);
    }
  }

  function Constructor() {
    commonAudioUtil = new CommonAudioUtil();
    g726_state = commonAudioUtil.g726_init_state();
  }

  Constructor.prototype = inheritObject(new AudioDecoder(),{
    decode: function(buffer) {
      var decodedBuffer = new Int16Array(buffer.length * 2);
      for(var i = 0, n = 0, buffer_length = buffer.length; i < buffer_length; i++) {
        var res;
        var sec = (0xf0 & buffer[i]) >> 4;
        res = g726_32_decode(sec, AUDIO_ENCODING_LINEAR);
        // decodedBuffer[n] = (res & 0x000000ff);
        // n++;
        decodedBuffer[n] = (res & 0x0000ff00); // if >> 8, it seems to be little endian.
        n++;

        var first = 0x0f & buffer[i];
        res = g726_32_decode(first, AUDIO_ENCODING_LINEAR);
        // decodedBuffer[n] = (res & 0x000000ff);
        // n++;
        decodedBuffer[n] = (res & 0x0000ff00);
        n++;
      }

      return decodedBuffer;
    }
  });

  return new Constructor();  

}

function G726_40_AudioDecoder() {

  var AUDIO_ENCODING_ULAW = 1; /* ISDN u-law */
  var AUDIO_ENCODING_ALAW = 2; /* ISDN A-law */
  var AUDIO_ENCODING_LINEAR = 3; /* PCM 2's-complement (0-center) */

  /*
   * Maps G.723_40 code word to ructeconstructed scale factor normalized log
   * magnitude values.
   */
  var _dqlntab = [-2048, -66, 28, 104, 169, 224, 274, 318,
          358, 395, 429, 459, 488, 514, 539, 566,
          566, 539, 514, 488, 459, 429, 395, 358,
          318, 274, 224, 169, 104, 28, -66, -2048]; //short[]

  /* Maps G.723_40 code word to log of scale factor multiplier. */
  var _witab = [448, 448, 768, 1248, 1280, 1312, 1856, 3200,
        4512, 5728, 7008, 8960, 11456, 14080, 16928, 22272,
        22272, 16928, 14080, 11456, 8960, 7008, 5728, 4512,
        3200, 1856, 1312, 1280, 1248, 768, 448, 448]; //short[]

  /*
   * Maps G.723_40 code words to a set of values whose long and short
   * term averages are computed and then compared to give an indication
   * how stationary (steady state) the signal is.
   */
  var _fitab = [0, 0, 0, 0, 0, 0x200, 0x200, 0x200,
        0x200, 0x200, 0x400, 0x600, 0x800, 0xA00, 0xC00, 0xC00,
        0xC00, 0xC00, 0xA00, 0x800, 0x600, 0x400, 0x200, 0x200,
        0x200, 0x200, 0x200, 0, 0, 0, 0, 0]; //short[]

  var qtab_723_40 = [-122, -16, 68, 139, 198, 250, 298, 339,
          378, 413, 445, 475, 502, 528, 553]; //int[]

  var g726_state = {};

  var self = this;

  var commonAudioUtil = null;

  var player = null;

  var codecInfo = {
    type: "G.726-40",
    samplingRate : 8000,
    bitrate : '40000'
  };

  /*
 * g723_40_decoder()
 *
 * Decodes a 5-bit CCITT G.723 40Kbps code and returns
 * the resulting 16-bit linear PCM, A-law or u-law sample value.
 * -1 is returned if the output coding is unknown.
 * i            int
 * out_coding   int
 */
  function g726_40_decode(i, out_coding) {
    var sezi, sei, sez, se; /* ACCUM */
    var y;      /* MIX */
    var sr;     /* ADDB */
    var dq;
    var dqsez;

    i &= 0x1f;      /* mask to get proper bits */
    sezi = commonAudioUtil.predictor_zero(g726_state);
    sez = sezi >> 1;
    sei = sezi + commonAudioUtil.predictor_pole(g726_state);
    se = sei >> 1;      /* se = estimated signal */

    y = commonAudioUtil.step_size(g726_state); /* adaptive quantizer step size */
    dq = commonAudioUtil.reconstruct(i & 0x10, _dqlntab[i], y); /* estimation diff. */

    sr = (dq < 0) ? (se - (dq & 0x7FFF)) : (se + dq); /* reconst. signal */

    dqsez = sr - se + sez;    /* pole prediction diff. */

    g726_state = commonAudioUtil.update(5, y, _witab[i], _fitab[i], dq, sr, dqsez, g726_state);

    switch (out_coding) {
    case AUDIO_ENCODING_LINEAR:
      return (sr << 2); /* sr was of 14-bit dynamic range */
    default:
      return (-1);
    }
  }

  function Constructor() {
    commonAudioUtil = new CommonAudioUtil();
    g726_state = commonAudioUtil.g726_init_state();
  }

  Constructor.prototype = inheritObject(new AudioDecoder(),{
    decode: function(buffer) {
      var decodedBuffer = new Int16Array(buffer.length * 1.6);

      for( var i = 0, n = 0, buffer_length = buffer.length ; i < buffer_length - 5; i += 5 )
      {
        var res;
        var data;

        data = buffer[i] >> 3;
        res = g726_40_decode(data, AUDIO_ENCODING_LINEAR);
        // decodedBuffer[n] = (res & 0x000000ff);           
        // n++;
        decodedBuffer[n] = ((res & 0x0000ff00));    
        n++;

        data = (buffer[i] << 2) | (buffer[i + 1] >> 6);
        res = g726_40_decode(data, AUDIO_ENCODING_LINEAR);
        // decodedBuffer[n] = (res & 0x000000ff);           
        // n++;
        decodedBuffer[n] = ((res & 0x0000ff00));    
        n++;

        data = buffer[i + 1] >> 1;
        res = g726_40_decode(data, AUDIO_ENCODING_LINEAR);
        // decodedBuffer[n] = (res & 0x000000ff);           
        // n++;
        decodedBuffer[n] = ((res & 0x0000ff00));    
        n++;

        data = (buffer[i + 1] << 4) | (buffer[i + 2] >> 4);
        res = g726_40_decode(data, AUDIO_ENCODING_LINEAR);
        // decodedBuffer[n] = (res & 0x000000ff);           
        // n++;
        decodedBuffer[n] = ((res & 0x0000ff00));    
        n++;

        data = (buffer[i + 2] << 1) | (buffer[i + 3] >> 7);
        res = g726_40_decode(data, AUDIO_ENCODING_LINEAR);
        // decodedBuffer[n] = (res & 0x000000ff);           
        // n++;
        decodedBuffer[n] = ((res & 0x0000ff00));    
        n++;

        data = buffer[i + 3] >> 2;
        res = g726_40_decode(data, AUDIO_ENCODING_LINEAR);
        // decodedBuffer[n] = (res & 0x000000ff);           
        // n++;
        decodedBuffer[n] = ((res & 0x0000ff00));    
        n++;

        data = (buffer[i + 3] << 3) | (buffer[i + 4] >> 5);
        res = g726_40_decode(data, AUDIO_ENCODING_LINEAR);
        // decodedBuffer[n] = (res & 0x000000ff);           
        // n++;
        decodedBuffer[n] = ((res & 0x0000ff00));    
        n++;

        data = buffer[i + 4] >> 0;
        res = g726_40_decode(data, AUDIO_ENCODING_LINEAR);
        // decodedBuffer[n] = (res & 0x000000ff);           
        // n++;
        decodedBuffer[n] = ((res & 0x0000ff00));    
        n++;
      }
      return decodedBuffer;
    }
  });

  return new Constructor();
}
function G726xAudioDecoder(bits){
	"use strict";

	var decoder = null;

	function Constructor(bits) {
		switch(bits){
			case 16:
				decoder = new G726_16_AudioDecoder();
				break;
			case 24 :
				decoder = new G726_24_AudioDecoder();
				break;
			case 32:
				decoder = new G726_32_AudioDecoder();
				break;
			case 40:
				decoder = new G726_40_AudioDecoder();
				break;
			default:
				console.log("wrong bits");
				break;
		}
	}
	Constructor.prototype = {
		decode: function(data){
			var tBuffer = decoder.decode(data);
			var jsData = new Float32Array(tBuffer.length);
			for (var i = 0, tBuffer_length = tBuffer.length; i < tBuffer_length; i++) {
				/* var a1 = pcmData[i]/Math.pow(2,15);
				var a2 = Math.round(a1*100000) / 100000;
				jsData[i] = a2; */
				jsData[i] = tBuffer[i] / Math.pow(2,15);
			}
			
			return jsData;
		}
	};


	return new Constructor(bits);
}
function AudioPlayer() {
	"use strict";
	var preCodec = null,
		audioPlayer = null,
		errorCallbackFunc,
		_self;

	function Constructor() {
		_self = this;
		Constructor.prototype.channelId = 0;
	}

	Constructor.prototype = {
		setChannel: function (channelid) {
			Constructor.prototype.channelId = (channelid === null ? 0 : channelid);
		},
		getChannel: function () {
			return Constructor.prototype.channelId;
		},
		addEventListener: function (event, callbackFunc) {
			switch (event) {
				case 'error':
					if (typeof callbackFunc !== 'undefined') {
						errorCallbackFunc = callbackFunc;
					}
					break;
				default:
					log.error("undefined callback function");
					break;
			}
		},
		audioInit: function () {},
		isInit: function () {},
		Play: function () {},
		Stop: function () {},
		BufferAudio: function (data) {},
		ControlVolume: function () {}
	};

	return new Constructor();
}
function AudioPlayerAAC(){
	"use strict";

	var mimeCodec,
			mediaSource,		
			audio,		
			sourceBuffer = null,
			sourceOpened = false,
			isStopped = false,
			saveVol = 0,
			segmentBuffer = new Uint8Array();

	var preTimeStamp = 0;
	var initVideoTimeStamp = 0;
	var videoDiffTime = null;

	var bufferingFlag = false;
	var startPosArray = null;
	var startPos = 0;
	var _self;

	function appendBuffer(buffer1, buffer2) {
		var tmp = new Uint8Array(buffer1.byteLength + buffer2.byteLength);
		tmp.set(new Uint8Array(buffer1), 0);
		tmp.set(new Uint8Array(buffer2), buffer1.byteLength);
		return tmp;
	}

	function createAudio() {
		if(/Apple Computer/.test(navigator.vendor) && /Safari/.test(navigator.userAgent)) {
			mimeCodec = 'audio/x-aac';
		} else {
			mimeCodec = 'audio/aac';
		}

		audio = document.createElement("audio");
		document.body.appendChild(audio);		
		audio.addEventListener('error', audioErrorCallback);

		// console.log('init AAC player Mime codec = ' + mimeCodec);
	}

	function createMediaSource() {
		var availablePlay = false;
		window.MediaSource = window.MediaSource || window.WebKitMediaSource;

		if(!window.MediaSource) {
			throw new umpError({
				channelId: _self.getChannel(),
				errorCode: fromHex('0x030D'),
				place: 'mediaRouter.js:440',
				message: "MediaSource API is not supported!"
			});
		} else if (window.MediaSource.isTypeSupported(mimeCodec)) {
			mediaSource = new MediaSource();
			mediaSource.addEventListener('sourceopen', sourceOpenedCallback);
			mediaSource.addEventListener('sourceclose', sourceCloseCallback);
			mediaSource.addEventListener('sourceended', sourceEndedCallback);
			mediaSource.addEventListener('error', sourceErrorCallback);
			mediaSource.addEventListener('abort', sourceAbortCallback);
			availablePlay = true;
		} else {
			console.error('Unsupported MIME type or codec: ', mimeCodec);
		}
		return availablePlay;
	}

	function audioErrorCallback(e) {
		console.error(e);
		switch (e.target.error.code) {
		case e.target.error.MEDIA_ERR_ABORTED:
			console.error('audio tag error : You aborted the media playback.'); 
			break;
		case e.target.error.MEDIA_ERR_NETWORK:
			console.error('audio tag error : A network error caused the media download to fail.'); 
			break;
		case e.target.error.MEDIA_ERR_DECODE:
			console.error('audio tag error : The media playback was aborted due to a corruption problem or because the media used features your browser did not support.'); 
			break;
		case e.target.error.MEDIA_ERR_SRC_NOT_SUPPORTED:
			console.error('audio tag error : The media could not be loaded, either because the server or network failed or because the format is not supported.'); 
			break;
		default:
			console.error('audio tag error : An unknown media error occurred.');
			break;
		}
	}
	
	function sourceOpenedCallback() {
		console.info('sourceopened');
		if(sourceBuffer === null) {
			try {
				sourceOpened = true;
				sourceBuffer = mediaSource.addSourceBuffer(mimeCodec);
				sourceBuffer.addEventListener('updateend', sourceUpdatedCallback);
			} catch (exception) {
				console.error('Exception calling addSourceBuffer : ' + exception);
				return;
			}
		}
	}

	function sourceUpdatedCallback() {   
		if (audio.paused) {
			audio.play();
		}		
	}

	function sourceCloseCallback() {
		console.info('sourceclose'); 
		sourceOpened = false;		
	}

	function sourceEndedCallback() { console.info('sourceended'); }
	function sourceErrorCallback() { console.info('error'); }
	function sourceAbortCallback() { console.info('abort'); }

	function Constructor() {
		_self = this;
	}
	
	Constructor.prototype = inheritObject(new AudioPlayer(), {
		audioInit: function(codecType, bitrate, volume){
			createAudio();
			var availablePlay = createMediaSource();
			if(availablePlay){
				// connect mediasource to audio tag
				if (audio !== null) {
					audio.src = window.URL.createObjectURL(mediaSource);
					this.ControlVolume(volume);
					audio.pause();
				}				
			}
			return availablePlay;
		},
		isInit: function() {
			return (sourceBuffer !== null)  === true;
		},
		Play: function() {
			// var vol = saveVol * 20;
			this.ControlVolume(saveVol);
			//isStopped = false;
		},
		Stop: function() {
			audio.volume = 0;
			saveVol = 0;
			// if(audio) {
			// 	audio.pause();
			// 	if(mediaSource.readyState === 'open' && !sourceBuffer.updating) {
			// 		if(audio.currentTime > 0) {
			// 			mediaSource.endOfStream();
			// 		}
			// 	}

			// 	var sourceBuffers = mediaSource.activeSourceBuffers;
			// 	for(var i = 0, sourceBuffers_length = sourceBuffers.length; i < sourceBuffers_length; i++) {
			// 		mediaSource.removeSourceBuffer(sourceBuffers[i]);
			// 	}
			// 	mediaSource = null;
			// 	sourceBuffer = null;
			// }
		},
		BufferAudio: function(data, rtpTimestamp) {
			isStopped = false;
			var timegap = rtpTimestamp - preTimeStamp;

			if(timegap > 200 || timegap < 0){	// under 2000ms
				segmentBuffer = new Uint8Array();
				startPosArray = new Array();
				bufferingFlag = true;
				// console.log("audioBuffering :: bufferingStart AAC!!!!!!!!!!!!");
			}

			if(bufferingFlag){
				startPosArray.push(startPos);
				startPos += data.length;
			}

			preTimeStamp = rtpTimestamp;
			segmentBuffer = appendBuffer(segmentBuffer, data);

			if (sourceBuffer !== null && !bufferingFlag) {
				if(!sourceBuffer.updating){ // if true, sourcebuffer is unusable
					try {
						if(startPosArray !== null){
							if(videoDiffTime !== null){
								// console.log("audioBuffering :: Origin Buffering Time AAC: " + startPosArray.length/16 + " sec");
								if((parseInt(startPosArray.length/16) - parseInt(videoDiffTime)) >= 2){
									videoDiffTime += 1;
								}
								startPos = parseInt(((videoDiffTime) * 16),10);
								// console.log("audioBuffering :: Waste Buffering Time AAC: " + startPos/16 + " sec");	
								if(startPos < startPosArray.length){
									sourceBuffer.appendBuffer(segmentBuffer.subarray(startPosArray[startPos],segmentBuffer.length));	
									if(sourceBuffer.buffered.length > 0){
										audio.currentTime = sourceBuffer.buffered.end(0);
									}
								} else {
									if(sourceBuffer.buffered.length > 0){
										audio.currentTime = sourceBuffer.buffered.end(0)-0.3;
									}
								}
 							}
						}else{
							sourceBuffer.appendBuffer(segmentBuffer);
						}

						segmentBuffer = new Uint8Array();
						startPosArray = null;
						startPos = 0;
					} catch (exception) {
						console.error('Exception while appending : ' + exception);
					}
				} else {
					
				}
			}
		},
		ControlVolume: function(vol) {
			saveVol = vol;
			if(audio !== null) {
				var tVol = vol / 5;
				if(tVol <= 0) { //min
					audio.volume = 0;
				} else {
					if (tVol >= 1) { //max
						audio.volume = 1;
					} else {
						audio.volume = tVol;
					}
				}
			}
		},
		GetVolume: function(){
			return saveVol;
		},
		terminate: function(){
			// audio = null;
		},
		setBufferingFlag: function(videoTime, videoStatus){
			if(videoStatus == "init"){
				// console.log("audioBuffering :: init time =" + videoTime);
				initVideoTimeStamp = videoTime;
			}else{
				if(bufferingFlag){
					// console.log("audioBuffering :: currentTime = " + videoTime);
					if(videoTime === 0 || videoTime === "undefined" || videoTime === null){
						videoDiffTime = null;
					}else{
						videoDiffTime = videoTime - initVideoTimeStamp;
						initVideoTimeStamp = 0;
					}
					bufferingFlag = false;
				}
			}
		},
		getBufferingFlag: function(){
			return bufferingFlag;
		},
		setInitVideoTimeStamp: function(time){
			initVideoTimeStamp = time;
		},
		getInitVideoTimeStamp: function(){
			return initVideoTimeStamp;
		}
	});

	return new Constructor();
}

function AudioPlayerGxx() {
	"use strict";

	var version = '1.0.0';
  var log = log4javascript.getLogger();

	var audioContext,
		gainInNode,
		biquadFilter,
		bufferNode,
		saveVol = 0,
		_self;

	var codecInfo = {
		type: "G.711",
		samplingRate: 8000,
		bitrate: '64000'
	};

	var nextStartTime = 0;
	var isRunning = false;
	var preTimeStamp = 0;
	var initVideoTimeStamp = 0;
	var videoDiffTime = null;

	var bufferingFlag = false;
	var playBuffer = new Float32Array(80000);
	var readLength = 0;
	var sourceNode = null;
	var audioDecoder = null;

	function playAudioIn(data, rtpTimestamp) {
		var timegap = rtpTimestamp - preTimeStamp;

		if (timegap > 200 || timegap < 0) { // under 2000ms
			nextStartTime = 0;
			readLength = 0;
			bufferingFlag = true;
			if (sourceNode !== null) {
				sourceNode.stop();
			}
			// console.log("audioBuffering :: bufferingStart G7xx!!!!!!!!!!!!");
		}

		if ((nextStartTime - audioContext.currentTime) < 0) { // nextStartTime overflow
			nextStartTime = 0;
		}

		preTimeStamp = rtpTimestamp;

		playBuffer = appendBufferFloat32(playBuffer, data, readLength);
		readLength += data.length;

		if (!bufferingFlag) {
			var startPos = 0;
			if ((readLength / data.length) > 1) {
				if (videoDiffTime !== null) {
					startPos = (videoDiffTime) * 8000;
					log.debug("audioBuffering :: Origin Buffering Time G7xx: " + readLength/8000 + " sec");
					log.debug("audioBuffering :: Waste Buffering Time G7xx: " + startPos/8000 + " sec");
				}
				if (startPos >= readLength || videoDiffTime === null) {
					readLength = 0;
					return;
				}
			}

			if (/Apple Computer/.test(navigator.vendor) && /Safari/.test(navigator.userAgent)) {
				playBuffer = Upsampling8Kto32K(playBuffer.subarray(startPos, readLength));
			} else {
				playBuffer = playBuffer.subarray(startPos, readLength);
			}
			var audioBuffer = audioContext.createBuffer(1, playBuffer.length, codecInfo.samplingRate);
			audioBuffer.getChannelData(0).set(playBuffer);

			readLength = 0;
			sourceNode = audioContext.createBufferSource();

			sourceNode.buffer = audioBuffer;
			sourceNode.connect(biquadFilter);

			if (!nextStartTime) {
				nextStartTime = audioContext.currentTime + 0.1;
			}

			sourceNode.start(nextStartTime);
			nextStartTime += audioBuffer.duration;
		}
	}

	function appendBufferFloat32(currentBuffer, newBuffer, readLength) {
		var BUFFER_SIZE = 80000;
		if ((readLength + newBuffer.length) >= currentBuffer.length) {
			var tmp = new Float32Array(currentBuffer.length + BUFFER_SIZE);
			tmp.set(currentBuffer, 0);
			currentBuffer = tmp;
		}
		currentBuffer.set(newBuffer, readLength);
		return currentBuffer;
	}

	function Upsampling8Kto32K(inputBuffer) {
		var point1, point2, point3, point4, mu = 0.2,
			mu2 = (1 - Math.cos(mu * Math.PI)) / 2;
		var buf = new Float32Array(inputBuffer.length * 4);
		for (var i = 0, j = 0, inputBuffer_length = inputBuffer.length; i < inputBuffer_length; i++) {
			//index for dst buffer
			j = i * 4;

			//the points to interpolate between
			point1 = inputBuffer[i];
			point2 = (i < (inputBuffer.length - 1)) ? inputBuffer[i + 1] : point1;
			point3 = (i < (inputBuffer.length - 2)) ? inputBuffer[i + 2] : point1;
			point4 = (i < (inputBuffer.length - 3)) ? inputBuffer[i + 3] : point1;
			//interpolate
			point2 = (point1 * (1 - mu2) + point2 * mu2);
			point3 = (point2 * (1 - mu2) + point3 * mu2);
			point4 = (point3 * (1 - mu2) + point4 * mu2);
			//put data into buffer
			buf[j] = point1;
			buf[j + 1] = point2;
			buf[j + 2] = point3;
			buf[j + 3] = point4;
		}
		return buf;
	}

	function Constructor() {
		_self = this;
	}
	Constructor.prototype = inheritObject(new AudioPlayer(), {
		audioInit: function (codecType, bitrate, volume) {
			//init audio context
			log.debug("init Gxx player");
			nextStartTime = 0;

			audioDecoder = null;
			codecInfo.samplingRate = 8000;
			if (codecType === "G711") {
				audioDecoder = new G711AudioDecoder();
			} else if (codecType === "AAC") {
				audioDecoder = new AACAudioDecoder();
				codecInfo.samplingRate = 16000;
			} else {
				audioDecoder = new G726xAudioDecoder(bitrate);
			}

			if (/Apple Computer/.test(navigator.vendor) && /Safari/.test(navigator.userAgent)) {
				codecInfo.samplingRate = codecInfo.samplingRate * 4;
			}

			codecInfo.type = codecType;

			if (typeof audioContext !== "undefined" && audioContext !== null) {
				log.debug("Audio context already defined!'");
				return false;
			} else {
				try {
					window.AudioContext = window.AudioContext ||
						window.webkitAudioContext ||
						window.mozAudioContext ||
						window.oAudioContext ||
						window.msAudioContext;

					
					audioContext = new AudioContext();
					audioContext.onstatechange = function () {
						if (audioContext !== null && audioContext !== undefined) {
							log.info('channel', _self.getChannel(), ' Audio Context State changed :: ', audioContext.state);
							if (audioContext.state === "running") {
								isRunning = true;
							} else if (audioContext.state === 'closed') {
								isRunning = false;
								audioContext = null;
							}
						}
					};

					if(audioContext !== undefined && audioContext !== null) {
						gainInNode = audioContext.createGain(); // create gain node
						biquadFilter = audioContext.createBiquadFilter();
						biquadFilter.connect(gainInNode);
						biquadFilter.type = "lowpass";

						// Biquad filter optimized value @Web_Audio_API
						biquadFilter.frequency.value = 1000;
						biquadFilter.gain.value = 25;
	
						// Connect gain node to speakers
						gainInNode.connect(audioContext.destination);
					}

					this.ControlVolume(volume);
					return true;
				} catch (error) {
					console.warn("Web Audio API is not supported in this web browser! : ", error);
					throw new umpError({
						channelId: this.channelId,
						errorCode: fromHex('0x030F'),
						place: 'audioPlayerGxx.js:201',
						message: "Audio error  [" + error.code + "], name [" + error.name + ", message [" + error.message + "]"
					});
					//return false;
				}
			}
		},
		isInit: function () {
			return (audioDecoder !== null) === true;
		},
		Play: function () {
			this.ControlVolume(saveVol);
		},
		Stop: function () {
			saveVol = 0;
			if (gainInNode !== undefined && gainInNode !== null) {
				gainInNode.gain.value = 0;
			}
			nextStartTime = 0;
		},
		BufferAudio: function (data, rtpTimestamp) {
			if (isRunning) {
				var decodedBuffer = audioDecoder.decode(data);
				playAudioIn(decodedBuffer, rtpTimestamp);
			}
		},
		ControlVolume: function (vol) {
			//setAudioInNodes(); // in case control volume before turn on
			if (gainInNode !== undefined && gainInNode !== null) {
				saveVol = vol;
				var tVol = vol / 5;
				if (tVol <= 0) { //min
					gainInNode.gain.value = 0;
					nextStartTime = 0;
				} else {
					if (tVol >= 1) { //max
						gainInNode.gain.value = 1;
					} else {
						gainInNode.gain.value = tVol;
					}
				}
			}
		},
		GetVolume: function () {
			return saveVol;
		},
		terminate: function () {
			if (typeof audioContext !== "undefined") {
				if (audioContext.state !== "closed") {
					nextStartTime = 0;
					isRunning = false;
					audioContext.close();
				}
			}

			if (codecInfo.type === "AAC") {
				audioDecoder.close();
			}
		},
		setBufferingFlag: function (videoTime, videoStatus) {
			if (videoStatus == "init") {
				log.debug("audioBuffering :: init time =" + videoTime);
				initVideoTimeStamp = videoTime;
			} else {
				if (bufferingFlag) {
					log.debug("audioBuffering :: currentTime = " + videoTime);
					if (videoTime === 0 || videoTime === "undefined" || videoTime === null) {
						videoDiffTime = null;
					} else {
						videoDiffTime = videoTime - initVideoTimeStamp;
						initVideoTimeStamp = 0;
					}
					bufferingFlag = false;
				}
			}
		},
		getBufferingFlag: function () {
			return bufferingFlag;
		},
		setInitVideoTimeStamp: function (time) {
			initVideoTimeStamp = time;
		},
		getInitVideoTimeStamp: function () {
			return initVideoTimeStamp;
		}
	});

	return new Constructor();
}
var AACSession = function () {
	"use strict";

	var version = '1.0.0';
	var aacrtpsession_log = log4javascript.getLogger('aacrtpsession');

	var config;
	var clockFreq;
	var bitrate;
	var ADTs = new Uint8Array(7);
	var playback = false;
	var headerLen = 4;
	var pktTime = {};
	var playMode;
	var streamData = {};
	var audioInfo = {};

	var rtpVersion,
		rtpPadding,
		rtpCSRCCount,
		rtpExtension,
		rtpMarkerBit,
		rtpTimeStamp = 0,
		rtpSquenceNumber,
		rtpPayloadType;

		var NTPmsw = new Uint8Array(new ArrayBuffer(4)),
		NTPlsw = new Uint8Array(new ArrayBuffer(4)),
		gmt = new Uint8Array(new ArrayBuffer(2));

	var frameSize;
	var raw_payload;

	function genADTSAAC(frameSize, payload) {
		var mChannels = 1;
		if (typeof (config) === 'string') {
			var FirstTwo_config = parseInt(config.substring(0, 2), 16);
			var LastTwo_config = parseInt(config.substring(2, 4), 16);
		} else {
			aacrtpsession_log.warn("wrong type of config in SDP");
			return;
		}

		var mAOT = FirstTwo_config >> 3;
		var freqIndex = ((FirstTwo_config & 0x07) << 1) | ((LastTwo_config & 0x80) >> 7);

		ADTs[0] = 0xFF;
		ADTs[1] = 0xF9;
		ADTs[2] = (mAOT - 1) << 6;
		ADTs[2] |= (freqIndex << 2);
		ADTs[2] |= mChannels >> 2;
		ADTs[3] = mChannels << 6;
		ADTs[3] |= ((frameSize + 7) & 0x1800) >> 11;
		ADTs[4] = ((frameSize + 7) & 0x07F8) >> 3;
		ADTs[5] = ((frameSize + 7) & 0x07) << 5;
		ADTs[5] |= 0x01;
		ADTs[6] = 0x54;

		var ADTsAAC = new Uint8Array(ADTs.length + payload.length);
		ADTsAAC.set(ADTs, 0);
		ADTsAAC.set(payload, ADTs.length);
		return ADTsAAC;
	}

	function Constructor() {}

	Constructor.prototype = inheritObject(new RtpSession(), {
		init: function (info) {
			aacrtpsession_log.info("Set codec info. for AAC");
			config = info.config;
			bitrate = info.bitrate;
			clockFreq = info.clockFreq;
			playback = false;
			this.timeData = {
				'timestamp': null,
				'timestamp_usec': null,
				'timezone': null
			};
		},
		depacketize: function (rtspInterleaved, rtpHeader, rtpPayload) {
			aacrtpsession_log.debug("AACSession::depacketize");
			headerLen = 4;
			var PAYLOAD;
			var PaddingSize = 0;
			var extensionHeaderLen = 0;

			if(this.interleavedId !== rtspInterleaved[1]) {
				// TODO: check interleaved id
			}

			// Reference: https://tools.ietf.org/html/rfc3550
			// Reference: https://tools.ietf.org/html/rfc3984
			rtpVersion = (rtpHeader[0] & 0xC0) >> 6;
			rtpPadding = (((rtpHeader[0] & 0x20) >> 5) === 1);
			rtpExtension = (((rtpHeader[0] & 0x10) >> 4) === 1);
			rtpCSRCCount = (rtpHeader[0] & 0x0F);
			rtpMarkerBit = (((rtpHeader[1] & 0x80) >> 7) === 1);
			rtpPayloadType = rtpHeader[1] & 0x7F;

			if (rtspInterleaved[0] !== 0x24) {
				throw new umpError({
					channelId: this.channelId,
					errorCode: fromHex('0x0102'),
					place: 'accSession.js:105',
					message: "it is not valid interleave header (RTSP over TCP). Interleaved[0] = " + rtspInterleaved[0].toString(16)
				});
			} else if (rtpCSRCCount !== 0) {
				throw new umpError({
					channelId: this.channelId,
					errorCode: fromHex('0x0103'),
					place: 'accSession.js:112',
					message: "There is additional CSRC which is not handled in this version. CSRC count = " + rtpCSRCCount
				});
			} else if (rtpPadding) {
				PaddingSize = rtpPayload[rtpPayload.length - 1];
				aacrtpsession_log.debug("AAC PaddingSize - " + PaddingSize);
			}

			//Extension bit check in RTPHeader
			if (rtpExtension) {
				extensionHeaderLen = ((rtpPayload[2] << 8 | rtpPayload[3]) * 4) + 4;

				if (rtpPayload[0] == '0xAB' && (rtpPayload[1] == '0xAD' || rtpPayload[1] == '0xAC')) {
					var startHeader = 4;

					NTPmsw.set(rtpPayload.subarray(startHeader, startHeader + 4), 0);
					startHeader += 4;
					NTPlsw.set(rtpPayload.subarray(startHeader, startHeader + 4), 0);
					if (this.getDeviceType() === 'camera') {
						startHeader += 6;
						gmt.set(rtpPayload.subarray(startHeader, startHeader + 2), 0);
					}

					var tempdata = {};
					tempdata.timestamp = ((this.ntohl(NTPmsw) - 0x83AA7E80) >>> 0);
					tempdata.timestamp_usec = (this.ntohl(NTPlsw) / 0xffffffff) * 1000;

					if (this.getDeviceType() === 'camera') {
						tempdata.timezone = (((gmt[0] << 8) | gmt[1]) << 16) >> 16;
					}

					if (this.GetTimeStamp().timestamp != null && this.GetTimeStamp().timestamp_usec !== null) {
						aacrtpsession_log.debug("", tempdata.timestamp, tempdata.timestamp_usec, this.GetTimeStamp().timestamp, this.GetTimeStamp().timestamp_usec);
						var timeGap = Math.abs(tempdata.timestamp - this.GetTimeStamp().timestamp);
						if (timeGap <= 1) {
							var distance = Math.abs((tempdata.timestamp * 1000 + tempdata.timestamp_usec) -
								(this.GetTimeStamp().timestamp * 1000 + this.GetTimeStamp().timestamp_usec));
							if (distance != 0) {
								this.setFramerate(Math.round(1000 / distance));
								aacrtpsession_log.debug("playback framerate = ", this.getFramerate());
							}
						}
					}
					this.SetTimeStamp(tempdata);
					playback = true;
				}
			}

			//https://tools.ietf.org/html/rfc6416
			PAYLOAD = rtpPayload.subarray(extensionHeaderLen, rtpPayload.length - PaddingSize);

			rtpTimeStamp = this.ntohl(rtpHeader.subarray(4, 8));
			rtpSquenceNumber = this.ntohl(rtpHeader.subarray(2, 3));

			aacrtpsession_log.debug("interleaved id = ", this.interleavedId,
			", AAC RTP Version: ", ("00" + rtpVersion).slice(-2),
			", Padding: ", rtpPadding,
			", ExtensionBit: ", rtpExtension,
			", CSRC Count: ", rtpCSRCCount,
			", Marker Bit: ", rtpMarkerBit,
			", RTP Payload Type: ", rtpPayloadType,
			", RTP Sequence Number: ", rtpSquenceNumber,
			", RTP Timestamp: ", rtpTimeStamp,
			", RTCP Timestamp: " + this.rtcpSession.rtpTimestamp);

			//check marker bit
			if (rtpMarkerBit) {
				this.rtpTimestamp = (rtpTimeStamp / 90).toFixed(0);

				frameSize = rtpPayload.length - (headerLen + extensionHeaderLen);
				raw_payload = rtpPayload.subarray((headerLen + extensionHeaderLen), rtpPayload.length);

				var temp1 = raw_payload.subarray(0, 2);

				//To check adt header is involved
				if (!((temp1[0] === 0xFF) && (temp1[1] & 0xF0 === 0xF0))) {
					raw_payload = genADTSAAC(frameSize, raw_payload);
				}

				playMode = (playback === true) ? 'Playback' : "Live";
				streamData = {
					'codecType': 'AAC',
					'frameData': raw_payload, // Adt header 7byte...
					'channelId': this.channelId,
					'timeStamp': {
						'rtpTimestamp': this.rtpTimestamp,
						'timestamp': this.timeData.timestamp,
						'timestamp_usec': this.timeData.timestamp_usec,
						'timezone': this.timeData.timezone
					},
					'rtcp_interleavedId': this.rtcpSession.interleavedId
				};
				audioInfo = {
					'bitrate': bitrate
				};

				this.eventAudioCallback(playMode, streamData, audioInfo);
			}
		}
	});

	return new Constructor();
};
var AudioTalkSession = function (channel) {
	"use strict";

	var rtspheader,
		rtpheader,
		rtpHeaderSize = 12,
		rtspHeaderSize = 4,
		sequenceNum = 0xFFDE,   //random start sequence number
		timestamp,
		ssrcId = Math.floor((Math.random() * 1000000) + 1),
		rtpPacket,
		channelID = null,
		audioEncoder = new G711AudioEncoder();

	var intToByteArrayHtoN = function(value,len,bytearray,lastpos) {
		var byteval;
		for (var index = lastpos; index > (lastpos-len); index = index - 1) {
			byteval = value & 0xff;
			bytearray[index] = byteval;
			value = (value - byteval) / 256 ;
		}

	};

  function Constructor(channel) {
  	channelID = channel;
  }

  Constructor.prototype = inheritObject(new RtpSession(), {
  	setSampleRate: function(_sampleRate){
  		audioEncoder.setSampleRate(_sampleRate);
  	},
	getRTPPacket: function(buffer) {
		var rtpPayload = audioEncoder.encode(buffer);
		var payloadSize;
		var index = 0, byteval;

		rtspheader = new Uint8Array(new ArrayBuffer(4));
		rtspheader[0] = 0x24;
		rtspheader[1] = channelID;
		payloadSize = rtpHeaderSize + rtpPayload.length;

		intToByteArrayHtoN(payloadSize,2,rtspheader,3);

		//form rtp header
		rtpheader = new Uint8Array(new ArrayBuffer(12));
		rtpheader[0] = 0x80;
		rtpheader[1] = 0x80;//marker & Payload Type
		//sequence number
		sequenceNum += 1;
		intToByteArrayHtoN(sequenceNum,2,rtpheader,3);

		//timestamp
		timestamp = new Date();
		intToByteArrayHtoN(timestamp,4,rtpheader,7);

		//ssrc
		intToByteArrayHtoN(ssrcId,4,rtpheader,11);

		rtpPacket = new Uint8Array(new ArrayBuffer(rtpHeaderSize +rtpPayload.length+4));
		rtpPacket.set(rtspheader,0);
		rtpPacket.set(rtpheader,rtspHeaderSize);
		rtpPacket.set(rtpPayload,rtspHeaderSize+rtpHeaderSize);

		return rtpPacket;
	}
	});

	return new Constructor(channel);
};
var G711Session = function () {
  "use strict";

  var version = '1.0.0';
  var g711rtpsession_log = log4javascript.getLogger('g711rtpsession');

  var audioDecoder = null;
  var bitrate = 0;
  var clockFreq = 0;
  var playback = false;
  var pktTime = {};
  var processedMessage;
  var interleavedChannelId;
  var playMode;
  var streamData = {};
  var audioInfo = {};

  var rtpVersion,
    rtpPadding,
    rtpCSRCCount,
    rtpExtension,
    rtpMarkerBit,
    rtpTimeStamp = 0,
    rtpSquenceNumber,
    rtpPayloadType;

  var NTPmsw = new Uint8Array(new ArrayBuffer(4)),
		NTPlsw = new Uint8Array(new ArrayBuffer(4)),
		gmt = new Uint8Array(new ArrayBuffer(2));

  function Constructor() {}

  Constructor.prototype = inheritObject(new RtpSession(), {
    init: function (info) {
      g711rtpsession_log.info("Set codec info. for G711");
      bitrate = info.bitrate;
      clockFreq = info.clockFreq;
      playback = false;
      this.timeData = {
        'timestamp': null,
        'timestamp_usec': null,
        'timezone': null
      };
    },
    depacketize: function (rtspInterleaved, rtpHeader, rtpPayload) {
      g711rtpsession_log.debug("G711Session::depacketize");
      var PAYLOAD;
      var PaddingSize = 0;
      var extensionHeaderLen = 0;

      if (this.interleavedId !== rtspInterleaved[1]) {
        // TODO: check interleaved id
      }
      // Reference: https://tools.ietf.org/html/rfc3550
      // Reference: https://tools.ietf.org/html/rfc3984
      rtpVersion = (rtpHeader[0] & 0xC0) >> 6;
      rtpPadding = (((rtpHeader[0] & 0x20) >> 5) === 1);
      rtpExtension = (((rtpHeader[0] & 0x10) >> 4) === 1);
      rtpCSRCCount = (rtpHeader[0] & 0x0F);
      rtpMarkerBit = (((rtpHeader[1] & 0x80) >> 7) === 1);
      rtpPayloadType = rtpHeader[1] & 0x7F;

      if (rtspInterleaved[0] !== 0x24) {
        throw new umpError({
          channelId: this.channelId,
          errorCode: fromHex('0x0102'),
          place: 'g711Session.js:66',
          message: "it is not valid interleave header (RTSP over TCP). Interleaved[0] = " + rtspInterleaved[0].toString(16)
        });
      } else if (rtpCSRCCount !== 0) {
        throw new umpError({
          channelId: this.channelId,
          errorCode: fromHex('0x0103'),
          place: 'g711Session.js:73',
          message: "There is additional CSRC which is not handled in this version. CSRC count = " + rtpCSRCCount
        });
      } else if (rtpPadding) {
        PaddingSize = rtpPayload[rtpPayload.length - 1];
        g711rtpsession_log.debug("G.711 PaddingSize - " + PaddingSize);
      }

      //Extension bit check in RTPHeader
      if (rtpExtension) {
        extensionHeaderLen = ((rtpPayload[2] << 8 | rtpPayload[3]) * 4) + 4;

        if (rtpPayload[0] == '0xAB' && (rtpPayload[1] == '0xAD' || rtpPayload[1] == '0xAC')) {
          var startHeader = 4;

          NTPmsw.set(rtpPayload.subarray(startHeader, startHeader + 4), 0);
          startHeader += 4;
          NTPlsw.set(rtpPayload.subarray(startHeader, startHeader + 4), 0);
          if (this.getDeviceType() === 'camera') {
            startHeader += 6;
            gmt.set(rtpPayload.subarray(startHeader, startHeader + 2), 0);
          }

          var tempdata = {};
          tempdata.timestamp = ((this.ntohl(NTPmsw) - 0x83AA7E80) >>> 0);
          tempdata.timestamp_usec = (this.ntohl(NTPlsw) / 0xffffffff) * 1000;

          if (this.getDeviceType() === 'camera') {
            tempdata.timezone = (((gmt[0] << 8) | gmt[1]) << 16) >> 16;
          }

          if (this.GetTimeStamp().timestamp != null && this.GetTimeStamp().timestamp_usec !== null) {
            g711rtpsession_log.debug("", tempdata.timestamp, tempdata.timestamp_usec, this.GetTimeStamp().timestamp, this.GetTimeStamp().timestamp_usec);
            var timeGap = Math.abs(tempdata.timestamp - this.GetTimeStamp().timestamp);
            if (timeGap <= 1) {
              var distance = Math.abs((tempdata.timestamp * 1000 + tempdata.timestamp_usec) -
                (this.GetTimeStamp().timestamp * 1000 + this.GetTimeStamp().timestamp_usec));
              if (distance != 0) {
                this.setFramerate(Math.round(1000 / distance));
                g711rtpsession_log.debug("playback framerate = ", this.getFramerate());
              }
            }
          }
          this.SetTimeStamp(tempdata);
          playback = true;
        }
      }

      processedMessage = rtpPayload.subarray(extensionHeaderLen, rtpPayload.length);
      PAYLOAD = rtpPayload.subarray(extensionHeaderLen, rtpPayload.length - PaddingSize);

      rtpTimeStamp = this.ntohl(rtpHeader.subarray(4, 8));
			rtpSquenceNumber = this.ntohl(rtpHeader.subarray(2, 3));

      // Reference: https://tools.ietf.org/html/rfc5391
      g711rtpsession_log.debug("interleaved id = ", this.interleavedId,
        ", HEVC RTP Version: ", ("00" + rtpVersion).slice(-2),
        ", Padding: ", rtpPadding,
        ", ExtensionBit: ", rtpExtension,
        ", CSRC Count: ", rtpCSRCCount,
        ", Marker Bit: ", rtpMarkerBit,
        ", RTP Payload Type: ", rtpPayloadType,
        ", RTP Sequence Number: ", rtpSquenceNumber,
        ", RTP Timestamp: ", rtpTimeStamp,
        ", RTCP Timestamp: " + this.rtcpSession.rtpTimestamp);

      //check marker bit
			if (rtpMarkerBit) {
			  this.rtpTimestamp = (rtpTimeStamp / 90).toFixed(0);

			  // pktTime = rtspclient.GetPacketTimeStamp(rtpInterlevedChannelID,rtpTimeStamp);
			  playMode = (playback === true) ? 'Playback' : "Live";
			  streamData = {
			    'codecType': 'G711',
          'frameData': processedMessage,
          'channelId': this.channelId,
			    'timeStamp': {
			      'rtpTimestamp': this.rtpTimestamp,
			      'timestamp': this.timeData.timestamp,
			      'timestamp_usec': this.timeData.timestamp_usec,
			      'timezone': this.timeData.timezone
			    },
			    'rtcp_interleavedId': this.rtcpSession.interleavedId
			  };
			  audioInfo = {
			    'bitrate': bitrate
			  };

			  this.eventAudioCallback(playMode, streamData, audioInfo);
			}
    }
  });

  return new Constructor();
};
var G726Session = function () {
  "use strict";

  var version = '1.0.0';
  var g726rtpsession_log = log4javascript.getLogger('g726rtpsession');

  var bitrate = 0;
  var clockFreq = 0;
  var playback = false;
  var pktTime = {};
  var processedMessage;
  var interleavedChannelId;
  var playMode;
  var streamData = {};
  var audioInfo = {};

  var rtpVersion,
    rtpPadding,
    rtpCSRCCount,
    rtpExtension,
    rtpMarkerBit,
    rtpTimeStamp = 0,
    rtpSquenceNumber,
    rtpPayloadType;

  var NTPmsw = new Uint8Array(new ArrayBuffer(4)),
		NTPlsw = new Uint8Array(new ArrayBuffer(4)),
		gmt = new Uint8Array(new ArrayBuffer(2));

  function Constructor() {}

  Constructor.prototype = inheritObject(new RtpSession(), {
    init: function (info) {
      g726rtpsession_log.info("Set codec info. for G726");
      clockFreq = info.clockFreq;
      bitrate = info.bitrate;
      playback = false;
      this.timeData = {
        'timestamp': null,
        'timestamp_usec': null,
        'timezone': null
      };
    },
    depacketize: function (rtspInterleaved, rtpHeader, rtpPayload) {
      g726rtpsession_log.debug("G726Session::depacketize");
      var PAYLOAD;
      var PaddingSize = 0;
      var extensionHeaderLen = 0;

			if(this.interleavedId !== rtspInterleaved[1]) {
				// TODO: check interleaved id
			}
      // Reference: https://tools.ietf.org/html/rfc3550
      // Reference: https://tools.ietf.org/html/rfc3984
      rtpVersion = (rtpHeader[0] & 0xC0) >> 6;
      rtpPadding = (((rtpHeader[0] & 0x20) >> 5) === 1);
      rtpExtension = (((rtpHeader[0] & 0x10) >> 4) === 1);
      rtpCSRCCount = (rtpHeader[0] & 0x0F);
      rtpMarkerBit = (((rtpHeader[1] & 0x80) >> 7) === 1);
      rtpPayloadType = rtpHeader[1] & 0x7F;

      if (rtspInterleaved[0] !== 0x24) {
        throw new umpError({
          channelId: this.channelId,
          errorCode: fromHex('0x0102'),
          place: 'g726Session.js:65',
          message: "it is not valid interleave header (RTSP over TCP). Interleaved[0] = " + rtspInterleaved[0].toString(16)
        });
      } else if (rtpCSRCCount !== 0) {
        throw new umpError({
          channelId: this.channelId,
          errorCode: fromHex('0x0103'),
          place: 'g726Session.js:72',
          message: "There is additional CSRC which is not handled in this version. CSRC count = " + rtpCSRCCount
        });
      } else if (rtpPadding) {
        PaddingSize = rtpPayload[rtpPayload.length - 1];
        g726rtpsession_log.debug("G.726 PaddingSize - " + PaddingSize);
      }

      //Extension bit check in RTPHeader
      if (rtpExtension) {
        extensionHeaderLen = ((rtpPayload[2] << 8 | rtpPayload[3]) * 4) + 4;

        if (rtpPayload[0] == '0xAB' && (rtpPayload[1] == '0xAD' || rtpPayload[1] == '0xAC')) {
          var startHeader = 4;

          NTPmsw.set(rtpPayload.subarray(startHeader, startHeader + 4), 0);
          startHeader += 4;
          NTPlsw.set(rtpPayload.subarray(startHeader, startHeader + 4), 0);
          if (this.getDeviceType() === 'camera') {
            startHeader += 6;
            gmt.set(rtpPayload.subarray(startHeader, startHeader + 2), 0);
          }

          var tempdata = {};
          tempdata.timestamp = ((this.ntohl(NTPmsw) - 0x83AA7E80) >>> 0);
          tempdata.timestamp_usec = (this.ntohl(NTPlsw) / 0xffffffff) * 1000;

          if (this.getDeviceType() === 'camera') {
            tempdata.timezone = (((gmt[0] << 8) | gmt[1]) << 16) >> 16;
          }

          if (this.GetTimeStamp().timestamp != null && this.GetTimeStamp().timestamp_usec !== null) {
            g726rtpsession_log.debug("", tempdata.timestamp, tempdata.timestamp_usec, this.GetTimeStamp().timestamp, this.GetTimeStamp().timestamp_usec);
            var timeGap = Math.abs(tempdata.timestamp - this.GetTimeStamp().timestamp);
            if (timeGap <= 1) {
              var distance = Math.abs((tempdata.timestamp * 1000 + tempdata.timestamp_usec) -
                (this.GetTimeStamp().timestamp * 1000 + this.GetTimeStamp().timestamp_usec));
              if (distance != 0) {
                this.setFramerate(Math.round(1000 / distance));
                g726rtpsession_log.debug("playback framerate = ", this.getFramerate());
              }
            }
          }
          this.SetTimeStamp(tempdata);
          playback = true;
        }
      }

      processedMessage = rtpPayload.subarray(extensionHeaderLen, rtpPayload.length);
      PAYLOAD = rtpPayload.subarray(extensionHeaderLen, rtpPayload.length - PaddingSize);

      rtpTimeStamp = this.ntohl(rtpHeader.subarray(4, 8));
			rtpSquenceNumber = this.ntohl(rtpHeader.subarray(2, 3));

      // Reference: https://tools.ietf.org/html/rfc3551
      g726rtpsession_log.debug("interleaved id = ", this.interleavedId,
      ", G.726 RTP Version: ", ("00" + rtpVersion).slice(-2),
      ", Padding: ", rtpPadding,
      ", ExtensionBit: ", rtpExtension,
      ", CSRC Count: ", rtpCSRCCount,
      ", Marker Bit: ", rtpMarkerBit,
      ", RTP Payload Type: ", rtpPayloadType,
      ", RTP Sequence Number: ", rtpSquenceNumber,
      ", RTP Timestamp: ", rtpTimeStamp,
      ", RTCP Timestamp: " + this.rtcpSession.rtpTimestamp);

      //check marker bit
			if (rtpMarkerBit) {
        this.rtpTimestamp = (rtpTimeStamp / 90).toFixed(0);

        playMode = (playback === true) ? 'Playback' : "Live";
        streamData = {
          'codecType': 'G726',
          'frameData': processedMessage,
          'channelId': this.channelId,
          'timeStamp': {
            'rtpTimestamp': this.rtpTimestamp,
            'timestamp': this.timeData.timestamp,
            'timestamp_usec': this.timeData.timestamp_usec,
            'timezone': this.timeData.timezone
          },
          'rtcp_interleavedId': this.rtcpSession.interleavedId
        };
        audioInfo = {
          'bitrate': bitrate
        };

        this.eventAudioCallback(playMode, streamData, audioInfo);
      }
    }
  });

  return new Constructor();
};
/* global BrowserDetect, H264SPSParser, H265SPSParser, CanvasTagPlayer, VideoTagPlayer,
  AudioPlayerGxx, AudioPlayerAAC, Talk, MetaDataParser, BackupProvider, cloneArray, fromHex */
/**
 * description MediaRouter
 * @class MediaRouter
 */
function MediaRouter() {
  "use strict";

  var version = '1.0.0';
  var mediarouter_log = log4javascript.getLogger('router');

  //common variables
  var BROWSERTYPE = BrowserDetect(); //ie, safari, chrome, firefox

  //video variables
  var videoPlayer = null;
  var videoCodec = null;
  var videoSize = null;
  var videoWidth = null;
  var videoHeight = null;

  var SPSParser = null;

  /* eslint-disable no-magic-numbers */
  var MEGA_SIZE = 1 << 20;
  var XGA_SIZE = 1024 * 768;
  var FHD_SIZE = 1920 * 1080;
  /* eslint-enable no-magic-numbers */

  var limitSize = {
    "Live": 1 * MEGA_SIZE,
    "Playback": XGA_SIZE,
  };

  var videoElement = null;
  var tagMode = "canvas";
  var lastRenderingTime = null;
  var speedValue = 1;
  var dropOut = 1;
  var ULTRA_SPEED = 4;
  var DROP_OUT_LEVEL = 2;
  var defaultVideoMode = null;
  var requestTime = null;

  //Time sync variables
  var videoNTPDateTime = null;
  var rtcpTSid1 = null;
  var metaNTPDateTime = null;
  var rtcpTSid3 = null;

  //audio variables
  var audioPlayer = null;
  var audioCodec = null;
  var audioBitrate = null;
  var audioTalker = null;

  //metadata variables
  var metaDataParser = null;

  //backup variables
  var backupProvider = null;
  var isBackup = false;

  //callback variables
  var errorCallback = null;
  var timeStampCallback = null;
  var resizeCallback = null;
  var stepRequestCallback = null;
  var videoModeCallback = null;
  var rtpClientCallback = null;
  var statisticsCallback;
  var captureCallback;
  var instantplaybackCallback;
  var stepObj = null;
  var deviceType;

  //step variables
  var stepFlag = false;
  var stepCmd = "forward";
  var stepStatus = "request";

  //minimap variables
  var minimapTarget = null;
  var minimapUpdateTimer = null;

  var currentProfile = {
    'codec': '',
    'size': 0,
    'isLimitSpeed': false,
  };

  // 16:9 HD resolution
  var widthHD = 1920;
  var heightHD = 1080;
  var LIMIT_SPEED_RESOLUTION = widthHD * heightHD;

  var _self;

  function Constructor() {
    _self = this;
    Constructor.prototype.audioVolume = 0;
    Constructor.prototype.minRemainTime = 5;
    Constructor.prototype.minTimerInterval = 1;
    Constructor.prototype.mute = true;
    Constructor.prototype.drop = false;
    Constructor.prototype.boxsize = 4;
  }

  function initVideoPlayer() {
    if (videoPlayer !== null) {
      videoPlayer.close();
    }
    videoPlayer = null;
    videoSize = null;
    videoCodec = null;

    tagMode = 'canvas';
    deviceType = _self.getDeviceType();
  }

  function spsParse(sps, codecType) {
    if (videoCodec !== codecType) {
      SPSParser = (codecType === "H264" ? new H264SPSParser() : new H265SPSParser());
    }

    SPSParser.parse(sps);
  }

  function setVideoMode(mode) {
    tagMode = mode;

    if (videoModeCallback !== null && videoModeCallback !== undefined) {
      mediarouter_log.info("videoModeCallback channelId: ", _self.getChannel());
      videoModeCallback({
        channelId: _self.getChannel(),
        elementId: _self.getElement(),
        mode: tagMode
      });
    }

    if (tagMode === "canvas") {
      videoElement = getElementByAttributeValue('canvas', 'kind-channel-mapped-id', _self.getElement());

      if (videoElement === undefined) {
        videoElement = getElementByAttributeValue('canvas', 'kind-channel-mapped-id', _self.getChannel());
        if (typeof videoElement === 'undefined') {
          videoElement = getElementByAttributeValue('canvas', 'kind-channel-id', _self.getChannel());
        }
      }
    } else {
      videoElement = getElementByAttributeValue('video', 'kind-channel-mapped-id', _self.getElement());

      if (videoElement === undefined || videoElement === null) {
        videoElement = getElementByAttributeValue('video', 'kind-channel-mapped-id', _self.getChannel());
        if (typeof videoElement === 'undefined' ||  videoElement === null) {
          videoElement = getElementByAttributeValue('video', 'kind-channel-id', _self.getChannel());
        }
      }
    }
    mediarouter_log.debug("setVideoMode: channel", _self.getChannel(), ", video element id: ", videoElement.id)
  }

  function getFrameSizeInfo(codecType, videoInfo) {
    var sizeInfo = {
      'width': 0,
      'height': 0,
      'decodeSize': 0,
      'cropWidth': 0,
      'cropHeight': 0
    };

    if (codecType !== "MJPEG") {
      spsParse(videoInfo.spsPayload, codecType);

      videoInfo.width = SPSParser.getSizeInfo().width;
      videoInfo.width += SPSParser.getSizeInfo().cropWidth;

      videoInfo.height = SPSParser.getSizeInfo().height;

      sizeInfo = SPSParser.getSizeInfo();
    }

    sizeInfo.decodeSize = videoInfo.width * videoInfo.height;

    return sizeInfo;
  }

  /**
   * if MJPEG has limit when over 2M pixels(resolution).
   * limit playback speed
   * @function checkValidSpeed
   * @param  {string} codecType Codec Type
   * @param  {any} size
   * @return {void}
   */
  function checkValidSpeed(codecType, size) {
    if (currentProfile.codec === codecType &&
      currentProfile.size === size) {
      return;
    }
    if (codecType === 'MJPEG' &&
      size > LIMIT_SPEED_RESOLUTION) {
      if (currentProfile.isLimitSpeed === null ||
        currentProfile.isLimitSpeed === false) {
        currentProfile.isLimitSpeed = true;
        errorCallback({
          errorCode: fromHex('0x0302'),
          oldErrorCode: "103",
          isLimit: true,
          description: "limit speed",
          place: "mediaRouter.js:197",
          channelId: _self.getChannel()
        });
      }
    } else {
      if (currentProfile.isLimitSpeed === null ||
        currentProfile.isLimitSpeed === true) {
        currentProfile.isLimitSpeed = false;
        errorCallback({
          errorCode: fromHex('0x0302'),
          oldErrorCode: "103",
          isLimit: false,
          description: "default speed list",
          place: "mediaRouter.js:210",
          channelId: _self.getChannel()
        });
      }
    }
    currentProfile.codec = codecType;
    currentProfile.size = size;
  }

  function selectVideoPlayer(channelid, playMode, codecType, size, framerate) {
    var fps = (typeof framerate === "undefined" ? 0 : framerate);
    var player = null;

    if (videoPlayer !== null) {
      videoPlayer.close();
      videoPlayer = null;
    }

    tagMode = "canvas";
    if (stepFlag === true) {
      player = new CanvasTagPlayer();
      return player;
    }
    if (playMode === 'Playback') {
      checkValidSpeed(codecType, size);
    }

    switch (codecType) {
      case "MJPEG":
        tagMode = "canvas";
        break;
      case "H264":
      case "H265":
        var mimeType = 'video/mp4;codecs="' + SPSParser.getCodecInfo() + '"';
        if (MediaSource.isTypeSupported(mimeType)) {
          if (codecType === "H264") {
            if (_self.getDeviceType() === "nvr") {
              tagMode = "video";
            } else if (defaultVideoMode !== null) {
              tagMode = defaultVideoMode;
            } else {
              tagMode = size > limitSize[playMode] ? "video" : "canvas";
            }
          } else { // codecType === "H265"
            tagMode = "video";
          }
        } else {
          if ((codecType === "H264" && size > FHD_SIZE) ||
            (codecType === "H265" && SPSParser.getProfileName() !== "Main")) {
            errorCallback({
              errorCode: fromHex('0x0301'),
              oldErrorCode: "996",
              description: "Not enough decoding for currnet profile, Change UWA profile",
              place: "mediaRouter.js:331",
              channelId: _self.getChannel()
            });
          } else {
            tagMode = "canvas";
          }
        }
        break;
      default:
        mediarouter_log.error("Undefineded Audio codecType = " + codecType);
        break;
    }

    if (tagMode === "video") {
      player = new VideoTagPlayer();
      player.setDeviceType(deviceType);
      if (requestTime && player.setRequestTime) {
        player.setRequestTime(requestTime);
      }
    } else { // "canvas"
      player = new CanvasTagPlayer();
    }
    setVideoMode(tagMode);

    // if device type is NVR, change default delay time
    if(_self.getDeviceType()  === 'nvr') {
      player.setDefaultDelay(1.0);
    }

    player.useDropPacket(_self.isDropPacket());
    player.addEventListener('statistics', statisticsCallback);
    player.addEventListener('capture', captureCallback);
    player.addEventListener('instantplayback', instantplaybackCallback);
    player.setFrameRate(fps);
    mediarouter_log.debug("max Instant playback time: " + _self.getMaxInstantPlaybackTime() + ", interval: " + _self.getBufferClearInterval());

    player.setMaxInstantPlayback(_self.getMaxInstantPlaybackTime());
    player.setBufferClearInterval(_self.getBufferClearInterval());
    player.setBoxSize(_self.getBoxSize());
    mediarouter_log.info("Channel Idx: " + channelid + ", Video Tag type = " + tagMode);

    return player;
  }

  function sendTimeStamp(timeStamp) {
    if (timeStampCallback !== null) {
      lastRenderingTime = timeStamp;
      timeStampCallback(timeStamp, stepFlag);
    }
  }

  function stepRequest() {
    stepStatus = "request";
    stepFlag = true;
    initVideoPlayer();
    stepRequestCallback('request', stepObj);
  }

  function videoPlayerErrorCallback() {
    // re-initialize video player from error
    initVideoPlayer();
  }
  /**
   * Check Buffer Manager works or not
   * @function checkBufferManagerAvailable
   * @param {string} playMode "Live" or "Playback"
   * @param {string} codecType "MJPEG", "H264", "H265"
   * @return {boolean} true if H.265 stream & Playback mode
   */
  function checkBufferManagerAvailable(playMode, codecType) {
    if (playMode === 'Playback' && codecType === 'H265' && tagMode === "canvas") {
      return true;
    }
    return false;
  }

  Constructor.prototype = {
    /**
     * This function is to set channel number.
     * @function setChannel
     * @memberof MediaRouter
     * @example
     *     example: mediaRouter.setChannel(channelid);
     */
    setChannel: function (channelid) {
      Constructor.prototype.channelId = (channelid === null ? 0 : channelid);
    },
    /**
     * This function is to get channel number.
     * @function getChannel
     * @memberof MediaRouter
     * @example
     *     example: mediaRouter.getChannel();
     */
    getChannel: function () {
      return Constructor.prototype.channelId;
    },
    /**
     * This function is select or Change Player by codecType and send video data for player.
     * @function onVideoData
     * @memberof MediaRouter
     * @param {string} playMode "Live" or "Playback"
     * @param {object} streamData streamData object
     * @param {string} streamData.codecType "MJPEG", "H264", "H265"
     * @param {Uint8Array} streamData.frameData Depacketized frame data
     * @param {object} streamData.timeStamp Timestamp data object
     * @param {number} streamData.timeStamp.rtpTimeStamp RTP timeStamp
     * @param {number} streamData.timeStamp.timestamp Frame timestamp
     * @param {number} streamData.timeStamp.timestamp_usec Frame timestamp millisecond
     * @param {number} streamData.timeStamp.timezone timezone.
     * @param {object} videoInfo videoInfo object
     * @param {string} videoInfo.frameType "I" or "P"
     * @param {number} videoInfo.spsPayload sps
     * @param {number} videoInfo.ppsPayload pps
     * @param {number} videoInfo.framerate frame rate
     * @param {number} videoInfo.width width for mjpeg
     * @param {number} videoInfo.height height for mjpeg
     * @example
     *     example: mediaRouter.onVideoData(playMode, streamData, videoInfo);
     */
    onVideoData: function (playMode, streamData, videoInfo) {
      mediarouter_log.debug("mediaRouter::onVideoData: channel [", this.getChannel(), "] rtp timestamp: [", streamData.timeStamp.rtpTimestamp , "] play mode: [", playMode, "] video info: ", JSON.stringify(videoInfo));
      var sizeInfo = 0;
      var backupData = null;
      if (isBackup === true && backupProvider !== null) {
        backupData = cloneArray(streamData.frameData);
      }

      if (videoNTPDateTime && rtcpTSid1 && streamData.timeStamp.rtpTimestamp) {
        streamData.timeStamp.utcDatetime = new Date( videoNTPDateTime.valueOf() + (streamData.timeStamp.rtpTimestamp - rtcpTSid1) );
        mediarouter_log.debug("mediaRouter::onVideoData: channel [", this.getChannel(), "] NTPDateTime : [", videoNTPDateTime.valueOf(), "] video rtptime : [", streamData.timeStamp.rtpTimestamp, "] rtcp rtptime : []", rtcpTSid1, "utcDatetime: [", streamData.timeStamp.utcDatetime.toISOString(), "] ");
      }

      if (videoInfo.frameType === "I") {
        sizeInfo = getFrameSizeInfo(streamData.codecType, videoInfo);

        //Select Player or Change Player
        if (isBackup === false || playMode === "Live") {
          if (videoCodec !== streamData.codecType || sizeInfo.decodeSize !== videoSize ||
            videoInfo.width !== videoWidth || videoInfo.height !== videoHeight || videoPlayer === null) {
            videoPlayer = selectVideoPlayer(this.channelId, playMode, streamData.codecType, sizeInfo.decodeSize, videoInfo.framerate);
            if (videoPlayer === null) {
              return;
            }
            videoPlayer.playmode = playMode.toString().toLowerCase();
            videoPlayer.channelId = this.channelId;
            videoPlayer.setTimeStampCallback(sendTimeStamp);
            videoPlayer.setErrorCallback(errorCallback);
            videoPlayer.setResizeCallback(resizeCallback);

            if (speedValue !== 1 && tagMode === "video") {
              videoPlayer.setSpeedPlay(speedValue);
            }
            // move to select video player
            setVideoMode(tagMode);
            videoPlayer.init(videoElement);
            videoCodec = streamData.codecType;
            videoSize = sizeInfo.decodeSize;

            if (videoInfo.width !== videoWidth ||
              videoInfo.height !== videoHeight) {
              videoWidth = videoInfo.width;
              videoHeight = videoInfo.height;

              var videoResizeInfo = {
                channelId: this.channelId,
                elementId: _self.getElement(),
                tagmode: tagMode,
                width: videoWidth,
                height: videoHeight
              };
              if (resizeCallback !== undefined && resizeCallback !== null) {
                resizeCallback(videoResizeInfo);
              }
            }
          }
        }
      } else {
        if (videoWidth !== null) {
          videoInfo.width = videoWidth;
          videoInfo.height = videoHeight;
        }
      }

      if (videoPlayer !== null) {
        videoInfo.dropOut = dropOut;
        if (tagMode === "video" && videoInfo.frameType === "I") {
          videoInfo.codecInfo = SPSParser.getCodecInfo();
          if (streamData.codecType === "H264") {
            videoInfo.profileIdc = SPSParser.getSpsValue("profile_idc");
            videoInfo.levelIdc = SPSParser.getSpsValue("level_idc");
          }
          else if (streamData.codecType === "H265") {
            videoInfo.profileTierLevel = SPSParser.getProfileTierLevel();
          }
        }
        var isBufferManagerAvailable = checkBufferManagerAvailable(playMode, streamData.codecType);
        if (stepFlag === true) {
          // make NVR branch because NVR is not same of step playback between Camera.
          if(this.getDeviceType() === 'camera') {
            var ret = videoPlayer.bufferingVideoData(playMode, streamData, videoInfo);
            if (ret === false && stepStatus === "request") {
              stepStatus = "complete";
              stepRequestCallback('complete');
              videoPlayer.controlStepPlay(lastRenderingTime, stepCmd);
            }
          } else {
            videoPlayer.onVideoData(playMode, streamData, videoInfo);

            stepStatus = "complete";
            stepRequestCallback('complete');
          }
        } else if (stepFlag === false && isBufferManagerAvailable === false) {
          videoPlayer.onVideoData(playMode, streamData, videoInfo);
        } else {
          videoPlayer.sendToBufferManager(playMode, streamData, videoInfo, errorCallback);
        }
      }

      if (backupData !== null) {
        streamData.frameData = backupData;
        backupProvider.onVideoData(streamData, videoInfo);
      }
    },
    /**
     * This function is select or Change Player by codecType and send audio data for player.
     * @function onAudioData
     * @memberof MediaRouter
     * @param {string} playMode "Live" or "Playback"
     * @param {object} streamData streamData object
     * @param {string} streamData.codecType "G711", "G726", "AAC"
     * @param {Uint8Array} streamData.frameData Depacketized audio data
     * @param {number} streamData.rtpTimeStamp RTP timeStamp
     * @param {object} audioInfo audioInfo
     * @param {number} audioInfo.bitrate bitrate
     * @example
     *     example: mediaRouter.onAudioData(playMode, streamData, audioInfo);
     */
    onAudioData: function (playMode, streamData, audioInfo) {
      mediarouter_log.debug("mediaRouter::onAudioData: channel [", this.getChannel(), "] rtp timestamp: [", streamData.timeStamp.rtpTimestamp , "] play mode: [", playMode, "] audio info: ", JSON.stringify(audioInfo));
      var backupData = null;
      try {
        if (isBackup === true && backupProvider !== null) {
          backupData = cloneArray(streamData.frameData);
        }

        if(!this.mute) {
          if (audioPlayer === null || typeof audioPlayer === "undefined") {
            this.createAudioPlayer(streamData.codecType);
          }
          if (audioCodec !== streamData.codecType ||
            (streamData.codecType === "G726" && audioBitrate !== audioInfo.bitrate)) {
              audioCodec = streamData.codecType;
              audioBitrate = audioInfo.bitrate;
              audioPlayer.setInitVideoTimeStamp(0);
              audioPlayer.audioInit(streamData.codecType, audioInfo.bitrate, this.getAudioVolume());
              // audioPlayer.setBufferingFlag(streamData.rtpTimestamp, "init");
              audioPlayer.Play();
          }
        } else {
          if(audioPlayer !== null) {
            this.deleteAudioPlayer();
            return;
          }
        }

// =======
//       if ( isBackup === true && backupProvider !== null) {
//         backupData = cloneArray(streamData.frameData);
//       }

//       if (audioCodec !== streamData.codecType ||
//           (streamData.codecType === "G726" && audioBitrate !== audioInfo.bitrate) ||
//           audioPlayer === null) {
//         audioPlayer = new AudioPlayerGxx();
//         audioCodec = streamData.codecType;
//         audioBitrate = audioInfo.bitrate;
//         audioPlayer.setInitVideoTimeStamp(0);
//         audioPlayer.audioInit(streamData.codecType, audioInfo.bitrate, audioVolume);
//         // audioPlayer.setBufferingFlag(streamData.timeStamp.rtpTimestamp, "init");
//       }
// >>>>>>> UMP3.1

        if (audioPlayer !== null && audioPlayer.isInit() === true && audioPlayer.getChannel() === this.getChannel()) {
          if (isBackup === false || playMode === "Live") {
            mediarouter_log.debug("input audio data from channel: ", this.getChannel());
            audioPlayer.BufferAudio(streamData.frameData, streamData.timeStamp.rtpTimestamp);
            audioPlayer.setBufferingFlag(streamData.timeStamp.rtpTimestamp, "currentTime");
          }
        }
        if (backupData !== null) {
          streamData.frameData = backupData;
          backupProvider.receiveAudioData(streamData, audioInfo);
        }
      } catch (error) {
        throw new umpError({
          channelId: this.channelId,
          errorCode: fromHex('0x030B'),
          place: 'mediaRouter.js:609',
          message: "onAudioData from mediaRouter: errorcode [" + error.errorCode + "], message  [" + error.message + "]"
        });
      }
    },
    /**
     * To receive Metadata from rtpClient
     * @function onMetadata
     * @memberof MediaRouter
     * @param {Uint8Array} metadata metadata
     * @return ?
     * @example
     *     example:
     */
    onMetadata: function (metadata) {
      mediarouter_log.debug("mediaRouter::onMetadata: channel [", this.getChannel(), "] rtp timestamp: [", metadata.timeStamp.rtpTimestamp, "]");
      if (metaDataParser !== null) {
        metaDataParser.parse(metadata.frameData);
      }
    },
    /**
     * To receive RTCP data from rtcpSession
     * @function onRtcpData
     * @memberof MediaRouter
     * @param {Object} rtcpdata rtcpdata
     * @return ?
     * @example
     *     example:
     */
    onRtcpData: function (rtcpdata) {
      mediarouter_log.debug("mediaRouter::onRtcpData: channel [", this.getChannel(), "] rtcp info: ", JSON.stringify(rtcpdata));
      var utcDatetime = new Date( rtcpdata.timeStamp.timestamp * 1000 + rtcpdata.timeStamp.timestamp_usec )
      if (rtcpdata.interleaved === 1) {
        videoNTPDateTime = utcDatetime;
        rtcpTSid1 = rtcpdata.rtpTimestamp;
      } else if (rtcpdata.interleaved === 3) {
        metaNTPDateTime = utcDatetime;
        rtcpTSid3 = rtcpdata.rtpTimestamp;
      }
    },
    /**
     * To init audio player
     * @function controlAudioPlayer
     * @memberof MediaRouter
     * @param {object} data sendAduioTalkBufferCallback
     * @return ?
     * @example
     *     example:
     */
    controlAudioPlayer: function (data) {
      if (audioPlayer !== null) {
        if (data === 'on' || data === 'unmute') {
          mediarouter_log.info("already start audio decoder, set volume");
          this.mute = false;
        } else if (data === 'off' || data === 'mute') {
          this.mute = true;
          mediarouter_log.info("destory audio player and mute channel: ", this.getChannel());
        } else {
          if(Number.isInteger(Number(data))) {
            this.setAudioVolume(data);
            audioPlayer.ControlVolume(data);
          } else {
            mediarouter_log.warn("this is not audio volume value");
            throw new umpError({
              channelId: this.getChannel(),
              errorCode: fromHex('0x030E'),
              place: 'mediaRouter.js:362',
              message: 'audio volume do not set'
            });
          }
        }
      } else {
        if(data === 'unmute' || data === 'on') {
          this.mute = false;
          //this.createAudioPlayer();
        }
        // if data is not constant rule, set to audio volume when data is integer value
        if (!(data === 'on' || data === 'off' || data === 'mute' || data === 'unmute')) {
          if(Number.isInteger(Number(data))) {
            this.setAudioVolume(data);
          } else {
            mediarouter_log.warn("this is not audio volume value");
            throw new umpError({
              channelId: this.getChannel(),
              errorCode: fromHex('0x030E'),
              place: 'mediaRouter.js:389',
              message: 'audio volume do not set'
            });
          }
        }
      }
    },
    createAudioPlayer: function(codec) {
      if(audioPlayer === null) {
        mediarouter_log.info("generate audio player and unmute channel: ", this.getChannel());

        switch (codec) {
          case 'G711':
          case 'G726':
            audioPlayer = new AudioPlayerGxx();
            break;
          case 'AAC':
            // this object dependent to audio tag player
            //audioPlayer = new AudioPlayerAAC();
            audioPlayer = new AudioPlayerGxx();
            break;
          default:
            mediarouter_log.warn("this audio codec is not supported from this client.");
            break;
        }

        audioPlayer.setChannel(this.getChannel());

        if(this.getAudioVolume() !== 0) {
          audioPlayer.ControlVolume(this.getAudioVolume());
        }
      }
    },
    deleteAudioPlayer: function() {
      if(audioPlayer !== null) {
        audioPlayer.Stop();
        audioPlayer.terminate();
        audioPlayer = null;
        audioCodec = null;
        audioBitrate = null;
      }
    },
    /**
     * To init audio talk provider
     * @function startAudioTalk
     * @memberof MediaRouter
     * @param {function} sendAudioTalkBuffer sendAduioTalkBufferCallback
     * @return ?
     * @example
     *     example:
     */
    startAudioTalk: function (sendAudioTalkBuffer) {
      return new Promise(function (resolve, reject) {
        audioTalker = new Talk();

        if (audioTalker.init()) {
          audioTalker.setSendAudioTalkBufferCallback(sendAudioTalkBuffer);
          audioTalker.initAudioOut().then(function (_sampleRate) {
            resolve(_sampleRate);
          }).catch(function (error) {
            errorCallback({
              errorCode: fromHex('0x020A'),
              description: "Talk service unavailable",
              place: "mediaRouter:649",
              channelId: _self.getChannel()
            });
            reject(new Error("Failure"));
          });
        } else {
          errorCallback({
            errorCode: fromHex('0x020A'),
            description: "Talk service unavailable",
            place: "mediaRouter:658",
            channelId: _self.getChannel()
          });
          reject(new Error("Web Audio API is not supported in this web browser"));
        }
      });
    },
    /**
     * To received statistics data from rtpSession
     * @function onStatistics
     * @memberof MediaRouter
     * @param {object} statistics statistics data
     *                                        {"channelId":0,"type":"drop","queue":0,"fps":1,"interval":0,"receviedPacket":120,"droppedPacket":0}
     */
    onStatistics: function (statistics) {
      // change box size of video player
      this.changeBoxSize(statistics.fps);
      // send statistics data to application
      if (statisticsCallback !== undefined) {
        mediarouter_log.debug("Statistics: " + JSON.stringify(statistics));
        statisticsCallback(statistics);
      }
    },
    /**
     * change box size to video player
     * @function changeBoxSize
     * @memberof MediaRouter
     * @param {number} fps frame rate
     *                                        {"channelId":0,"type":"drop","queue":0,"fps":1,"interval":0,"receviedPacket":120,"droppedPacket":0}
     */
    changeBoxSize: function (fps) {
      if (videoPlayer !== undefined && videoPlayer !== null) {
        if (fps > 30 && videoPlayer.getBoxSize() !== 5) {
          videoPlayer.setBoxSize(5);
        } else if ((fps > 20 && fps <= 30) && videoPlayer.getBoxSize() !== 4) {
          videoPlayer.setBoxSize(4);
        } else if ((fps > 10 && fps <= 20) && videoPlayer.getBoxSize() !== 3) {
          videoPlayer.setBoxSize(3);
        } else if ((fps > 5 && fps <= 10) && videoPlayer.getBoxSize() !== 2) {
          videoPlayer.setBoxSize(2);
        } else if (fps < 5 && videoPlayer.getBoxSize() !== 1) {
          videoPlayer.setBoxSize(1);
        } else {
          mediarouter_log.debug("mediaRouter::changeBoxSize, current fps: " + fps + ", same boxsize: " + videoPlayer.getBoxSize());
          //videoPlayer.setBoxSize(1);
          // TODO: wrong fps value
        }
      }
    },
    /**
     * This function is to excute, set, etc for media.
     * @function sendCommandData
     * @memberof MediaRouter
     * @param {string} type command type
     * @param {object} data data
     * @example
     *     example: mediaRouter.sendCommandData(type, data);
     */
    sendCommandData: function (type, data) {
      var command = '';
      switch (type) {
        case 'capture':
          if (videoPlayer !== null) {
            videoPlayer.capture(data);
          }
          break;
        case 'backup':
          command = data.command;
          if (command === 'start') {
            isBackup = true;
            backupProvider = new BackupProvider(data.callback);
            backupProvider.init(data.callback, data.fileName);
          } else if (backupProvider !== null && command === 'stop') {
            isBackup = false;
            backupProvider.closeStream();
          }
          break;
        case 'forward':
          stepCmd = "forward";
          if (stepFlag === false) {
            stepRequest();
          } else {
            if (!videoPlayer.forward()) {
              stepStatus = "request";
              stepRequestCallback('request', stepObj);
//              mediarouter_log.info("last lendering time = ", JSON.stringify(lastRenderingTime));
            }
          }
          break;
        case 'backward':
          stepCmd = "backward";
          if (stepFlag === false) {
            stepRequest();
          } else {
            if (!videoPlayer.backward()) {
              stepStatus = "request";
              stepRequestCallback('request', stepObj);
            }
          }
          break;
        case 'speed':
          speedValue = data;
          if (videoPlayer !== null && tagMode === "video") {
            videoPlayer.setSpeedPlay(data);
          }
          dropOut = 1;
          if (speedValue >= ULTRA_SPEED || speedValue <= -1 * ULTRA_SPEED) {
            dropOut = DROP_OUT_LEVEL;
          }
          break;
        case 'pause':
          if (videoPlayer !== null) {
            videoPlayer.pause();
            return true;
          } else {
            return false;
          }
          break;
        case 'resume':
          if (stepFlag === true) {
            stepFlag = false;
            initVideoPlayer();
          } else {
            if ( videoPlayer !== null) {
              videoPlayer.resume();
            }
            if (data === true) { //Immediate:yes
              initVideoPlayer();
            }
          }
          break;
        case 'seek':
          initVideoPlayer();
          break;
        case 'audioIn':
          this.controlAudioPlayer(data);
          break;
        case 'digitalZoom':
          if (videoPlayer !== null && tagMode !== "video") {
            videoPlayer.digitalZoom(data);
          }
          break;
        case 'clearBuffer':
          if (stepFlag === true) {
            videoPlayer.clearBuffer();
            stepFlag = false;
          }
          break;
        case 'changeVideoMode':
          defaultVideoMode = data;
          break;
        case 'minimap':
          if (data.mode === 'on') {
            if ( videoPlayer !== null) {
              videoPlayer.updateMiniMapInfo({mode:'draw', target :minimapTarget});
            }
            if ( minimapUpdateTimer ) {
              clearInterval(minimapUpdateTimer);
              minimapUpdateTimer = null;
            }
            minimapUpdateTimer = setInterval(function(){
              if (videoPlayer) {
                videoPlayer.updateMiniMapInfo({mode:'draw', target :minimapTarget});
              }
            }, 3000);
            minimapTarget = data.target || null;
          } else if ( data.mode ==='off') {
            clearInterval(minimapUpdateTimer);
            minimapUpdateTimer = null;
            minimapTarget = null;
          }
          if (videoPlayer !== null) {
            videoPlayer.updateMiniMapInfo(data);
          }
          break;
        case 'requestTimeChanged':
          if (BROWSERTYPE !== "firefox") {
            requestTime = data;
          }
          break;
        default:
          mediarouter_log.error("mediaRouter::sendCommadnData type is unknwon");
          break;
      }
    },
    /**
     * This function is to add event,callback listener.
     * @function addListener
     * @memberof MediaRouter
     * @param {string} type listener type
     * @param {function} func function
     * @example
     *     example: mediaRouter.addListener(type, function);
     */
    addListener: function (type, func, data) {
      switch (type) {
        case 'timeStamp':
          timeStampCallback = func;
          break;
        case 'resize':
          resizeCallback = func;
          break;
        case 'stepRequest':
          stepRequestCallback = func;
          stepObj = data;
          break;
        case 'metaEvent':
          var eventNotificationCallback = func;
          metaDataParser = new MetaDataParser(eventNotificationCallback);
          metaDataParser.setChannel(_self.getChannel());
          break;
        case 'videoMode':
          videoModeCallback = func;
          break;
        case 'rtpClient':
          rtpClientCallback = func;
          break;
        case 'error':
          errorCallback = func;
          break;
        case 'statistics':
          statisticsCallback = func;
          break;
        case 'capture':
          captureCallback = func;
          break;
        case 'instantplayback':
          instantplaybackCallback = func;
          break;
        default:
          mediarouter_log.error("MediaRouter::addListener type is unknown: [" + type + "]");
          break;
      }
    },
    /**
     * This function is to close players.
     * @function terminate
     * @memberof MediaRouter
     * @example
     *     example: mediaRouter.terminate();
     */
    terminate: function () {
      if (videoPlayer !== null) {
        videoPlayer.close();
        videoPlayer = null;
        videoCodec = null;
        videoSize = null;
        videoWidth = null;
        videoHeight = null;
      }

      this.deleteAudioPlayer();

      if (audioTalker !== null) {
        audioTalker.terminate();
        audioTalker = null;
      }
      if (rtpClientCallback !== null) {
        rtpClientCallback('close', '');
      }
      videoElement = null;
      stepFlag = false;
    },
    getVideoWidth: function () {
      return videoWidth;
    },
    getVideoHeight: function () {
      return videoHeight;
    },
    getVideoCodecType: function () {
      return videoCodec;
    },
    getDeviceType: function () {
      return deviceType;
    },
    setDeviceType: function (type) {
      deviceType = type;
    },
    setMaxInstantPlaybackTime: function (thresholdInstantPlayback) {
      Constructor.prototype.minRemainTime = thresholdInstantPlayback;
    },
    getMaxInstantPlaybackTime: function () {
      return Constructor.prototype.minRemainTime;
    },
    setBufferClearInterval: function (interval) {
      Constructor.prototype.minTimerInterval = interval;
    },
    getBufferClearInterval: function () {
      return Constructor.prototype.minTimerInterval;
    },
    setAudioVolume: function (volume) {
      Constructor.prototype.audioVolume = volume;
    },
    getAudioVolume: function () {
      return Constructor.prototype.audioVolume;
    },
    setProfile: function (profile) {
      Constructor.prototype.profile = profile;
    },
    getProfile: function () {
      return Constructor.prototype.profile;
    },
    setElement: function (element) {
      Constructor.prototype.DOMElement = element;
    },
    getElement: function () {
      return Constructor.prototype.DOMElement;
    },
    useDropPacket: function(useDropPacket) {
      Constructor.prototype.drop = useDropPacket;
    },
    isDropPacket: function() {
      return Constructor.prototype.drop;
    },
    setBoxSize: function(boxsize) {
      Constructor.prototype.boxsize = boxsize;
    },
    getBoxSize: function() {
      return Constructor.prototype.boxsize;
    }
  };

  /**
   * This property is to return the audio mute state.
   * @property audio mute state
   * @memberof mediaRouter
   * @example
   *     Session.mute = 0;
   */
  Object.defineProperty(this, "mute", {
    get: function() {
        return mute;
    },
    set: function(v) {
      mute = v;
    },
  });


  return new Constructor();
}

var RTCPSession = function () {
  "use strict";

  var version = '1.0.0';
  var rtcp_session_log = log4javascript.getLogger('rtcpsession');

  var rtcpVersion,
        rtcpPadding,
        rtcpCount,
        rtcpType,
        rtcpLength,
        SSRC = new Uint8Array(4),
        NTP_MSW = new Uint8Array(4), // NTP timestamp, most significant word
        NTP_LSW = new Uint8Array(4), // NTP timestamp, least significant word
        RTP = new Uint8Array(4); // NTP timestamp, least significant word
  var header_offset = 0;

  function Constructor() {
    Constructor.prototype.codec = "";
    Constructor.prototype.rtcpSession = null;
  }

  Constructor.prototype = inheritObject(new Session(), {
    init: function () {
      rtcp_session_log.info("RTCPSession::init");
    },
    depacketize: function (rtspInterleaved, rtcpHeader, rtpPayload) {
      rtcp_session_log.info("RTCPSession::depacketize");

      rtcpVersion = (rtcpHeader[0] & 0xC0) >> 6;
			rtcpPadding = (((rtcpHeader[0] & 0x20) >> 5) === 1);
			rtcpCount = rtcpHeader[0] & 0x1F;
			rtcpType = rtcpHeader[1];
			rtcpLength = (rtcpHeader[2] << 8) + rtcpHeader[3];

      if(rtcpType === 200) {
        rtcp_session_log.info("interleaved id = ", this.interleavedId, "RTCP Header: version = ", rtcpVersion, ", Padding = " , rtcpPadding, ", Count = ", rtcpCount,
        ", Type = ", rtcpType, "Length = ", rtcpLength);

        header_offset = 4;
        SSRC.set(rtcpHeader.subarray(header_offset, header_offset + 4), 0);

        rtcp_session_log.info("interleaved id = ", this.interleavedId, "SSRC of sender = ", this.ntohl(SSRC));

        header_offset += 4;
        NTP_MSW.set(rtcpHeader.subarray(header_offset, header_offset + 4), 0);
        // this.mostSignificantWord = this.ntohl(NTP_MSW);

        header_offset = 0;
        NTP_LSW.set(rtpPayload.subarray(header_offset, header_offset + 4), 0);
        // this.leastSignificantWord = this.ntohl(NTP_LSW);

        var tempdata = {};
        tempdata.timestamp = ((this.ntohl(NTP_MSW) - 0x83AA7E80) >>> 0);
        tempdata.timestamp_usec = (this.ntohl(NTP_LSW) / 0xffffffff) * 1000;
        this.SetTimeStamp(tempdata);

        rtcp_session_log.info("----------- interleaved id = ", this.interleavedId, "NTP_MSW = ", this.timeData.timestamp, ", NTP_LSW = ", this.timeData.timestamp_usec);

        header_offset += 4;
        RTP.set(rtpPayload.subarray(header_offset, header_offset + 4), 0);
        this.rtpTimestamp = (this.ntohl(RTP)/90).toFixed(0);

        rtcp_session_log.info("interleaved id = ", this.interleavedId, "RTP = ", this.rtpTimestamp);

        var data = {
          interleaved: this.interleavedId,
          //utcDatetime: new Date( this.timeData.timestamp * 1000 + this.timeData.timestamp_usec )
          'timeStamp': {
						'rtpTimestamp': this.rtpTimestamp,
						'timestamp': this.timeData.timestamp,
						'timestamp_usec': this.timeData.timestamp_usec,
						'timezone': this.timeData.timezone
					},
        }

        this.eventRtcpCallback(data);
      }
    },
    close: function() {
      rtcp_session_log.info("RTCPSession::close");
    },

  });

  return new Constructor();
};
/* global H264Session, H265Session, MjpegSession, AudioTalkSession,
  G711Session, G726Session, AACSession, MetaSession */

/**
 * To manage RtpSession
 * @class RtpClient
 * @param {object} mediaRouter object
 * @example
 *  var rtpClient = new RtpClient(mediaRouter);
 */
function RtpClient(mediaRouter) {
  "use strict";

  var version = '1.0.0';
  var rtpclient_log = log4javascript.getLogger('rtpclient');

  var sessionArray = [];
  var sendAudioTalkDataCallback = null;
  var audioTalkSession = null;

  /**
   * description
   * @function mediaRouterMessage
   * @memberof RtpClient
   * @param {string} msgType mediaRouterMessageType
   * @param {object} data mediaRouter Data
   * @return ?
   * @example
   *     example:
   */
  function mediaRouterMessage(msgType, data) {
    switch (msgType) {
      case 'close' :
        if (sessionArray.length > 0){
          sessionArray.forEach(function(session) {
            session.close();
          });
          sessionArray = [];
        }
        break;
      case 'backup':
        /*
            data : {
                command: 'stop'
            }
            data : {
                command: 'start'
                filename: fileName
            }
        */
        break;
      case 'stepPlay':
        /*
            data : 'findIFrame'
            data : {direction: 'forward', 'backward', 'playbackPause', 'playbackResume', 'playbackSeek', 'playToggle', 'needBuffering', 'bufferFull'}
        */
        break;
      case 'bufferFree':
        /*
            data : bufferIdx
        */
        break;
      case 'audioBackup':
        /*
            data : 'start', 'stop'
        */
        break;
      default:
      rtpclient_log.error("Invalild mediaRouter cmd");
    }
  }
  /**
   * Recevied from video media data from rtp session, send video frame to mediaRouter
   * @function onVideoFrameData
   * @memberof RtpClient
   * @param {string} playMode "Live" or "Playback"
   * @param {object} streamData video streamData object
   * @param {string} streamData.codecType "MJPEG", "H264", "H265"
   * @param {Uint8Array} streamData.frameData Depacketized frame data
   * @param {object} streamData.timestamp Timestamp data object
   * @param {number} streamData.timestamp.rtpTimeStamp RTP timeStamp
   * @param {number} streamData.timestamp.timestamp Frame timestamp
   * @param {number} streamData.timestamp.timestamp_usec Frame timestamp millisecond
   * @param {number} streamData.timestamp.timezone timezone.
   * @param {object} videoInfo videoInfo object
   * @param {string} videoInfo.frameType "I" or "P"
   * @param {number} videoInfo.spsPayload sps
   * @param {number} videoInfo.ppsPayload pps
   * @param {number} videoInfo.framerate frame rate
   * @param {number} videoInfo.width width for mjpeg
   * @param {number} videoInfo.height height for mjpeg
   * @return ?
   * @example
   *     example:
   */
  function onVideoFrameData(playMode, streamData, videoInfo) {
    mediaRouter.onVideoData(playMode, streamData, videoInfo);
  }
  /**
   * Recevied from audio media data from rtp session, send audio frame to mediaRouter
   * @function onAudioFrameData
   * @memberof RtpClient
   * @param {string} playMode "Live" or "Playback"
   * @param {object} streamData audio streamData object
   * @param {string} streamData.codecType "G711", "G726", "AAC"
   * @param {Uint8Array} streamData.frameData audio data
   * @param {number} streamData.rtpTimeStamp RTP timeStamp
   * @param {object} audioInfo audioInfo object
   * @param {number} audioInfo.bitrate audio bitrate
   * @return ?
   * @example
   *     example:
   */
  function onAudioFrameData(playMode, streamData, audioInfo) {
    mediaRouter.onAudioData(playMode, streamData, audioInfo);
  }
  /**
   * Recevied from meta media data from rtp session, send meta data to mediaRouter
   * @function onMetadata
   * @memberof RtpClient
   * @param {Uint8Array} metadata metadata
   * @return ?
   * @example
   *     example:
   */
  function onMetadata(metadata) {
    mediaRouter.onMetadata(metadata);
  }
  /**
   * To send audioTalkData to websocket
   * @function sendAudioTalkData
   * @memberof RtpClient
   * @param {Uint8Array} stream audiotalk stream data
   * @return ?
   * @example
   *     example:
   */
  function sendAudioTalkData(stream) {
    var rtpPacket = audioTalkSession.getRTPPacket(stream);
    sendAudioTalkDataCallback(rtpPacket);
  }
  /**
   * Recevied from statistics data from rtp session, send statistics data to mediaRouter
   * @function onStatistic
   * @memberof RtpClient
   * @param {JSON} statistics statistics data
   * @return ?
   * @example
   *     example:
   */
  function onStatistics(statistics) {
    mediaRouter.onStatistics(statistics);
  }
    /**
   * Recevied from statistics data from rtp session, send statistics data to mediaRouter
   * @function onStatistic
   * @memberof RtpClient
   * @param {JSON} statistics statistics data
   * @return ?
   * @example
   *     example:
   */
  function onRtcpData(rtcp) {
    mediaRouter.onRtcpData(rtcp);
  }
  /**
   *
   * @param  {any} _samplate
   * @return {void}
   */
  function setSampleRate(_samplate) {
    audioTalkSession.setSampleRate(_samplate);
  }
  /**
   *
   * @param  {any} error
   * @return {void}
   */
  function onError(error) {
    console.log("error" + error.message);
  }

  function Constructor(mediaRouter) {
    mediaRouter.addListener('rtpClient', mediaRouterMessage);
    this.setChannel(mediaRouter.getChannel());
  }
  Constructor.prototype = {
    setChannel: function (channelid) {
      this.channelId = (channelid === null ? 0 : channelid);
    },
    getChannel: function () {
      return this.channelId;
    },
    /**
     * To set rtpSession array
     * @function sendSdpInfo
     * @memberof RtpClient
     * @param {object} sdpInfo sdp Information
     * @param {string} _isTalkService talk service status
     * @return ?
     * @example
     *     example:
     */
    sendSdpInfo: function (sdpInfo) {
      for (var sdpIndex = 0; sdpIndex < sdpInfo.length; sdpIndex++) {
        var rtpSession = null;
        var rtcpSession = null;
        rtpclient_log.info("Create Session: " + sdpInfo[sdpIndex].codecName);
        switch (sdpInfo[sdpIndex].codecName) {
          case 'H264':
            {
              rtpSession = new H264Session();
              rtpSession.init();
              //rtpSession.setChannel(this.channelId);
              rtpSession.setFramerate((typeof sdpInfo[sdpIndex].Framerate) === 'undefined' ? 0: sdpInfo[sdpIndex].Framerate);
              rtpSession.addEventListener('video', onVideoFrameData);
            }
            break;
          case 'H265':
            {
              rtpSession = new H265Session();
              rtpSession.init();
              //rtpSession.setChannel(this.channelId);
              rtpSession.setFramerate((typeof sdpInfo[sdpIndex].Framerate) === 'undefined' ? 0: sdpInfo[sdpIndex].Framerate);
              rtpSession.addEventListener('video', onVideoFrameData);
            }
            break;
          case 'JPEG':
            {
              rtpSession = new MjpegSession();
              rtpSession.init();
              //rtpSession.setChannel(this.channelId);
              rtpSession.addEventListener('video', onVideoFrameData);
            }
            break;
          case 'G.711':
            {
              if (sdpInfo[sdpIndex].trackID.search('trackID=t') === -1 &&
                  sdpInfo[sdpIndex].trackID.search('trackID=back') === -1) {
                var g711codecInfo = {
                  'clockFreq': sdpInfo[sdpIndex].ClockFreq,
                  'bitrate': sdpInfo[sdpIndex].Bitrate
                };
                rtpSession = new G711Session();
                rtpSession.init(g711codecInfo);
                //rtpSession.setChannel(this.channelId);
                rtpSession.addEventListener('audio', onAudioFrameData);
              } else {
                audioTalkSession = new AudioTalkSession(sdpInfo[sdpIndex].RtpInterlevedID);
                mediaRouter.startAudioTalk(sendAudioTalkData)
                .then(setSampleRate).catch(onError);
              }
            }
            break;
          case 'G.726-16':
          case 'G.726-24':
          case 'G.726-32':
          case 'G.726-40':
            {
              if (sdpInfo[sdpIndex].trackID.search('trackID=t') === -1 &&
                  sdpInfo[sdpIndex].trackID.search('trackID=back') === -1) {
                var g726codecInfo = {
                  'clockFreq': sdpInfo[sdpIndex].ClockFreq,
                  'bitrate': parseInt(sdpInfo[sdpIndex].codecName.substr(6, 2), 10)
                };
                rtpSession = new G726Session();
                rtpSession.init(g726codecInfo);
                //rtpSession.setChannel(this.channelId);
                rtpSession.addEventListener('audio', onAudioFrameData);
              }
            }
            break;
          case 'mpeg4-generic':
            {
              if (sdpInfo[sdpIndex].trackID.search('trackID=t') === -1 &&
                  sdpInfo[sdpIndex].trackID.search('trackID=back') === -1) {
                var aacCodecInfo = {
                  'config': sdpInfo[sdpIndex].config,
                  'clockFreq': sdpInfo[sdpIndex].ClockFreq,
                  'bitrate': sdpInfo[sdpIndex].Bitrate
                };
                rtpSession = new AACSession();
                rtpSession.init(aacCodecInfo);
                //rtpSession.setChannel(this.channelId);
                rtpSession.addEventListener('audio', onAudioFrameData);
              }
            }
            break;
/*          case 'MP4V-ES':
            {
              if (sdpInfo[sdpIndex].trackID.search('trackID=t') === -1 &&
                  sdpInfo[sdpIndex].trackID.search('trackID=back') === -1) {
                var aacCodecInfo = {
                  'config': sdpInfo[sdpIndex].config,
                  'clockFreq': sdpInfo[sdpIndex].ClockFreq,
                  'bitrate': sdpInfo[sdpIndex].Bitrate
                }
                rtpSession = new AACSession();
                rtpSession.init(aacCodecInfo);
                rtpSession.setChannel(this.channelId);
                rtpSession.addEventListener('video', sendAudioFrameData);
              }
            }
            break;*/
          case 'MetaData':
            {
              rtpSession = new MetaSession();
              rtpSession.init();
              //rtpSession.setChannel(this.channelId);
              rtpSession.addEventListener('text', onMetadata);
            }
            break;
        }
        if (rtpSession !== null) {
          rtcpSession = new RTCPSession();
          rtcpSession.interleavedId = sdpInfo[sdpIndex].RtcpInterlevedID;
          rtcpSession.channelId = this.channelId;
          rtcpSession.addEventListener('rtcp', onRtcpData);

          rtpSession.addEventListener('statistics', onStatistics);
          rtpSession.setDeviceType(mediaRouter.getDeviceType());
          rtpSession.codec = sdpInfo[sdpIndex].codecName;
          rtpSession.interleavedId = sdpInfo[sdpIndex].RtpInterlevedID;
          rtpSession.channelId = this.channelId;
          rtpSession.rtcpSession = rtcpSession;

          sessionArray[parseInt(sdpInfo[sdpIndex].RtpInterlevedID)] = rtpSession;
          sessionArray[parseInt(sdpInfo[sdpIndex].RtcpInterlevedID)] = rtcpSession;
        }
      }
    },
    /**
     * description
     * @function sendRtpData
     * @memberof RtpClient
     * @param {Uint8Array} rtspinterleave rtsp interlead header
     * @param {Uint8Array} rtpheader rtp header
     * @param {Uint8Array} rtpPacketArray rtp payloads
     * @return ?
     * @example
     *     example:
     */
    sendRtpData: function (rtspinterleave, rtpheader, rtpPacketArray) {
      var mediaType = rtspinterleave[1];
      if (typeof sessionArray[mediaType] !== 'undefined') { //not rtcp data
        rtpclient_log.debug("media type index = ", mediaType, ", codec = ", sessionArray[mediaType].codecName, ", length = ", rtpPacketArray.length) ;
        sessionArray[mediaType].depacketize(rtspinterleave, rtpheader, rtpPacketArray);
      }
    },
    /**
     * description
     * @function addListener
     * @memberof RtpClient
     * @param {string} type callback type
     * @param {function} func callback function
     * @return ?
     * @example
     *     example:
     */
    addListener: function (type, func) {
      switch (type) {
        case 'audioTalk':
          sendAudioTalkDataCallback = func;
          break;
        default:
          rtpclient_log.error("RtpClient::addListener type is unknown");
          break;
      }
    }
  };
  return new Constructor(mediaRouter);
}
/* global Uint8Array */

/**
 * RtpSession
 * @class RtpSession
 */
function RtpSession() {
  "use strict";

  var version = '1.0.0';
  var rtpsession_log = log4javascript.getLogger("rtpsession");

  var _self;
  var rtpPayloadCbFunc = null,
      rtpBufferingCbFunc = null,
      rtpTimestampCbFunc = null,
      rtpOutputSizeCbFunc = null,
      timeData = null,
      mediaTimer,
      timerWorker,
      statisticsTimer,
      statisticsWorker,
      timerCallback = null,
      useWorkerTimer = false;

  var currentGov = 0,
      calcGov = 0,
      govLength = null,
      dropTimeStart = 0,
      decodingTime = 0,
      dropCheckTime = 0,
      dropPer = 0,
      frameCount = 1,
      dropCount = 0,
      statisticsTimerInterval = 1000,
      decodeMode = "canvas",
      maxQueueSize = 10;
      var timeoutID;

  // function startTimer(){
  //   timer = {
  //       interval: interval
  //   }
  //   worker.postMessage(timer);
  // }
  //var mediaQueue  = new CircularTypedArrayQueue(maxQueueSize);
  //var mediaQueue = new Queue();
  var mediaQueue = new Queue(maxQueueSize);

  function Constructor() {
    this.decoder = null;
    Constructor.prototype.numberOfDroppedPacket = 0;
    Constructor.prototype.numberOfReceivedPacket = 0;
    Constructor.prototype.numberOfPrevTotalCount = 0;
    Constructor.prototype.numberOfMediaTimerCount = 0;
    Constructor.prototype.deviceType = 'camera';
    Constructor.prototype.codec = "";
    Constructor.prototype.rtcpSession = null;
    _self = this;
  }

  Constructor.prototype = inheritObject(new Session(), {
    setFrameCallback: function (rtpPayloadCallbackFunc) {
      this.rtpPayloadCbFunc = rtpPayloadCallbackFunc;
    },
    setBufferingCallback: function (rtpBufferingCallbackFunc) {
      this.rtpBufferingCbFunc = rtpBufferingCallbackFunc;
    },
    setTimestampCallback: function (rtpTimestampCallbackFunc) {
      this.rtpTimestampCbFunc = rtpTimestampCallbackFunc;
    },
    setOutputSizeCallback: function (rtpOutputSizeCallbackFunc) {
      this.rtpOutputSizeCbFunc = rtpOutputSizeCallbackFunc;
    },
    setAACCodecInfo: function (info) {},
    depacketize: function (rtspinterleave, rtpheader, rtpPacketArray) {},
    bufferingRtpData: function (rtspinterleave, rtpheader, rtpPacketArray) {},
    getRTPPacket: function (Channel, rtpPayload) {},
    calculatePacketTime: function (rtpTimeStamp) {},
    ntohl: function (buffer) {
      return (((buffer[0] << 24) + (buffer[1] << 16) +
        (buffer[2] << 8) + buffer[3]) >>> 0);
    },
    appendBuffer: function (currentBuffer, newBuffer, readLength) {
      var BUFFER_SIZE = 1024 * 1024;
      if ((readLength + newBuffer.length) >= currentBuffer.length) {
        var tmp = new Uint8Array(currentBuffer.length + BUFFER_SIZE);
        tmp.set(currentBuffer, 0);
        currentBuffer = tmp;
      }
      currentBuffer.set(newBuffer, readLength);
      return currentBuffer;
    },
    setFramerate: function (_framerate) {
      Constructor.prototype.frameRate = _framerate;
    },
    getFramerate: function () {
      return Constructor.prototype.frameRate;
    },
    setGovLength: function (_govLength) {
      govLength = _govLength;
    },
    getGovLength: function () {
      return govLength;
    },
    setDecodingTime: function (time) {
      decodingTime = time;
    },
    getDropPercent: function () {
      return dropPer;
    },
    getDropCount: function () {
      return dropCount;
    },
    initStartTime: function () {
      this.firstDiffTime = 0;
      calcGov = 0;
    },
    setCheckDelay: function (checkDelay) {
      this.checkDelay = checkDelay;
    },
    close: function() {
      this.stopMediaTimer();
      clearInterval(timeoutID);
    },
    startMediaTimer: function (interval, timercallback) {
      timerCallback = timercallback;
      var timer = {
        interval: 33
      };
      //timestamp = Math.floor(Date.now());

      if(typeof interval !== 'undefined') {
        timer.interval = interval;
      } else {
        timer.interval = Math.floor((1000/Constructor.prototype.frameRate));
      }
      _self = this;

      if (useWorkerTimer) {
        if (typeof timerWorker === 'undefined' || timerWorker === null) {
          timerWorker = new Worker('../media/ump/Worker/VideoDecoder/mediaTimerWorker.js');
          timerWorker.onmessage = this.onMediaTimer;
          timerWorker.postMessage(timer);
        }
      } else {
        // start statistics timer per frame rate
        mediaTimer = setInterval(this.onMediaTimer, timer.interva);
      }

      // start statistics timer per every 1 secomd
      statisticsTimer = setInterval(this.onStatisticsTimer, statisticsTimerInterval);
    },
    stopMediaTimer: function () {
      if (useWorkerTimer) {
        if (typeof timerWorker !== 'undefined' && timerWorker !== null) {
          timerWorker.terminate();
          timerWorker = null;
        }
      } else {
        // clear media timer
        if (typeof mediaTimer !== 'undefined' && mediaTimer !== null) {
          clearInterval(mediaTimer);
        }
      }
      // clear statistics timer
      if(typeof statisticsTimer !== 'undefined' && statisticsTimer !== null) {
        clearInterval(statisticsTimer);
      }
    },
    setStartTimeStamp: function (timeStamp) {
      Constructor.prototype.startTimestamp = timeStamp;
      Constructor.prototype.sumOfInterval = 0;
    },
    getTimerStamp: function() {
      return (Number(Constructor.prototype.startTimestamp) + Constructor.prototype.sumOfInterval);
    },
    increaseNumberOfReceivedPacketCount: function() {
      Constructor.prototype.numberOfReceivedPacket++;
    },
    getNumberOfReceivedPacketCount: function() {
      return Constructor.prototype.numberOfReceivedPacket;
    },
    setNumberOfReceivedPacketCount: function(packet_count) {
      Constructor.prototype.numberOfReceivedPacket = Number(packet_count);
    },
    isInitializeReceivedPacketCount: function() {
      if (Constructor.prototype.numberOfReceivedPacket !== 0) {
        return false;
      }
      return true;
    },
    increaseNumberOfDroppedPacket: function() {
      Constructor.prototype.numberOfDroppedPacket++;
    },
    getNumberOfDroppedPacketCount: function() {
      return Constructor.prototype.numberOfDroppedPacket;
    },
    setDeviceType: function(type) {
      Constructor.prototype.deviceType = type;
    },
    getDeviceType: function() {
      return Constructor.prototype.deviceType;
    },
    addPacket:  function(data) {
      try {
        if(typeof(mediaQueue) !== 'undefined') {
          // if frame type is I and queue is is not zero
          // if(data.info.frameType === 'I' && mediaQueue.isFull()) {
          //   var temp = mediaQueue.deQueue();
          //   if(temp.info.frameType === 'I') {
          //     _self.eventVideoCallback(temp.mode, temp.packet, temp.info);
          //   }
          // }
          mediaQueue.enqueue(data);
          //console.log("Channel: " + this.getChannel() + ", Queue Length: " + mediaQueue.getLength() + ", isFull: " + mediaQueue.isFull());

          //mediaQueue.print();
          //this.eventVideoCallback(data.mode, data.packet, data.info);
          //return;

          //console.log("push packet count: " + mediaQueue.getLength())
         /* try {
            if(!mediaQueue.isEmpty() && mediaQueue.getLength() >= 5) {
              var count = mediaQueue.getLength();
              //for(var i = 0; i < count; i++)
              {
                var temp = mediaQueue.peek();

                if(temp !== null && typeof temp !== 'undefined') {
                  var gap = Math.abs(Number(temp.packet.timeStamp.rtpTimestamp) - this.getTimerStamp(), 0.5);
                  console.log("Channel: " + ("00" + Constructor.prototype.channelId).slice(-2) +
                                  ", Packet Number: " + ("000000" + temp.index).slice(-6) +
                                  ", frame type: " + temp.info.frameType +
                                  ", packet timestamp: " + temp.packet.timeStamp.rtpTimestamp +
                                  ", timer timestamp: " + this.getTimerStamp().toFixed(10) +
                                  ", gap: " +  ("0000000" + gap.toFixed(3)).slice(-5) +
                                  ", remain packet: " + mediaQueue.getLength());
                  if(temp.info.frameType === 'I') {
                    this.eventVideoCallback(temp.mode, temp.packet, temp.info);
                    mediaQueue.dequeue();
                  } else if(gap > 100) {
                    this.increaseNumberOfDroppedPacket();
                    mediaQueue.dequeue();
                  } else {
                    this.eventVideoCallback(temp.mode, temp.packet, temp.info);
                    mediaQueue.dequeue();
                  }
                }
              }
            }*/
            while(!mediaQueue.isEmpty()) {
              var temp = mediaQueue.peek();
              if(temp !== null && typeof temp !== 'undefined') {
                var gap = Math.abs(Number(temp.packet.timeStamp.rtpTimestamp) - this.getTimerStamp(), 0.5);
                // console.log("Channel: " + ("00" + Constructor.prototype.channelId).slice(-2) +
                //                  ", packet timestamp: " + temp.packet.timeStamp.rtpTimestamp +
                //                  ", timer timestamp: " + this.getTimerStamp().toFixed(10) +
                //                  ", gap: " +  ("0000000" + gap.toFixed(3)).slice(-5) );
                // this.eventVideoCallback(temp.mode, temp.packet, temp.info);
                // mediaQueue.dequeue();

                if( gap > 0 && gap < Math.floor((1000/Constructor.prototype.frameRate) * 5) )
                {
                  if(Constructor.prototype.channelId == -1) {
                    console.log("Channel: " + ("00" + Constructor.prototype.channelId).slice(-2) +
                                     ", Packet Number: " + ("000000" + temp.index).slice(-6) +
                                     //", sum of interval: " + Constructor.prototype.sumOfInterval.toFixed(4) +
                                     //", calculated Average: " + ~~((Constructor.prototype.sumOfInterval/Constructor.prototype.numberOfMediaTimerCount)) +
                                     ", Queue Size: " + ("00" + mediaQueue.getLength()).slice(-2) +
                                     ", timerStamp: " + this.getTimerStamp().toFixed(0) +
                                     ", timeStamp: " + Number(temp.packet.timeStamp.rtpTimestamp).toFixed(2) +
                                     ", gap: " +  ("00000" + Number(Math.abs( Number(temp.packet.timeStamp.rtpTimestamp) - this.getTimerStamp(), 0.5)).toFixed(2)).slice(-5)+
                                     ", Frame Type: " + temp.info.frameType +
                                     ", Frame Length: " + temp.packet.frameData.length +
                                     "\r\n",  temp.packet.frameData);
                  }
                  this.eventVideoCallback(temp.mode, temp.packet, temp.info);
                  mediaQueue.dequeue();
                } else if( temp.info.frameType === 'I') {
                  if(Constructor.prototype.channelId == -1) {
                    console.log("Channel: " + ("00" + Constructor.prototype.channelId).slice(-2) +
                                     ", Packet Number: " + ("000000" + temp.index).slice(-6) +
                                     //", sum of interval: " + Constructor.prototype.sumOfInterval.toFixed(4) +
                                     //", calculated Average: " + ~~((Constructor.prototype.sumOfInterval/Constructor.prototype.numberOfMediaTimerCount)) +
                                     ", Queue Size: " + ("00" + mediaQueue.getLength()).slice(-2) +
                                     ", timerStamp: " + this.getTimerStamp().toFixed(0) +
                                     ", timeStamp: " + Number(temp.packet.timeStamp.rtpTimestamp).toFixed(2) +
                                     ", gap: " +  ("00000" + Number(Math.abs( Number(temp.packet.timeStamp.rtpTimestamp) - this.getTimerStamp(), 0.5)).toFixed(2)).slice(-5)+
                                     ", Frame Type: " + temp.info.frameType +
                                     ", Frame Length: " + temp.packet.frameData.length +
                                     "\r\n",  temp.packet.frameData);
                  }
                  this.eventVideoCallback(temp.mode, temp.packet, temp.info);
                  mediaQueue.dequeue();
                } else {
                  this.increaseNumberOfDroppedPacket();
                  mediaQueue.dequeue();
                }
            }
            }
  //          mediaQueue.deQueue();
            // if(mediaQueue.isFull()) {
            //   try {
            //     //mediaQueue.Clear();
            //     rtpsession_log.debug("Clear Queue, Channel: " + ("00" + Constructor.prototype.channelId).slice(-2) + ", Queue Length: " + ("00" + mediaQueue.getLength()).slice(-2));
            //   } catch (error) {
            //     rtpsession_log.warn("Fail to dequeue, Channel: " + ("00" + Constructor.prototype.channelId).slice(-2));
            //   }
            // }
/*
          } catch (error) {
            //throw new Error("Error send to media packet to mediaRouter");
            console.warn("Channel: " + ("00" + Constructor.prototype.channelId).slice(-2) +
                             ", Message: " + error);
          }*/
        }
      } catch(error) {
        console.warn("Error add packet, Channel: " + ("00" + Constructor.prototype.channelId).slice(-2) +
                             ", error message: ", error);
        this.increaseNumberOfDroppedPacket();
      }
    },
    onMediaTimer: function (event) {
      Constructor.prototype.numberOfMediaTimerCount++;
      if(typeof event !== 'undefined') {
        Constructor.prototype.sumOfInterval += event.data.interval;
      }
      // console.log("Channel: " + Constructor.prototype.channelId +
      //             ", timer interval: " + event.data.interval +
      //             ", sum of interval: " + Constructor.prototype.sumOfInterval +
      //             ", calculated Average: " + ~~((Constructor.prototype.sumOfInterval/Constructor.prototype.numberOfMediaTimerCount)));
    /*  try {
        while(!mediaQueue.isEmpty()) {
          var temp = mediaQueue.peek();
          if(temp !== null && typeof temp !== 'undefined') {
            var gap = Math.abs(Number(temp.packet.timeStamp.rtpTimestamp) - _self.getTimerStamp(), 0.5);
            // console.log("Channel: " + ("00" + Constructor.prototype.channelId).slice(-2) +
            //                  ", packet timestamp: " + temp.packet.timeStamp.rtpTimestamp +
            //                  ", timer timestamp: " + this.getTimerStamp().toFixed(10) +
            //                  ", gap: " +  ("0000000" + gap.toFixed(3)).slice(-5) );
            // this.eventVideoCallback(temp.mode, temp.packet, temp.info);
            // mediaQueue.dequeue();

            if( gap > 0 && gap < Math.floor((1000/Constructor.prototype.frameRate) * 5) )
            {
              if(Constructor.prototype.channelId == -1) {
                console.log("Channel: " + ("00" + Constructor.prototype.channelId).slice(-2) +
                                 ", Packet Number: " + ("000000" + temp.index).slice(-6) +
                                 //", sum of interval: " + Constructor.prototype.sumOfInterval.toFixed(4) +
                                 //", calculated Average: " + ~~((Constructor.prototype.sumOfInterval/Constructor.prototype.numberOfMediaTimerCount)) +
                                 ", Queue Size: " + ("00" + mediaQueue.getLength()).slice(-2) +
                                 ", timerStamp: " + _self.getTimerStamp().toFixed(0) +
                                 ", timeStamp: " + Number(temp.packet.timeStamp.rtpTimestamp).toFixed(2) +
                                 ", gap: " +  ("00000" + Number(Math.abs( Number(temp.packet.timeStamp.rtpTimestamp) - _self.getTimerStamp(), 0.5)).toFixed(2)).slice(-5)+
                                 ", Frame Type: " + temp.info.frameType +
                                 ", Frame Length: " + temp.packet.frameData.length +
                                 "\r\n",  temp.packet.frameData);
              }
              _self.eventVideoCallback(temp.mode, temp.packet, temp.info);
              mediaQueue.dequeue();
            } else if( temp.info.frameType === 'I') {
              if(Constructor.prototype.channelId == -1) {
                console.log("Channel: " + ("00" + Constructor.prototype.channelId).slice(-2) +
                                 ", Packet Number: " + ("000000" + temp.index).slice(-6) +
                                 //", sum of interval: " + Constructor.prototype.sumOfInterval.toFixed(4) +
                                 //", calculated Average: " + ~~((Constructor.prototype.sumOfInterval/Constructor.prototype.numberOfMediaTimerCount)) +
                                 ", Queue Size: " + ("00" + mediaQueue.getLength()).slice(-2) +
                                 ", timerStamp: " + _self.getTimerStamp().toFixed(0) +
                                 ", timeStamp: " + Number(temp.packet.timeStamp.rtpTimestamp).toFixed(2) +
                                 ", gap: " +  ("00000" + Number(Math.abs( Number(temp.packet.timeStamp.rtpTimestamp) - _self.getTimerStamp(), 0.5)).toFixed(2)).slice(-5)+
                                 ", Frame Type: " + temp.info.frameType +
                                 ", Frame Length: " + temp.packet.frameData.length +
                                 "\r\n",  temp.packet.frameData);
              }
              _self.eventVideoCallback(temp.mode, temp.packet, temp.info);
              mediaQueue.dequeue();
            } else {
              _self.increaseNumberOfDroppedPacket();
              mediaQueue.dequeue();
            }
        }
      }
      } catch (error) {
        //throw new Error("Error send to media packet to mediaRouter");
        console.warn("Channel: " + ("00" + Constructor.prototype.channelId).slice(-2) +
                         ", Message: " + error);
      }*/
/*      try {
          if(mediaQueue.isEmpty()) {
            throw new Error("media queue is empty");
          }
          var data = mediaQueue.peek();
          if(data !== null && typeof data !== 'undefined') {
            if(Constructor.prototype.channelId == 0) {
              console.log("Channel: " + ("00" + Constructor.prototype.channelId).slice(-2) +
                               ", Packet Number: " + ("000000" + data.index).slice(-6) +
                               ", timer interval: " + event.data.interval.toFixed(4) +
                               ", sum of interval: " + Constructor.prototype.sumOfInterval.toFixed(4) +
                               ", calculated Average: " + ~~((Constructor.prototype.sumOfInterval/Constructor.prototype.numberOfMediaTimerCount)) +
                               ", Queue Size: " + ("00" + mediaQueue.getLength()).slice(-2) +
                               ", timerStamp: " + _self.getTimerStamp().toFixed(0) +
                               ", timeStamp: " + Number(data.packet.timeStamp.rtpTimestamp).toFixed(2) +
                               ", gap: " +  ("00000" + Number(Math.abs( Number(data.packet.timeStamp.rtpTimestamp) - _self.getTimerStamp(), 0.5)).toFixed(2)).slice(-5)+
                               ", Frame Type: " + data.info.frameType +
                               ", Frame Length: " + data.packet.frameData.length +
                               "\r\n",  data.packet.frameData);
            }
            _self.eventVideoCallback(data.mode, data.packet, data.info);
            mediaQueue.dequeue();
            //rtpsession_log.debug("Queue Size: " + mediaQueue.getLength() + ", Frame Type: " + data.info.frameType +"\r\n",  data.packet.frameData);

            //_self.eventVideoCallback(data.mode, data.packet, data.info);
          }
//          mediaQueue.deQueue();
          // if(mediaQueue.isFull()) {
          //   try {
          //     //mediaQueue.Clear();
          //     rtpsession_log.debug("Clear Queue, Channel: " + ("00" + Constructor.prototype.channelId).slice(-2) + ", Queue Length: " + ("00" + mediaQueue.getLength()).slice(-2));
          //   } catch (error) {
          //     rtpsession_log.warn("Fail to dequeue, Channel: " + ("00" + Constructor.prototype.channelId).slice(-2));
          //   }
          // }
    } catch (error) {
      //throw new Error("Error send to media packet to mediaRouter");
      console.warn("Channel: " + ("00" + Constructor.prototype.channelId).slice(-2) +
                       ", Message: " + error);
    }*/
    },
    onStatisticsTimer: function () {
      if(typeof _self.eventStatisticsCallback !== 'undefined') {
        var staticstics = {
          codec: _self.codec,
          channelId: _self.channelId,
          type: 'rtp',
          queue: mediaQueue.getLength(),
          fps: Constructor.prototype.numberOfReceivedPacket - Constructor.prototype.numberOfPrevTotalCount,
          interval: ~~(Constructor.prototype.sumOfInterval/Constructor.prototype.numberOfMediaTimerCount),
          receviedPacket: Constructor.prototype.numberOfReceivedPacket,
          droppedPacket: Constructor.prototype.numberOfDroppedPacket
        };
/*
        //if(Constructor.prototype.channelId == 0)
        {
          rtpsession_log.debug("Channel: " + ("00" + Constructor.prototype.channelId).slice(-2) +
                    ", timer interval: " + event.data.interval.toFixed(4) +
                    ", sum of interval: " + Constructor.prototype.sumOfInterval.toFixed(4) +
                    ", calculated Average: " + ~~((Constructor.prototype.sumOfInterval/Constructor.prototype.numberOfMediaTimerCount)) +
                    ", Queue Size: " + ("00" + mediaQueue.getLength()).slice(-2) +
                    ", timerStamp: " + _self.getTimerStamp().toFixed(0));
        }
*/
          //interval: ~~((1000/Constructor.prototype.frameRate)),
        _self.eventStatisticsCallback(staticstics);
      }
      Constructor.prototype.numberOfPrevTotalCount = Constructor.prototype.numberOfReceivedPacket;
    }
  });


  /**
   * This property is to return the codec name of RtpSession.
   * @property codec
   * @memberof RtpSession
   * @example
   *     RtpSession.codec = 'H.264';
   */
  Object.defineProperty(this, "codec", {
    get: function() {
        return codec_name;
    },
    set: function(v) {
      codec_name = v;
    },
  });

    /**
   * This property is to return the rtcp session of RtpSession.
   * @property rtcpSession
   * @memberof RtpSession
   * @example
   *     RtpSession.rtcpSession = new RTCPSession();
   */
  Object.defineProperty(this, "rtcpSession", {
    get: function() {
        return rtcp_session;
    },
    set: function(v) {
      rtcp_session = v;
    },
  });

  return new Constructor();
}
var Session = function () {
  "use strict";

  var version = '1.0.0';
  var session_log = log4javascript.getLogger('session');

  function Constructor() {
    this.interleavedId = 0;
    this.channelId = 0;
    this.timeData = null;
  }

  Constructor.prototype = {
    init: function () {
      session_log.info("Session::init");
    },
    depacketize: function (rtspInterleaved, rtpHeader, rtpPayload) {
      session_log.info("Session::depacketize");
    },
    ntohl: function (buffer) {
      return (((buffer[0] << 24) + (buffer[1] << 16) +
        (buffer[2] << 8) + buffer[3]) >>> 0);
    },
    addEventListener: function(event, eventCallback) {
      switch(event) {
      case 'text':
        this.eventMetaCallback = eventCallback;
      break;
      case 'video':
        this.eventVideoCallback = eventCallback;
      break;
      case 'audio':
        this.eventAudioCallback = eventCallback;
      break;
      case 'rtcp':
        this.eventRtcpCallback = eventCallback;
      break;
      case 'statistics':
        this.eventStatisticsCallback = eventCallback;
      break;
      default:
        rtpsession_log.error("can not add event listener. it is not defined");
      break;
      }
    },
    removeEventListener: function(event, eventCallback) {
      switch(event) {
      case 'text':
        this.eventMetaCallback = null;
      break;
      case 'video':
        this.eventVideoCallback = null;
      break;
      case 'audio':
        this.eventAudioCallback = null;
      break;
      case 'statistics':
        this.eventStatisticsCallback = null;
      break;
      default:
        rtpsession_log.error("can not add event listener. it is not defined");
      break;
      }
    },
    SetTimeStamp: function (data) {
      this.timeData = data;
    },
    GetTimeStamp: function () {
      return this.timeData;
    },
  };

  /**
   * This property is channel number.
   * @function channelId
   * @memberof Session
   * @example
   *    Session.channelId = ;
   */
  Object.defineProperty(this, "channelId", {
    get: function() {
        return channel_Id;
    },
    set: function(v) {
      channel_Id = v;
    },
  });

  /**
   * This property is to return the interleaved channel number of Session.
   * @property interleaved channel number
   * @memberof Session
   * @example
   *     Session.interleavedId = 0;
   */
  Object.defineProperty(this, "interleavedId", {
    get: function() {
        return interleaved_Id;
    },
    set: function(v) {
      interleaved_Id = v;
    },
  });

  /**
   * This property is to return the interleaved channel number of Session.
   * @property interleaved channel number
   * @memberof Session
   * @example
   *     Session.interleavedId = 0;
   */
  Object.defineProperty(this, "rtpTimestamp", {
    get: function() {
        return rtp_timestamp;
    },
    set: function(v) {
      rtp_timestamp = v;
    },
  });

  return new Constructor();
};
var MetaSession = function () {
	"use strict";

	var version = '1.0.0';
	var matasession_log = log4javascript.getLogger('metasession');

	var marker = 0,
		inputLength = 0,
		size_1_4K = Math.floor(1.4 * 1024),
		inputBuffer = new Uint8Array(size_1_4K);
	var playback = false;
	var extensionHeaderLen = 0;

		var rtpVersion,
					rtpPadding,
					rtpCSRCCount,
					rtpExtension,
					rtpMarkerBit,
					rtpPayloadType,
					rtpTimeStamp = 0,
					rtpSquenceNumber;

		var NTPmsw = new Uint8Array(new ArrayBuffer(4)),
			NTPlsw = new Uint8Array(new ArrayBuffer(4)),
			gmt = new Uint8Array(new ArrayBuffer(2));

		var setBuffer = function (buffer2) {
			if ((inputLength + buffer2.length) > inputBuffer.length) {
				var tmp = inputBuffer;
				inputBuffer = null;
				inputBuffer = new Uint8Array(tmp.length + buffer2.length);
				inputBuffer.set(tmp, 0);
				tmp = null;
			}

			inputBuffer.set(buffer2, inputLength);
			inputLength += buffer2.length;
			return inputBuffer;
		};

  function Constructor() {}

  Constructor.prototype = inheritObject(new RtpSession(), {
		init: function () {
			playback = false;
			this.timeData = { 'timestamp': null, 'timestamp_usec': null, 'timezone': null };
		},
  	depacketize: function(rtspInterleaved, rtpHeader, rtpPayload) {
			extensionHeaderLen = 0;
			// Reference: https://tools.ietf.org/html/rfc3550
			// Reference: https://tools.ietf.org/html/rfc3984
			rtpVersion = (rtpHeader[0] & 0xC0) >> 6;
			rtpPadding = (((rtpHeader[0] & 0x20) >> 5) === 1);
			rtpExtension = (((rtpHeader[0] & 0x10) >> 4) === 1);
			rtpCSRCCount = (rtpHeader[0] & 0x0F);
			rtpMarkerBit = (((rtpHeader[1] & 0x80) >> 7) === 1);
			rtpPayloadType = rtpHeader[1] & 0x7F;

			if (rtspInterleaved[0] !== 0x24) {
				throw new umpError({
					channelId: this.channelId,
					errorCode: fromHex('0x0102'),
					place: 'metaSession.js:53',
					message: "it is not valid interleave header (RTSP over TCP). Interleaved[0] = " + rtspInterleaved[0].toString(16)
				});
			} else if (rtpCSRCCount !== 0) {
				throw new umpError({
					channelId: this.channelId,
					errorCode: fromHex('0x0103'),
					place: 'metaSession.js:60',
					message: "There is additional CSRC which is not handled in this version. CSRC count = " + rtpCSRCCount
				});
			} else if (rtpPadding) {
				PaddingSize = rtpPayload[rtpPayload.length - 1];
				matasession_log.debug("Meta PaddingSize - " + PaddingSize);
			}

			//Extension bit check in RTPHeader
			if (rtpExtension) {
				extensionHeaderLen = ((rtpPayload[2] << 8 | rtpPayload[3]) * 4) + 4;

				if (rtpPayload[0] == '0xAB' && (rtpPayload[1] == '0xAD' || rtpPayload[1] == '0xAC')) {
					var startHeader = 4;

					NTPmsw.set(rtpPayload.subarray(startHeader, startHeader + 4), 0);
					startHeader += 4;
					NTPlsw.set(rtpPayload.subarray(startHeader, startHeader + 4), 0);
					if (this.getDeviceType() === 'camera') {
						startHeader += 6;
						gmt.set(rtpPayload.subarray(startHeader, startHeader + 2), 0);
					}

					var tempdata = {};
					tempdata.timestamp = ((this.ntohl(NTPmsw) - 0x83AA7E80) >>> 0);
					tempdata.timestamp_usec = (this.ntohl(NTPlsw) / 0xffffffff) * 1000;

					if (this.getDeviceType() === 'camera') {
						tempdata.timezone = (((gmt[0] << 8) | gmt[1]) << 16) >> 16;
					}

					if (this.GetTimeStamp().timestamp != null && this.GetTimeStamp().timestamp_usec !== null) {
						matasession_log.debug("", tempdata.timestamp, tempdata.timestamp_usec, this.GetTimeStamp().timestamp,  this.GetTimeStamp().timestamp_usec);
						var timeGap = Math.abs(tempdata.timestamp - this.GetTimeStamp().timestamp);
						if(timeGap <= 1) {
							var distance = Math.abs( (tempdata.timestamp*1000 + tempdata.timestamp_usec)-
																	(this.GetTimeStamp().timestamp*1000 + this.GetTimeStamp().timestamp_usec));
							if(distance != 0) {
								this.setFramerate(Math.round(1000 / distance));
								matasession_log.debug("playback framerate = ", this.getFramerate());
							}
						}
					}
					this.SetTimeStamp(tempdata);
					playback = true;
				}
			}

			rtpTimeStamp = this.ntohl(rtpHeader.subarray(4, 8));
			rtpSquenceNumber = this.ntohl(rtpHeader.subarray(2, 3));

			matasession_log.debug("interleaved id = ", this.interleavedId,
				", MetaSession RTP Version: ", ("00" + rtpVersion).slice(-2),
				", Padding: ", rtpPadding,
				", ExtensionBit: ", rtpExtension,
				", CSRC Count: ", rtpCSRCCount,
				", Marker Bit: ", rtpMarkerBit,
				", RTP Payload Type: ", rtpPayloadType,
				", RTP Sequence Number: ", rtpSquenceNumber,
				", RTP Timestamp: ", rtpTimeStamp,
				", RTCP Timestamp: " + this.rtcpSession.rtpTimestamp);
			// marker = ((rtpHeader[1] & 0x80) === 0x80);
			setBuffer(rtpPayload);

			if(rtpMarkerBit) {
				var inputBufferSub = inputBuffer.subarray(0, inputLength);
				this.rtpTimestamp = (rtpTimeStamp / 90).toFixed(0);
				inputLength = 0;

				var streamData = {
					'frameData': inputBufferSub,
 					'channelId': this.channelId,
 					'receiveClock': performance.now(),
					'timeStamp': {
						'rtpTimestamp': this.rtpTimestamp,
						'timestamp': this.timeData.timestamp,
						'timestamp_usec': this.timeData.timestamp_usec,
						'timezone': this.timeData.timezone
					},
 					'rtcp_interleavedId': this.rtcpSession.interleavedId
				}
				this.eventMetaCallback(streamData);
			}
		}
	});

	return new Constructor();
};
var InitState = function (manager) {
  "use strict";
  this.manager = manager;
  /**
   * Is enable to pop frame
   * @function isReadyToPop
   * @return {boolean} false. In init state, frame not to be pop. 
   */
  this.isReadyToPop = function () {
    return false;
  };

  /**
   * After buffer.push, Change bufferStatus to Play State 
   * & return is Enable to pop
   * @function push
   * @return {boolean} true. In Init state, after push, always enable to pop
   */
  this.push = function () {
    //console.log("[PUSH] Init state --> Play state");
    this.manager.change(new PlayState(this.manager));
    return true;
  };

  this.pause = function () {};
  this.full = function () {};
  this.restart = function () {};
  this.clear = function () {};
  this.resume = function () {};
};

/**
 * Class for Playing State
 * @param {PlaybackBufferManager} manager manager
 */
var PlayState = function (manager) {
  "use strict";
  this.manager = manager;

  /**
   * Is enable to pop frame
   * @function isReadyToPop
   * @return {boolean} true. In play state, frame to be pop. 
   */
  this.isReadyToPop = function () {
    return true;
  };

  /**
   * After buffer.push, until 'canvasRender' frame not to be pop
   * @function push
   * @return {boolean} false.
   */
  this.push = function () {
    return false;
  };
 
  /**
   * Change buffer status when 'Pause' event occured
   * @function pause
   * @memberof PlayState
   * @param {StepBufferList} buffer playback buffer list
   */
  this.pause = function (buffer) {
    //console.log("[PAUSE] Play status ---> Pause Status ");
    this.manager.change(new PauseState(this.manager));
  };

  /**
   * Change Buffer Status when 'Full' event occured.
   * Send PAUSE command to camera (internally)
   * @return {Object} message to pause stream.
   */
  this.full = function () {
    //console.log("[FULL] Play state ---> Wait Pause state");
    var message = {};
    message.errorCode = fromHex('0x0500');
    message.oldErrorCode = "600";
    message.description = 'error';
    this.manager.change(new WaitPauseState(this.manager));
    return message;
  };

  /**
   * After clear buffer, Change status to init state.
   * @function clear
   */
  this.clear = function () {
    this.manager.change(new InitState(this.manager));
  };

  /**
   * Change Buffer Status when buffer is empty
   * @function restart
   */
  this.restart = function() {
    //console.log("[RESTART] PLAY status --> Init status");
    this.manager.change(new InitState(this.manager));
  };

  this.checkBufferLength = function () {};
};
/**
 * Class for Waiting Puase State
 * @param {PlaybackBufferManager} manager manager
 */
var WaitPauseState = function (manager) {
  "use strict";
  this.manager = manager;

  /**
   * Is enable to pop frame
   * @function isReadyToPop
   * @return {boolean} true. In Waiting Pause state, frame to be pop. 
   */
  this.isReadyToPop = function () {
    return true;
  };

  /**
   * After buffer.push, until 'canvasRender' frame not to be pop
   * @function push
   * @return {boolean} false.
   */
  this.push = function () {
    return false;
  };
  /**
   * Change buffer status when 'Pause' event occured
   * @function pause
   * @memberof PlayState
   * @param {StepBufferList} buffer playback buffer list
   */
  this.pause = function (buffer) {
    //console.log("[PAUSE] Wait Pause status ---> Full Status");
    this.manager.change(new FullState(this.manager));
  };

  /**
   * After clear buffer, Change status to init state.
   * @function clear
   */
  this.clear = function () {
    this.manager.change(new InitState(this.manager));
  };

  this.full = function () {};
  this.restart = function () {};
  this.checkBufferLength = function () {};
};

/**
 * Class for Full State
 * @param {PlaybackBufferManager} manager manager
 */
var FullState = function (manager) {
  "use strict";
  this.manager = manager;

  /**
   * Is enable to pop frame
   * @function isReadyToPop
   * @return {boolean} true. In Full state, frame to be pop. 
   */
  this.isReadyToPop = function () {
    return true;
  };

  /**
   * Change buffer status when 'Pause' event occured
   * @function pause
   * @memberof PlayState
   * @param {StepBufferList} buffer playback buffer list
   */
  this.pause = function (buffer) {
    //console.log("[PAUSE] Full Status ---> FakePauseStatus");
    this.manager.change(new FakePauseState(this.manager));
    var message = {};
    message.errorCode = fromHex('0x0000');
    message.oldErrorCode = "200";
    message.currentState = "Pause";
    message.description = 'BufferManager process PAUSE';
    return message;
  };

  /**
   * Change Buffer Status when buffer is empty
   * Send RESUME command to camera (internally)
   * @return {Object} message to resume stream.
   */
  this.restart = function () {
    //console.log("[RESTART] FUll status --> Init status");
    this.manager.change(new InitState(this.manager));
    var message = {};
    message.errorCode = fromHex('0x0501');
    message.oldErrorCode = "601";
    message.description = 'error';
    return message;
  };

  /**
   * After clear buffer, Change status to init state.
   * @function clear
   */
  this.clear = function () {
    this.manager.change(new InitState(this.manager));
  };

  /**
   * After buffer.push, until 'canvasRender' frame not to be pop
   * @function push
   * @return {boolean} false.
   */
  this.push = function () {
    return false;
  };
  this.resume = function () {};
  this.full = function () {};
};

/**
 * Class for Fake Pause State 
 * - In full state, user want to pause stream. (internally not sending Pause command)
 * @param {PlaybackBufferManager} manager manager
 */
var FakePauseState = function (manager) {
  "use strict";
  this.manager = manager;

  /**
   * Is enable to pop frame
   * @function isReadyToPop
   * @return {boolean} false. In Fake pause state, frame not to be pop. 
   */
  this.isReadyToPop = function () {
    return false;
  };

  /**
   * re-start playback. Change state to Full state.
   * @function resume
   * @return {boolean} true. after changing to full state, frame to be pop
   */
  this.resume = function () {
    //console.log("[RESUME] FakePause ---> Full status");
    this.manager.change(new FullState(this.manager));
    var message = {};
    message.errorCode = fromHex('0x0000');
    message.oldErrorCode = "200";
    message.currentState = "Resume";
    message.description = 'BufferManager process RESUME';
    return message;
  };

  /**
   * After clear buffer, Change status to init state.
   * @function clear
   */
  this.clear = function () {
    this.manager.change(new InitState(this.manager));
  };

  /**
   * After buffer.push, until 'canvasRender' frame not to be pop
   * @function push
   * @return {boolean} false.
   */
  this.push = function () {
    return false;
  };
  this.full = function () {};
  this.restart = function () {};
  this.pause = function () {};
  this.checkBufferLength = function () {};
};

/**
 * Class for Pause State 
 * - In play state, user want to pause stream
 * @param {PlaybackBufferManager} manager manager
 */
var PauseState = function (manager) {
  "use strict";
  this.manager = manager;

  /**
   * Is enable to pop frame
   * @function isReadyToPop
   * @return {boolean} false. In pause state, frame not to be pop. 
   */
  this.isReadyToPop = function () {
    return false;
  };

  /**
   * re-start playback. Change state to Init state.
   * @function resume
   * @return {boolean} true. after changing to init state, frame to be pop
   */
  this.resume = function () {
    //console.log("[RESUME] PauseState ---> PLAY state");
    this.manager.change(new InitState(this.manager));
  };

  /**
   * After clear buffer, Change status to init state.
   * @function clear
   */
  this.clear = function () {
    this.manager.change(new InitState(this.manager));
  };

  /**
   * After buffer.push, until 'canvasRender' frame not to be pop
   * @function push
   * @return {boolean} false.
   */
  this.push = function () {
    return false;
  };
  this.full = function () {};
  this.restart = function () {};
  this.pause = function () {};
  this.checkBufferLength = function () {};
};
var H264Session = function () {
	"use strict";

	var version = '1.0.0';
	var h264rtpsession_log = log4javascript.getLogger('h264rtpsession');

	var rtpVersion,
		rtpPadding,
		rtpCSRCCount,
		rtpExtension,
		rtpMarkerBit,
		rtpTimeStamp = 0,
		rtpSquenceNumber,
		rtpPayloadType,
		rtpNRI,
		rtpNALType,
		rtpForbiddenZeroBit;
	var inputLength = 0;
	var size_1_4K = Math.floor(1.4 * 1024);
	var playback = false;
	var inputBuffer = new Uint8Array(size_1_4K),
		PREFIX = new Uint8Array(4),
		NTPmsw = new Uint8Array(new ArrayBuffer(4)),
		NTPlsw = new Uint8Array(new ArrayBuffer(4)),
		gmt = new Uint8Array(new ArrayBuffer(2));

	//initial segment test
	var sps_segment = null;
	var pps_segment;

	//media segment test
	PREFIX[0] = '0x00';
	PREFIX[1] = '0x00';
	PREFIX[2] = '0x00';
	PREFIX[3] = '0x01';

	var H264NalUnit = {};
	H264NalUnit.Enum(
		'H264_NAL_UNSPECIFIED',		// 0
		'H264_NAL_SLICE',			// 1
		'H264_NAL_DPA',				// 2
		'H264_NAL_DPB',				// 3
		'H264_NAL_DPC',				// 4
		'H264_NAL_IDR_SLICE',		// 5
		'H264_NAL_SEI',				// 6
		'H264_NAL_SPS',				// 7
		'H264_NAL_PPS',				// 8
		'H264_NAL_AUD',				// 9
		'H264_NAL_END_SEQUENCE',	// 10
		'H264_NAL_END_STREAM',		// 11
		'H264_NAL_FILLER_DATA',		// 12
		'H264_NAL_SPS_EXT',			// 13
		'H264_NAL_PREFIX',			// 14
		'H264_NAL_SUB_SPS',			// 15
		'H264_NAL_DPS',				// 16
		'H264_NAL_RESERVED17',		// 17
		'H264_NAL_RESERVED18',		// 18
		'H264_NAL_AUXILIARY_SLICE',	// 19
		'H264_NAL_EXTEN_SLICE',		// 20
		'H264_NAL_DEPTH_EXTEN_SLICE',//21
		'H264_NAL_RESERVED22',		// 22
		'H264_NAL_RESERVED23',		// 23
		'H264_NAL_UNSPECIFIED24',	// 24
		'H264_NAL_UNSPECIFIED25',	// 25
		'H264_NAL_UNSPECIFIED26',	// 26
		'H264_NAL_UNSPECIFIED27',	// 27
		'H264_NAL_UNSPECIFIED28',	// 28
		'H264_NAL_UNSPECIFIED29',	// 29
		'H264_NAL_UNSPECIFIED30',	// 30
		'H264_NAL_UNSPECIFIED31'	// 31
	);

	var setBuffer = function (buffer2) {
		if ((inputLength + buffer2.length) > inputBuffer.length) {
			var tmp = inputBuffer;
			inputBuffer = null;
			inputBuffer = new Uint8Array(tmp.length + buffer2.length);
			inputBuffer.set(tmp, 0);
			tmp = null;
		}

		inputBuffer.set(buffer2, inputLength);
		inputLength += buffer2.length;
		return inputBuffer;
	};

	function Constructor() { }

	Constructor.prototype = inheritObject(new RtpSession(), {
		init: function () {
			playback = false;
			this.timeData = { 'timestamp': null, 'timestamp_usec': null, 'timezone': null };
		},
		depacketize: function (rtspInterleaved, rtpHeader, rtpPayload) {
			var PAYLOAD;
			var extensionHeaderLen = 0;
			var PaddingSize = 0;

			if(this.interleavedId !== rtspInterleaved[1]) {
				// TODO: check interleaved id
			}

			// Reference: https://tools.ietf.org/html/rfc3550
			// Reference: https://tools.ietf.org/html/rfc3984
			rtpVersion = (rtpHeader[0] & 0xC0) >> 6;
			rtpPadding = (((rtpHeader[0] & 0x20) >> 5) === 1);
			rtpExtension = (((rtpHeader[0] & 0x10) >> 4) === 1);
			rtpCSRCCount = (rtpHeader[0] & 0x0F);
			rtpMarkerBit = (((rtpHeader[1] & 0x80) >> 7) === 1);
			rtpPayloadType = rtpHeader[1] & 0x7F;

			if (rtspInterleaved[0] !== 0x24) {
				throw new umpError({
					channelId: this.channelId,
					errorCode: fromHex('0x0102'),
					place: 'h264Session.js:87',
					message: "it is not valid interleave header (RTSP over TCP). Interleaved[0] = " + rtspInterleaved[0].toString(16)
				});
			} else if (rtpCSRCCount !== 0) {
				throw new umpError({
					channelId: this.channelId,
					errorCode: fromHex('0x0103'),
					place: 'h264Session.js:94',
					message: "There is additional CSRC which is not handled in this version. CSRC count = " + rtpCSRCCount
				});
			} else if (rtpPadding) {
				PaddingSize = rtpPayload[rtpPayload.length - 1];
				h264rtpsession_log.debug("H.264 PaddingSize - " + PaddingSize);
			}

			//Extension bit check in RTPHeader
			if (rtpExtension) {

				extensionHeaderLen = ((rtpPayload[2] << 8 | rtpPayload[3]) * 4) + 4;

				if (rtpPayload[0] == '0xAB' && (rtpPayload[1] == '0xAD' || rtpPayload[1] == '0xAC')) {
					var startHeader = 4;

					NTPmsw.set(rtpPayload.subarray(startHeader, startHeader + 4), 0);
					startHeader += 4;
					NTPlsw.set(rtpPayload.subarray(startHeader, startHeader + 4), 0);
					if (this.getDeviceType() === 'camera') {
						startHeader += 6;
						gmt.set(rtpPayload.subarray(startHeader, startHeader + 2), 0);
					}

					var tempdata = {};
					tempdata.timestamp = ((this.ntohl(NTPmsw) - 0x83AA7E80) >>> 0);
					tempdata.timestamp_usec = (this.ntohl(NTPlsw) / 0xffffffff) * 1000;

					if (this.getDeviceType() === 'camera') {
						tempdata.timezone = (((gmt[0] << 8) | gmt[1]) << 16) >> 16;
					}

					if (this.GetTimeStamp().timestamp != null && this.GetTimeStamp().timestamp_usec !== null) {
						h264rtpsession_log.debug("", tempdata.timestamp, tempdata.timestamp_usec, this.GetTimeStamp().timestamp,  this.GetTimeStamp().timestamp_usec);
						var timeGap = Math.abs(tempdata.timestamp - this.GetTimeStamp().timestamp);
						if(timeGap <= 1) {
							var distance = Math.abs( (tempdata.timestamp*1000 + tempdata.timestamp_usec)-
																	(this.GetTimeStamp().timestamp*1000 + this.GetTimeStamp().timestamp_usec));
							if(distance != 0) {
								this.setFramerate(Math.round(1000 / distance));
								h264rtpsession_log.debug("playback framerate = ", this.getFramerate());
							}
						}
					}
					this.SetTimeStamp(tempdata);
					playback = true;
				}
			}

			PAYLOAD = rtpPayload.subarray(extensionHeaderLen, rtpPayload.length - PaddingSize);

			rtpTimeStamp = this.ntohl(rtpHeader.subarray(4, 8));
			rtpSquenceNumber = this.ntohl(rtpHeader.subarray(2, 3));

			h264rtpsession_log.debug("interleaved id = ", this.interleavedId,
				", H.264 RTP Version: ", ("00" + rtpVersion).slice(-2),
				", Padding: ", rtpPadding,
				", ExtensionBit: ", rtpExtension,
				", CSRC Count: ", rtpCSRCCount,
				", Marker Bit: ", rtpMarkerBit,
				", RTP Payload Type: ", rtpPayloadType,
				", RTP Sequence Number: ", rtpSquenceNumber,
				", RTP Timestamp: ", rtpTimeStamp,
				", RTCP Timestamp: " + this.rtcpSession.rtpTimestamp);

			// Reference: https://tools.ietf.org/html/rfc3984
			rtpForbiddenZeroBit = (PAYLOAD[0] & 0x80) >> 7;
			rtpNRI = (PAYLOAD[0] & 0x60) >> 5;
			rtpNALType = (PAYLOAD[0] & 0x1f);
			if (rtpNALType == 0) {
				console.warn("This NAL type does not support on this application. nal_type = " + toHex(rtpNALType));
				throw new umpError({
					channelId: this.channelId,
					errorCode: fromHex('0x0101'),
					place: 'h264Session.js:155',
					message: "This NAL type does not support on this application. nal_type = " + toHex(rtpNALType)
				});
			}
			else {
				h264rtpsession_log.debug("H.264 Forbidden Zero Bit: " + rtpForbiddenZeroBit +
												 ", NRI: " + rtpNRI.toString(2) +
												 ", Nal Unit Type: " + toHex(rtpNALType) +
												 ", Payload length: " + PAYLOAD.length);
			}

			switch (rtpNALType) {
				case H264NalUnit.H264_NAL_SPS: //SPS
					inputBuffer = setBuffer(PREFIX);
					inputBuffer = setBuffer(PAYLOAD);
					sps_segment = PAYLOAD;
					break;
				case H264NalUnit.H264_NAL_PPS: //PPS
					inputBuffer = setBuffer(PREFIX);
					inputBuffer = setBuffer(PAYLOAD);
					pps_segment = PAYLOAD;
					break;
				case H264NalUnit.H264_NAL_SPS_EXT: // SPS (Sequence Parameter Set) extension
					console.warn("H.264 SPS (Sequence Parameter Set) extension" + "\r\n" + "Reference: https://tools.ietf.org/html/rfc3984#section-5.7");
					throw new umpError({
						channelId: this.channelId,
						errorCode: fromHex('0x0101'),
						place: 'h264Session.js:195',
						message: "SPS (Sequence Parameter Set) extension is additional which is not handled in this version. NALType  = " + rtpNALType
					});
					break;
				case H264NalUnit.H264_NAL_SUB_SPS: // SSPS (Subset Sequence Parameter Set)
					console.warn("H.264 SSPS (Subset Sequence parameter Set) " + "\r\n" + "Reference: https://tools.ietf.org/html/rfc3984#section-5.7");
					throw new umpError({
						channelId: this.channelId,
						errorCode: fromHex('0x0101'),
						place: 'h264Session.js:204',
						message: "SSPS (Subset Sequence parameter Set) is additional which is not handled in this version. NALType  = " + rtpNALType
					});
					break;
				case H264NalUnit.H264_NAL_UNSPECIFIED28: // Fragmentation unit(FU)
					// reference Figure 15 from  https://tools.ietf.org/html/rfc3984#section-5.8
					// following FU header format
					var start_bit = ((PAYLOAD[1] & 0x80) === 0x80),
						end_bit = ((PAYLOAD[1] & 0x40) === 0x40),
						reserved_bit = ((PAYLOAD[1] & 0x20) === 0x20),
						fu_type = PAYLOAD[1] & 0x1f,
						payload_start_index = 2;

						h264rtpsession_log.debug("start bit: " + start_bit +
						", end bit: " + end_bit +
						", reserved bit: " + reserved_bit  +
						", Fu Type: " + fu_type);

					if (start_bit == true && end_bit == false) {
						var new_nal_header = new Uint8Array(1);
						new_nal_header[0] = (PAYLOAD[0] & 0x60 | fu_type);
						inputBuffer = setBuffer(PREFIX);
						inputBuffer = setBuffer(new_nal_header);
						inputBuffer = setBuffer(PAYLOAD.subarray(payload_start_index, PAYLOAD.length));
					} else {
						inputBuffer = setBuffer(PAYLOAD.subarray(payload_start_index, PAYLOAD.length));
					}
					h264rtpsession_log.debug("H.264 Raw Length: " + PAYLOAD.length);
					h264rtpsession_log.debug("H.264 Buff Length: " + inputBuffer.length);
					// h264rtpsession_log.debug("H.264 Raw Length: " + PAYLOAD.length + "\r\nData: ", PAYLOAD);
					// h264rtpsession_log.debug("H.264 Buff Length: " + inputBuffer.length + "\r\nData: ", inputBuffer);
					break;
				case H264NalUnit.H264_NAL_AUD: // Fragmentation unit(FU)\
				   h264rtpsession_log.debug("H.264 Coded slice of an (" + rtpNALType  + ").\r\n" + "Reference: https://tools.ietf.org/html/rfc3984#section-5.7");
				// 	break;
				default:
					h264rtpsession_log.debug("H.264 Coded slice of an (" + rtpNALType  + ").\r\n" + "Reference: https://tools.ietf.org/html/rfc3984#section-5.7");
					inputBuffer = setBuffer(PREFIX);
					inputBuffer = setBuffer(PAYLOAD);
					break;
			}

			//check marker bit
			if (rtpMarkerBit) {
				//console.log("Length: " + inputBuffer.length + "\r\nData: ", inputBuffer);
				var inputBufferSub = inputBuffer.subarray(0, inputLength);
				//var inputBufferSub;
				var frameType = '';
				this.rtpTimestamp = (rtpTimeStamp / 90).toFixed(0);

				//inputBufferSub = new Uint8Array(inputLength);
				//inputBufferSub.set(inputBuffer.subarray(0, inputLength), 0);

				// reset input length
				inputLength = 0;

				if (this.isInitializeReceivedPacketCount()) {
					this.setStartTimeStamp(this.rtpTimestamp);
					this.startMediaTimer();
				}

				if ((inputBufferSub[3] & 0x1f) === 0x07) {
					//console.log("This h.264 parser does not support 3 byte start code.")
					throw new umpError({
						channelId: this.channelId,
						errorCode: fromHex('0x0101'),
						place: 'h264Session.js:264',
						message: "3 byte start code is additional which is not handled in this version. inputBufferSub[3].toString(16): " + inputBufferSub[3].toString(16)
					});
				}

				this.increaseNumberOfReceivedPacketCount();
				if ((inputBufferSub[4] & 0x1f) === 0x07 || (inputBufferSub[4] & 0x1f) === 0x09) {
					frameType = 'I';
				} else {
					frameType = 'P';
				}
				var playMode = (playback === true) ? 'Playback' : "Live";
				var streamData = {
					'codecType': 'H264',
					'frameData': inputBufferSub,
					'channelId': this.channelId,
					'packetSeq': this.getNumberOfReceivedPacketCount(),
					'receiveClock': performance.now(),
					'timeStamp': {
						'rtpTimestamp': this.rtpTimestamp,
						'timestamp': this.timeData.timestamp,
						'timestamp_usec': this.timeData.timestamp_usec,
						'timezone': this.timeData.timezone
					},
					'rtcp_interleavedId': this.rtcpSession.interleavedId
				};
				var videoInfo = {
					'frameType': frameType,
					'spsPayload': sps_segment,
					'ppsPayload': pps_segment,
					'framerate': this.getFramerate()
				};

				this.eventVideoCallback(playMode, streamData, videoInfo);

				//inputBuffer = new Uint8Array(size_1_4K);
				// var data = {
				// 	index: this.getNumberOfReceivedPacketCount(),
				// 	mode: playMode,
				// 	packet: streamData,
				// 	info: videoInfo
				// }
				// this.addPacket(data);
				return;
			}
		}
	});

	return new Constructor();
};
var H265Session = function () {
  "use strict";

  var version = '1.0.0';
  var h265rtpsession_log = log4javascript.getLogger('h265rtpsession');

  var rtpVersion,
    rtpPadding,
    rtpCSRCCount,
    rtpExtension,
    rtpMarkerBit,
    rtpTimeStamp = 0,
    rtpSquenceNumber,
    rtpPayloadType,
    rtpLayerId,
    rtpTID,
    rtpNALType,
    rtpForbiddenZeroBit;
  var inputLength = 0;
  var size_1_4K = Math.floor(1.4 * 1024);
  var playback = false;
  var inputBuffer = new Uint8Array(size_1_4K),
    PREFIX = new Uint8Array(4),
    NTPmsw = new Uint8Array(new ArrayBuffer(4)),
    NTPlsw = new Uint8Array(new ArrayBuffer(4)),
    gmt = new Uint8Array(new ArrayBuffer(2));

  //initial segment test
  var vpsPayload = null;
  var spsPayload = null;
  var ppsPayload = null;

  //media segment test
  PREFIX[0] = '0x00';
  PREFIX[1] = '0x00';
  PREFIX[2] = '0x00';
  PREFIX[3] = '0x01';

  var HEVCNalUnit = {};
  HEVCNalUnit.Enum(
    'HEVC_NAL_TRAIL_N',		// 0
    'HEVC_NAL_TRAIL_R',		// 1
    'HEVC_NAL_TSA_N',		// 2
    'HEVC_NAL_TSA_R',		// 3
    'HEVC_NAL_STSA_N',		// 4
    'HEVC_NAL_STSA_R',		// 5
    'HEVC_NAL_RADL_N',		// 6
    'HEVC_NAL_RADL_R',		// 7
    'HEVC_NAL_RASL_N',		// 8
    'HEVC_NAL_RASL_R',		// 9
    'HEVC_NAL_VCL_N10',		// 10
    'HEVC_NAL_VCL_R11',		// 11
    'HEVC_NAL_VCL_N12',		// 12
    'HEVC_NAL_VCL_R13',		// 13
    'HEVC_NAL_VCL_N14',		// 14
    'HEVC_NAL_VCL_R15',		// 15
    'HEVC_NAL_BLA_W_LP',	// 16
    'HEVC_NAL_BLA_W_RADL',	// 17
    'HEVC_NAL_BLA_N_LP',	// 18
    'HEVC_NAL_IDR_W_RADL',	// 19
    'HEVC_NAL_IDR_N_LP',	// 20
    'HEVC_NAL_CRA_NUT',		// 21
    'HEVC_NAL_IRAP_VCL22',	// 22
    'HEVC_NAL_IRAP_VCL23',	// 23
    'HEVC_NAL_RSV_VCL24',	// 24
    'HEVC_NAL_RSV_VCL25',	// 25
    'HEVC_NAL_RSV_VCL26',	// 26
    'HEVC_NAL_RSV_VCL27',	// 27
    'HEVC_NAL_RSV_VCL28',	// 28
    'HEVC_NAL_RSV_VCL29',	// 29
    'HEVC_NAL_RSV_VCL30',	// 30
    'HEVC_NAL_RSV_VCL31',	// 31
    'HEVC_NAL_VPS',			// 32
    'HEVC_NAL_SPS',			// 33
    'HEVC_NAL_PPS',			// 34
    'HEVC_NAL_AUD',			// 35
    'HEVC_NAL_EOS_NUT',		// 36
    'HEVC_NAL_EOB_NUT',		// 37
    'HEVC_NAL_FD_NUT',		// 38
    'HEVC_NAL_SEI_PREFIX',	// 39
    'HEVC_NAL_SEI_SUFFIX',	// 40
    'HEVC_NAL_RSV_NVCL41',	// 41
    'HEVC_NAL_RSV_NVCL42',	// 42
    'HEVC_NAL_RSV_NVCL43',	// 43
    'HEVC_NAL_RSV_NVCL44',	// 44
    'HEVC_NAL_RSV_NVCL45',	// 45
    'HEVC_NAL_RSV_NVCL46',	// 46
    'HEVC_NAL_RSV_NVCL47',	// 47
    'HEVC_NAL_UNSPEC48',	// 48
    'HEVC_NAL_UNSPEC49',	// 49
    'HEVC_NAL_UNSPEC50',	// 50
    'HEVC_NAL_UNSPEC51',	// 51
    'HEVC_NAL_UNSPEC52',	// 52
    'HEVC_NAL_UNSPEC53',	// 53
    'HEVC_NAL_UNSPEC54',	// 54
    'HEVC_NAL_UNSPEC55',	// 55
    'HEVC_NAL_UNSPEC56',	// 56
    'HEVC_NAL_UNSPEC57',	// 57
    'HEVC_NAL_UNSPEC58',	// 58
    'HEVC_NAL_UNSPEC59',	// 59
    'HEVC_NAL_UNSPEC60',	// 60
    'HEVC_NAL_UNSPEC61',	// 61
    'HEVC_NAL_UNSPEC62',	// 62
    'HEVC_NAL_UNSPEC63'	// 63
  );

  var setBuffer = function (buffer2) {
    if ((inputLength + buffer2.length) > inputBuffer.length) {
      var tmp = inputBuffer;
      inputBuffer = null;
      inputBuffer = new Uint8Array(tmp.length + buffer2.length);
      inputBuffer.set(tmp, 0);
      tmp = null;
    }

    inputBuffer.set(buffer2, inputLength);
    inputLength += buffer2.length;
    return inputBuffer;
  };

  function Constructor() { }

  Constructor.prototype = inheritObject(new RtpSession(), {
    init: function () {
      playback = false;
      this.timeData = { 'timestamp': null, 'timestamp_usec': null, 'timezone': null };
    },
    depacketize: function (rtspInterleaved, rtpHeader, rtpPayload) {
      var PAYLOAD;
      var extensionHeaderLen = 0;
      var PaddingSize = 0;

      if(this.interleavedId !== rtspInterleaved[1]) {
				// TODO: check interleaved id
			}

      // Reference: https://tools.ietf.org/html/rfc3984
      rtpVersion = (rtpHeader[0] & 0xC0) >> 6;
      rtpPadding = (((rtpHeader[0] & 0x20) >> 5) === 1);
      rtpExtension = (((rtpHeader[0] & 0x10) >> 4) === 1);
      rtpCSRCCount = (rtpHeader[0] & 0x0F);
      rtpMarkerBit = (((rtpHeader[1] & 0x80) >> 7) === 1);
      rtpPayloadType = rtpHeader[1] & 0x7F;

      if (rtspInterleaved[0] !== 0x24) {
        throw new umpError({
          channelId: this.channelId,
          errorCode: fromHex('0x0102'),
          place: 'h265Session.js:156',
          message: "it is not valid interleave header (RTSP over TCP). Interleaved[0] = " + rtspInterleaved[0].toString(16)
        });

      } else if ((rtpHeader[0] & 0x0F) === 0x0F) {
        throw new umpError({
          channelId: this.channelId,
          errorCode: fromHex('0x0103'),
          place: 'h265Session.js:164',
          message: "There is additional CSRC which is not handled in this version. CSRC count = " + rtpCSRCCount
        });
      } else if ((rtpHeader[0] & 0x20) === 0x20) {
        PaddingSize = rtpPayload[rtpPayload.length - 1];
        h265rtpsession_log.debug("H265Session::PaddingSize - " + PaddingSize);
      }

      //Extension bit check in RTPHeader
      if (rtpExtension) {
        extensionHeaderLen = ((rtpPayload[2] << 8 | rtpPayload[3]) * 4) + 4;

        //Playback check
        if (rtpPayload[0] == '0xAB' && (rtpPayload[1] == '0xAD' || rtpPayload[1] == '0xAC')) {
          var startHeader = 4;

          NTPmsw.set(rtpPayload.subarray(startHeader, startHeader + 4), 0);
          startHeader += 4;
          NTPlsw.set(rtpPayload.subarray(startHeader, startHeader + 4), 0);
          if (this.getDeviceType() === 'camera') {
            startHeader += 6;
            gmt.set(rtpPayload.subarray(startHeader, startHeader + 2), 0);
          }

					var tempdata = {};
					tempdata.timestamp = ((this.ntohl(NTPmsw) - 0x83AA7E80) >>> 0);
					tempdata.timestamp_usec = (this.ntohl(NTPlsw) / 0xffffffff) * 1000;

					if (this.getDeviceType() === 'camera') {
						tempdata.timezone = (((gmt[0] << 8) | gmt[1]) << 16) >> 16;
					}

					if (this.GetTimeStamp().timestamp != null && this.GetTimeStamp().timestamp_usec !== null) {
						h265rtpsession_log.debug("", tempdata.timestamp, tempdata.timestamp_usec, this.GetTimeStamp().timestamp,  this.GetTimeStamp().timestamp_usec);
						var timeGap = Math.abs(tempdata.timestamp - this.GetTimeStamp().timestamp);
						if(timeGap <= 1) {
							var distance = Math.abs( (tempdata.timestamp*1000 + tempdata.timestamp_usec)-
																	(this.GetTimeStamp().timestamp*1000 + this.GetTimeStamp().timestamp_usec));
							if(distance != 0) {
								this.setFramerate(Math.round(1000 / distance));
								h265rtpsession_log.debug("playback framerate = ", this.getFramerate());
							}
						}
					}
					this.SetTimeStamp(tempdata);
					playback = true;
				}
			}

      PAYLOAD = rtpPayload.subarray(extensionHeaderLen, rtpPayload.length - PaddingSize);

      rtpTimeStamp = this.ntohl(rtpHeader.subarray(4, 8));
      rtpSquenceNumber = this.ntohl(rtpHeader.subarray(2, 3));

      // Reference: https://tools.ietf.org/html/rfc3550
      h265rtpsession_log.debug("interleaved id = ", this.interleavedId,
        ", HEVC RTP Version: ", ("00" + rtpVersion).slice(-2),
        ", Padding: ", rtpPadding,
        ", ExtensionBit: ", rtpExtension,
        ", CSRC Count: ", rtpCSRCCount,
        ", Marker Bit: ", rtpMarkerBit,
        ", RTP Payload Type: ", rtpPayloadType,
        ", RTP Sequence Number: ", rtpSquenceNumber,
        ", RTP Timestamp: ", rtpTimeStamp,
        ", RTCP Timestamp: " + this.rtcpSession.rtpTimestamp);

      // Reference: https://tools.ietf.org/html/rfc7798
      // 1.1.4 NAL Unit Header
      rtpForbiddenZeroBit = (PAYLOAD[0] & 0x80) >> 7;
      rtpNALType = (PAYLOAD[0] >> 1) & 0x3f;
      rtpLayerId = ((PAYLOAD[0]  & 0x01) << 6) + ((PAYLOAD[1]  & 0xF8) >> 3);
      rtpTID = (PAYLOAD[1]  & 0x07);
      if (rtpNALType == 0) {
        console.warn("This NAL type does not support on this application. nal_type = " + toHex(rtpNALType));
        throw new umpError({
          channelId: this.channelId,
          errorCode: fromHex('0x0101'),
          place: 'h265Session.js:154',
          message: "This NAL type does not support on this application. nal_type = " + toHex(rtpNALType)
        });
      } else {
      	h265rtpsession_log.debug("HEVC Forbidden Zero Bit: " + rtpForbiddenZeroBit +
                       ", Nal Unit Type: " + toHex(rtpNALType) +
                       ", LayerId: " + toHex(rtpLayerId) +
                       ", TDI: " + toHex(rtpTID) +
      								 ", Payload length: " + PAYLOAD.length);
      }

      switch (rtpNALType) {
        case HEVCNalUnit.HEVC_NAL_VPS: // VPS
          inputBuffer = setBuffer(PREFIX);
          inputBuffer = setBuffer(PAYLOAD);
          vpsPayload = PAYLOAD;
          break;
        case HEVCNalUnit.HEVC_NAL_SPS: // SPS
          inputBuffer = setBuffer(PREFIX);
          inputBuffer = setBuffer(PAYLOAD);
          spsPayload = PAYLOAD;
          break;
        case HEVCNalUnit.HEVC_NAL_PPS: // PPS
          inputBuffer = setBuffer(PREFIX);
          inputBuffer = setBuffer(PAYLOAD);
          ppsPayload = PAYLOAD;
          break;
        case HEVCNalUnit.HEVC_NAL_AUD: // AUD
          break;
        case HEVCNalUnit.HEVC_NAL_UNSPEC49: // Fragmentation unit(FU)
          var start_bit = ((PAYLOAD[2] & 0x80) === 0x80),
            end_bit = ((PAYLOAD[2] & 0x40) === 0x40),
            fu_type = PAYLOAD[2] & 0x3f,
            payload_start_index = 3,
            payloadTemp = PAYLOAD.subarray(payload_start_index, PAYLOAD.length);

          if (start_bit == true && end_bit == false) {
            var new_nal_header = new Uint8Array(2);
            new_nal_header[0] = (PAYLOAD[0] & 0x81) | (fu_type << 1);
            new_nal_header[1] = PAYLOAD[1];

            inputBuffer = setBuffer(PREFIX);
            inputBuffer = setBuffer(new_nal_header);
            inputBuffer = setBuffer(PAYLOAD.subarray(payload_start_index, PAYLOAD.length));
          } else {
            inputBuffer = setBuffer(PAYLOAD.subarray(payload_start_index, PAYLOAD.length));
          }
          h265rtpsession_log.debug("HEVC Raw Length: " + PAYLOAD.length);
          h265rtpsession_log.debug("HEVC Buff Length: " + inputBuffer.length);

          // h265rtpsession_log.debug("HEVC Raw Length: " + PAYLOAD.length + "\r\nData: ", PAYLOAD);
					// h265rtpsession_log.debug("HEVC Buff Length: " + inputBuffer.length + "\r\nData: ", inputBuffer);
          break;
        default:
          h265rtpsession_log.debug("HEVC Coded slice of an (" + rtpNALType  + ").\r\n" + "Reference: https://tools.ietf.org/html/rfc3984#section-5.7");
          inputBuffer = setBuffer(PREFIX);
          inputBuffer = setBuffer(PAYLOAD);
          break;
      } //end of switch(rtpNALType)
      //case 48 Remove because not use more

      //check marker bit
      if (rtpMarkerBit) {
        h265rtpsession_log.debug("HEVC Length: " + inputBuffer.length + "\r\nData: ", inputBuffer);
        var inputBufferSub = inputBuffer.subarray(0, inputLength);
        var frameType = '';
        this.rtpTimestamp = (rtpTimeStamp / 90).toFixed(0);

        // reset input length
        inputLength = 0;

        if (this.isInitializeReceivedPacketCount()) {
          this.setStartTimeStamp(this.rtpTimestamp);
          this.startMediaTimer();
        }

        this.increaseNumberOfReceivedPacketCount();
        if (inputBufferSub[4] == 0x40) {
          frameType = 'I';
        } else {
          frameType = 'P';
        }

        var playMode = (playback === true) ? 'Playback' : "Live";
        var streamData = {
          'codecType': 'H265',
          'frameData': inputBufferSub,
          'channelId': this.channelId,
          'packetSeq': this.getNumberOfReceivedPacketCount(),
          'receiveClock': performance.now(),
          'timeStamp': {
            'rtpTimestamp': this.rtpTimestamp,
            'timestamp': this.timeData.timestamp,
            'timestamp_usec': this.timeData.timestamp_usec,
            'timezone': this.timeData.timezone
          },
          'rtcp_interleavedId': this.rtcpSession.interleavedId
        };
        var videoInfo = {
          'frameType': frameType,
          'vpsPayload': vpsPayload,
          'spsPayload': spsPayload,
          'ppsPayload': ppsPayload,
          'framerate': this.getFramerate()
        };

        this.eventVideoCallback(playMode, streamData, videoInfo);

        //inputBuffer = new Uint8Array(size_1_4K);

        return;
      }
    },
  });

  return new Constructor();
};
/* global inheritObject, RtpSession */

/**
 * MjpegSession
 * @class MjpegSession
 */
var MjpegSession = function () {
  "use strict";

  var version = '1.0.0';
  var mjpegrtpsession_log = log4javascript.getLogger('mjpegrtpsession');

  var rtpDataArray = new Array();
  var rtpStackCheckNum = 50;
  var markerBitHex = 0x80;
  var mjpegDepacketizeWorker = null;
  var self = null;
  var rtpTimeStamp = 0;

  function Constructor() {}

  function WorkerMessage(event) {
    var message = event.data;
    self.eventVideoCallback(message.playMode, message.streamData, message.videoInfo);
  }

  Constructor.prototype = inheritObject(new RtpSession(), {
    /**
     * This function is initialize MjpegSession.
     * @function init
     * @memberof MjpegSession
     * @example
     *     example: MjpegSession.init();
     */
    init: function () {
      if (mjpegDepacketizeWorker === null) {
        mjpegrtpsession_log.info("generate depacketize worker.");
        mjpegDepacketizeWorker = new Worker('./media/ump/Worker/MjpegSession/mjpegDepacketizeWorker.js');
        mjpegDepacketizeWorker.onmessage = WorkerMessage;
      }
      self = this;
    },
    /**
     * This function is to depacketize frame packet.
     * @function depacketize
     * @memberof MjpegSession
     * @param {Uint8Array} rtspInterleaved rtsp interlead header
     * @param {Uint8Array} rtpHeader rtp header
     * @param {Uint8Array} rtpPayload rtp payloads
     * @example
     *     example: MjpegSession.depacketize(rtspInterleaved, rtpHeader, rtpPayload);
     */
    depacketize: function (rtspInterleaved, rtpHeader, rtpPayload) {
      var rtpData = {
        'rtspInterleave': rtspInterleaved,
        'channelId': this.channelId,
        'header': rtpHeader,
        'payload': rtpPayload
      };

      rtpTimeStamp = this.ntohl(rtpHeader.subarray(4, 8));

      rtpDataArray.push(rtpData);
      if (rtpDataArray.length >= rtpStackCheckNum || (rtpHeader[1] & markerBitHex) === markerBitHex) {
        this.rtpTimestamp = (rtpTimeStamp / 90).toFixed(0);

        if (this.isInitializeReceivedPacketCount()) {
          this.setStartTimeStamp(this.rtpTimestamp);
          this.startMediaTimer();
        }

        this.increaseNumberOfReceivedPacketCount();

        var message = {
          'dataArray': rtpDataArray.splice(0, rtpStackCheckNum),
        };

        if (mjpegDepacketizeWorker) {
          mjpegDepacketizeWorker.postMessage(message);
        }
      }
    },
    close: function() {
      if (mjpegDepacketizeWorker) {
        mjpegDepacketizeWorker.terminate();
        mjpegDepacketizeWorker = null;
        mjpegrtpsession_log.info("terminate depacketize worker.");
      }
    },
  });

  return new Constructor();
};
/* global Uint8Array, InitState, VideoBufferList */
/**
 * Class for control playback stream.
 * @class PlaybackBufferManager
 */
function PlaybackBufferManager() {
  "use strict";

  var version = '1.0.0';
  var log = log4javascript.getLogger('rtp_video');

  var bufferStatus = null;
  var buffer = null;
  var bufferSize = 0;
  var callbackFunc = null;
  var reserveNode = null;
  var _self;
  /**
   * When buffer is full, callback function called.
   * @function fullCallback
   */
  function fullCallback() {
    var message = bufferStatus.full();
    if ( typeof message !== 'undefined') {
      callbackFunc(message);
    }
  }

  /**
   * When buffer is cleared after full, callback function called.
   * @function restartCallback
   */
  function restartCallback() {
    var message = bufferStatus.restart();
    if (typeof message !== 'undefined') {
      callbackFunc(message);
    }
  }

  function Constructor() {
    log.debug("[#####PlaybackBufferManager#####]Create PlaybackBufferManager");
    _self = this;
    bufferStatus = new InitState(this);
    buffer = new VideoBufferList();
    buffer.setBufferFullCallback(fullCallback);
    Constructor.prototype.channelId = 0;
  }
  Constructor.prototype = {
    /**
     * Initialize buffer & status
     * @function init
     * @param {CallbackFunction} _callback to send message ('resume' and 'pause')
     * @memberof PlaybackBufferManager
     */
    init: function (_callback) {
      bufferStatus = new InitState(this);
      callbackFunc = _callback;
      if (typeof buffer !== "undefined" && buffer !== null) {
        buffer.clearBuffer();
      }
    },
    /**
     * Change buffer status
     * @function change
     * @param {State} status next status.
     */
    change: function (status) {
      bufferStatus = status;
    },
    /**
     * Push data into frame's buffer
     * @function push
     * @memberof PlaybackBufferManager
     * @param {object} bufferInfo what to push
     * @param {string} bufferInfo.playMode "Live" or "Playback"
     * @param {object} bufferInfo.streamData streamData object
     * @param {string} bufferInfo.streamData.codecType "MJPEG", "H264", "H265"
     * @param {Uint8Array} bufferInfo.streamData.frameData Depacketized frame data
     * @param {object} bufferInfo.streamData.timeStamp Timestamp data object
     * @param {number} bufferInfo.streamData.timeStamp.rtpTimeStamp RTP timeStamp
     * @param {number} bufferInfo.streamData.timeStamp.timestamp Frame timestamp
     * @param {number} bufferInfo.streamData.timeStamp.timestamp_usec Frame timestamp millisecond
     * @param {number} bufferInfo.streamData.timeStamp.timezone timezone.
     * @param {object} bufferInfo.videoInfo videoInfo object
     * @param {string} bufferInfo.videoInfo.frameType "I" or "P"
     * @param {number} bufferInfo.videoInfo.spsPayload sps
     * @param {number} bufferInfo.videoInfo.ppsPayload pps
     * @param {number} bufferInfo.videoInfo.framerate frame rate
     * @param {number} bufferInfo.videoInfo.width width for mjpeg
     * @param {number} bufferInfo.videoInfo.height height for mjpeg
     * @return {boolean} Is available to pop next frame
     */
    push: function (bufferInfo) {
      if (buffer === null) {
        return false;
      }
      if (typeof bufferInfo.videoInfo.framerate !== 'undefined' &&
        bufferInfo.videoInfo.framerate * 4 !== bufferSize) {
        bufferSize = bufferInfo.videoInfo.framerate * 4;
        buffer.setBUFFERING(bufferSize);
        buffer.setMaxLength(bufferInfo.videoInfo.framerate * 6);
      }
      bufferInfo.streamData.frameData = new Uint8Array(bufferInfo.streamData.frameData);
      buffer.push(bufferInfo.streamData.frameData, bufferInfo.videoInfo.width,
        bufferInfo.videoInfo.height, bufferInfo.streamData.codecType,
        bufferInfo.videoInfo.frameType, bufferInfo.streamData.timeStamp);
      return bufferStatus.push();
    },
    /**
     * Insert frame in front of buffer
     * @function front
     */
    front: function () {
      buffer.front(reserveNode);
      reserveNode = null;
    },
    /**
     * Change buffer status when 'Pause' event occured
     * @function pause
     * @memberof PlaybackBufferManager
     */
    pause: function () {
      var message = bufferStatus.pause(buffer);
      if ( typeof message !== 'undefined') {
        callbackFunc(message);
      }
    },
    /**
     * Change buffer status when 'Resume' event occured
     * @function resume
     * @memberof PlaybackBufferManager
     * @param {StepBufferList} buffer playback buffer list
     * @return {boolean} true if next frame is available to pop
     */
    resume: function () {
      var message = bufferStatus.resume(buffer);
      if ( typeof message !== 'undefined') {
        callbackFunc(message);
      }
      return bufferStatus.isReadyToPop();
    },
    /**
     * Pop buffer's frame.
     * @function pop
     * @memberof PlaybackBufferManager
     * @return {Object} if, no frame in buffer then return false
     *                  else if, there is a frame in buffer, then return frame info.
     */
    pop: function (isDecoderReady) {
      if (buffer === null) {
        return;
      }
      var bufferNode = buffer.pop();
      if (bufferNode === null || typeof bufferNode === "undefined") {
        bufferStatus.clear();
        return false;
      } else {
        reserveNode = bufferNode;
        var popFrameInfo = {
          'playMode': 'Playback',
          'streamData': {},
          'videoInfo': {}
        };
        popFrameInfo.streamData.codecType = bufferNode.codecType;
        popFrameInfo.streamData.frameData = bufferNode.buffer;
        popFrameInfo.streamData.timeStamp = bufferNode.timeStamp;
        popFrameInfo.videoInfo.frameType = bufferNode.frameType;
        popFrameInfo.videoInfo.width = bufferNode.width;
        popFrameInfo.videoInfo.height = bufferNode.height;


        if (buffer.getBufferLength() < 1 && isDecoderReady) {
          restartCallback();
        }
        return popFrameInfo;
      }
    },
    /**
     * Callback function when buffer is full
     * @function full
     * @memberof PlaybackBufferManager
     * @return  {Object}
     */
    full: function () {
      return bufferStatus.full();
    },
    /**
     * Callback function when buffer is empty after full
     * @function restart
     * @memberof PlaybackBufferManager
     * @return  {Object}
     */
    restart: function () {
      return bufferStatus.restart();
    },
    /**
     * Is available to pop next frame
     * @function isReadyToPop
     * @memberof PlaybackBufferManager
     * @return {Boolean}
     */
    isReadyToPop: function () {
      return bufferStatus.isReadyToPop();
    },
    /**
     * Clear buffer and initialize status
     * @function clear
     * @memberof PlaybackBufferManager
     */
    clear: function () {
      bufferStatus.clear();
    },
  };

    /**
   * This property is channel number.
   * @function channelId
   * @memberof PlaybackBufferManager
   * @example
   *    PlaybackBufferManager.channelId = ;
   */
  Object.defineProperty(this, "channelId", {
    get: function() {
        return channel;
    },
    set: function(v) {
      channel = v;
    },
  });

  return new Constructor();
}
/* global BufferList, inherit, BufferNode */
/* exported VideoBufferList*/
var videoBufferNode = (function () {
  "use strict";
  
  function Constructor(data, width, height, codecType, frameType, timeStamp) {
    BufferNode.call(this, data);
    this.width = width;
    this.height = height;
    this.codecType = codecType;
    this.frameType = frameType;
    this.timeStamp = timeStamp;
  }

  return Constructor;
})();

function VideoBufferList() {
  var MAX_LENGTH = 0,
    BUFFERING = 240,
    bufferFullCallback = null;
  var checkFull = false;

  function Constructor() {
    BufferList.call(this);
    MAX_LENGTH = 360;
    BUFFERING = 240;
    bufferFullCallback = null;
    checkFull = false;
  }

  Constructor.prototype = inherit(BufferList, {
    push: function (data, width, height, codecType, frameType, timeStamp) {
      var node = new videoBufferNode(data, width, height, codecType, frameType, timeStamp);
      if (this._length > 0) {
        this.tail.next = node;
        node.previous = this.tail;
        this.tail = node;
      } else {
        this.head = node;
        this.tail = node;
      }
      this._length += 1;

      if (bufferFullCallback !== null && this._length >= BUFFERING) {
        if (checkFull === false) {
          checkFull = true;
          bufferFullCallback();
        }
      } else {
        if (checkFull) {
          checkFull = false;
        }
      }
      //console.log("VideoBufferList after push node count is " + this._length +
      //  " frameType is " + frameType);

      return node;
    },
    front: function (node) {
      if (node === null) {
        return;
      }
      if (this._length > 0) {
        this.head.previous = node;
        node.next = this.head;
        this.head = node;
      } else {
        this.head = node;
        this.tail = node;
      }
      this._length += 1;
      //console.log("[front] push node and buffer length : ", this._length);
    },
    pop: function () {
//    console.log("before pop node count is " + this._length + " MINBUFFER is " + MINBUFFER);
      var node = null;

      if (this._length > 0) {
        node = this.head;
        this.head = this.head.next;
        if (this.head !== null) {
          this.head.previous = null;
          // 2nd use-case: there is no second node
        } else {
          this.tail = null;
        }
        this._length -= 1;
      }

      //console.log("                        [POP] current buffer length is : ", this._length,
      //  " and frame type is : ", node === null ? 'null' : node.frameType);
      return node;
    },
    setMaxLength: function (length) {
      MAX_LENGTH = length;
      if (MAX_LENGTH > 360) {
        MAX_LENGTH = 360;
      } else if (MAX_LENGTH < 30) {
        MAX_LENGTH = 30;
      }

    },
    setBUFFERING: function (interval) {
      BUFFERING = interval;
      if (BUFFERING > 240) {
        BUFFERING = 240;
      } else if (BUFFERING < 20) {
        BUFFERING = 20;
      }
      //console.log("________buffer max length : ", BUFFERING);
    },
    setBufferFullCallback: function (callback) {
      bufferFullCallback = callback;
      // console.log("setBufferFullCallback MAX_LENGTH is " + MAX_LENGTH );
    },
    searchTimestamp: function (frameTimestamp) {
      //      console.log("searchTimestamp frameTimestamp = " + frameTimestamp.timestamp + " frameTimestamp usec = " + frameTimestamp.timestamp_usec);
      var currentNode = this.head,
        length = this._length,
        count = 1,
        message = {
          failure: 'Failure: non-existent node in this list.'
        };

      // 1st use-case: an invalid position
      if (length === 0 || frameTimestamp <= 0 || currentNode === null) {
        throw new Error(message.failure);
      }

      // 2nd use-case: a valid position
      while (currentNode !== null &&
        (currentNode.timeStamp.timestamp !== frameTimestamp.timestamp ||
          currentNode.timeStamp.timestamp_usec !== frameTimestamp.timestamp_usec)) {
        //        console.log("currentNode Timestamp = " + currentNode.timeStamp.timestamp + " Timestamp usec = " + currentNode.timeStamp.timestamp_usec);
        currentNode = currentNode.next;
        count++;
      }

      if (length < count) {
        currentNode = null;
      } else {
        this.curIdx = count;
        // console.log("searchTimestamp curIdx = " + this.curIdx + " currentNode.timeStamp.timestamp = " + currentNode.timeStamp.timestamp + " currentNode.timestamp_usec = " + currentNode.timeStamp.timestamp_usec + " frameTimestamp = " + frameTimestamp.timestamp + " frameTimestamp usec = " + frameTimestamp.timestamp_usec);
      }

      return currentNode;
    },
    findIFrame: function (isForward) {
      var currentNode = this.head,
        length = this._length,
        count = 1,
        message = {
          failure: 'Failure: non-existent node in this list.'
        };

      // 1st use-case: an invalid position
      if (length === 0) {
        throw new Error(message.failure);
      }

      // 2nd use-case: a valid position
      while (count < this.curIdx) {
        currentNode = currentNode.next;
        count++;
      }

      if (isForward === true) {
        while (currentNode.frameType !== "I") {
          currentNode = currentNode.next;
          count++;
        }
      } else {
        while (currentNode.frameType !== "I") {
          currentNode = currentNode.previous;
          count--;
        }
      }

      if (length < count) {
        currentNode = null;
      } else {
        this.curIdx = count;
        // console.log('findIFrame curIdx ' + this.curIdx + ' count ' + count + ' _length ' + this._length);
      }

      return currentNode;
    },
    clearBuffer: function () {
      this.clear();
    },
    getBufferLength: function () {
      return this._length;
    },
  });
  return new Constructor();
}
var RtcpSession = function(clockfreq){
  "use strict";

  var ntpmsw,
    ntplsw,
    rtptimestamp,
    fsynctimestamp = 0,
    fsynctime = {},
    timestampfrequency = clockfreq;
  
  function noteIncomingSR(ntpmsw, ntplsw, rtptimestamp) {
    var microseconds = (ntplsw*15625.0)/0x04000000;       
    fsynctime.seconds = ntpmsw - 0x83AA7E80;        
    fsynctime.useconds = microseconds+0.5;
    fsynctimestamp = rtptimestamp;
  }

  function Constructor() {}

  Constructor.prototype = inheritObject(new RtpSession(), {
    SendRtpData: function(rtspInterleaved, rtpHeader, rtpPayload) {
      var startHeader = 0;
      var RTCPSize = rtpPayload.length + 12;
      var rtcpbuffer = new Uint8Array(new ArrayBuffer(RTCPSize));

      rtcpbuffer.set(rtpHeader,0);
      rtcpbuffer.set(rtpPayload,12);

      var rc = rtcpbuffer[0] & 0x1F; 
      var pt = rtcpbuffer[1];
      var length = 4*((rtcpbuffer[2] << 8) + rtcpbuffer[3]) + 1; // doesn't count hdr
      startHeader += 4;
     
      var reportSenderSSRC = new Uint8Array(new ArrayBuffer(4));
      reportSenderSSRC.set(rtcpbuffer.subarray(startHeader,startHeader+4),0);
      startHeader += 4;          
     
      if(pt === 200)
      {                  
          var NTPmsw = new Uint8Array(new ArrayBuffer(4));
          NTPmsw.set(rtcpbuffer.subarray(startHeader,startHeader+4),0);
         
          ntpmsw = this.ntohl(NTPmsw);                
          startHeader += 4;

          var NTPlsw = new Uint8Array(new ArrayBuffer(4));
          NTPlsw.set(rtcpbuffer.subarray(startHeader,startHeader+4),0);
        
          ntplsw = this.ntohl(NTPlsw); 
          startHeader += 4;

          var rtpTimestamp = new Uint8Array(new ArrayBuffer(4));
          rtpTimestamp.set(rtcpbuffer.subarray(startHeader,startHeader+4),0);
       
          rtptimestamp = this.ntohl(rtpTimestamp);

          startHeader += 4;                 

          //console.log("NTP TimeStamp: msb: lsb: rtptime:", ntpmsw, ntplsw, rtptimestamp);

          noteIncomingSR(ntpmsw, ntplsw, rtptimestamp);         
      }
    },

    calculatePacketTime: function(rtpTimeStamp) {
      var PresentationTime = {};
      var timestampdiff = rtpTimeStamp - fsynctimestamp;
      var timeDiff = timestampdiff/timestampfrequency; //timestamp freqency comes from SDP         

      var million = 1000000;
      var seconds, uSeconds;

      if(fsynctime.seconds === 0)
      {
          fsynctime.seconds = Math.round( new Date()/1000);
          fsynctime.useconds = 0;
      }

      if (timeDiff >= 0.0) {
        seconds = fsynctime.seconds + timeDiff;
        uSeconds = fsynctime.useconds + ((timeDiff - timeDiff)*million);
        if (uSeconds >= million) {
          uSeconds -= million;
          ++seconds;
        }
      } else {
        timeDiff = -timeDiff;
        seconds = fsynctime.seconds - (timeDiff);
        uSeconds = fsynctime.useconds - ((timeDiff -timeDiff)*million);
        if (uSeconds < 0) {
          uSeconds += million;
          --seconds;
        }
      }

      PresentationTime.tv_sec = seconds;
      PresentationTime.tv_usec = uSeconds;

      return PresentationTime;
    }
  });

  return new Constructor();
};
var HTTP_STATUS_CODES = { 
  '100': 'Continue',
  '101': 'Switching Protocols',
  '102': 'Processing',
  '103': 'Checkpoint',
  '200': 'OK',
  '201': 'Created',
  '202': 'Accepted',
  '203': 'Non-Authoritative Information',
  '204': 'No Content',
  '205': 'Reset Content',
  '206': 'Partial Content',
  '207': 'Multi-Status',
  '218': 'This is fine',
  '300': 'Multiple Choices',
  '301': 'Moved Permanently',
  '302': 'Moved Temporarily',
  '303': 'See Other',
  '304': 'Not Modified',
  '305': 'Use Proxy',
  '307': 'Temporary Redirect',
  '400': 'Bad Request',
  '401': 'Unauthorized',
  '402': 'Payment Required',
  '403': 'Forbidden',
  '404': 'Not Found',
  '405': 'Method Not Allowed',
  '406': 'Not Acceptable',
  '407': 'Proxy Authentication Required',
  '408': 'Request Time-out',
  '409': 'Conflict',
  '410': 'Gone',
  '411': 'Length Required',
  '412': 'Precondition Failed',
  '413': 'Request Entity Too Large',
  '414': 'Request-URI Too Large',
  '415': 'Unsupported Media Type',
  '416': 'Requested Range Not Satisfiable',
  '417': 'Expectation Failed',
  '418': 'I\'m a teapot',
  '420': 'Method Failure',
  '421': 'Misdirected Request',
  '422': 'Unprocessable Entity',
  '423': 'Locked',
  '424': 'Failed Dependency',
  '425': 'Unordered Collection',
  '426': 'Upgrade Required',
  '428': 'Precondition Required',
  '429': 'Too Many Requests',
  '431': 'Request Header Fields Too Large',
  '440': 'Login Time-out',
  '449': 'Retry With',
  '450': 'Blocked by Windows Parental Controls',
  '451': 'Unavailable For Legal Reasons',
  '490': 'Maximum account rearched',
  '498': 'Invalid Token',
  '499': 'Token Required',
  '500': 'Internal Server Error',
  '501': 'Not Implemented',
  '502': 'Bad Gateway',
  '503': 'Service Unavailable',
  '504': 'Gateway Time-out',
  '505': 'HTTP Version Not Supported',
  '506': 'Variant Also Negotiates',
  '507': 'Insufficient Storage',
  '509': 'Bandwidth Limit Exceeded',
  '510': 'Not Extended',
  '511': 'Network Authentication Required',
  '530': 'Site is frozen',
  '598': 'Network read timeout error'
};
function SunapiClient(device_info) {
    'use strict';

    var authInfo;
    var sunapiClient = {};
    var loggingOn = false;
    var isGruntServer = true;

    var AuthTypeEnum = {
        None: 0,
        Basic: 1,
        Digest: 2,
        OAuth: 3
    };

    var RESTCLIENT_CONFIG = {
        clientVersion: '1.00_20160404',
        serverType: 'camera', // 'grunt' or 'camera'
        authType: AuthTypeEnum.None,
        cors: false,
        digest: {
            hostname: '', //'211.189.132.70', /// by neighbor21 duks >>> /// 변경  192.168.75.77 -> 211.189.132.70
            port: 80, /// by neighbor21  duks
            protocol: 'http', /// by neighbor21 duks
            rtspPort: 554,
            ClientIPAddress: '127.0.0.1', //default client ip used for rtsp useragent will be replaced later
            username: '',
            password: '',
            authType: AuthTypeEnum.None,
        }
    };

    function Constructor(device_info) {
        var loc_protocol, splitProt;
        if (typeof device_info.debug !== 'undefined') {
            loggingOn = device_info.debug;
        }

        // if deviceType is not defined, default is camera
        if (device_info.deviceType !== undefined &&
            device_info.deviceType !== '' &&
            device_info.deviceType !== null) {
            RESTCLIENT_CONFIG.serverType = device_info.deviceType;
        } else {
            console.warn("The device type is not defined, set to 'camera' by default.");
        }

        // check input parameter
        if (RESTCLIENT_CONFIG.serverType === 'nvr' && (device_info.hostname === undefined ||
                device_info.hostname === '' && device_info.hostname === null)) {
            // if hostname is empty, throw invalid parameter
            throw new umpError({
                errorCode: fromHex('0x0401'),
                place: 'sunapiClient.js:52',
                message: "hostname is empty from input parameter."
            });
        } else if (RESTCLIENT_CONFIG.serverType === 'camera' && (device_info.cameraIp === undefined ||
                device_info.cameraIp === '' || device_info.cameraIp === null)) {
            // if cameraIp is empty, throw invalid parameter
            throw new umpError({
                errorCode: fromHex('0x0400'),
                place: 'sunapiClient.js:60',
                message: "cameraIP is empty from input parameter."
            });
        } else if(RESTCLIENT_CONFIG.serverType === undefined || RESTCLIENT_CONFIG.serverType === null) {
            throw new umpError({
                errorCode: fromHex('0x0404'),
                place: 'sunapiClient.js:67',
                message: "device type is undefined."
            });
        }
        // else {
        //     throw new umpError({
        //         errorCode: fromHex('0x0405'),
        //         place: 'sunapiClient.js:73',
        //         message: "invalid device info. for connection."
        //     });
        // }

        if (RESTCLIENT_CONFIG.serverType === 'nvr' && (device_info.username === undefined ||
                device_info.username === '' || device_info.username === null)) {
            // if cameraIp is empty, throw invalid parameter
            throw new umpError({
                errorCode: fromHex('0x0402'),
                place: 'sunapiClient.js:70',
                message: "username is empty from input parameter."
            });
        } else if (RESTCLIENT_CONFIG.serverType === 'camera' && (device_info.user === undefined ||
                device_info.user === '' || device_info.user === null)) {
            // if cameraIp is empty, throw invalid parameter
            throw new umpError({
                errorCode: fromHex('0x0402'),
                place: 'sunapiClient.js:78',
                message: "user id is empty from input parameter."
            });
        }

        if (device_info.password === undefined ||
            device_info.password === '' || device_info.password === null) {
            // if cameraIp is empty, throw invalid parameter
            throw new umpError({
                errorCode: fromHex('0x0403'),
                place: 'sunapiClient.js:80',
                message: "password is empty from input parameter."
            });
        }

        RESTCLIENT_CONFIG.authType = device_info.authType;

        if (RESTCLIENT_CONFIG.serverType === 'camera') {
            if (isGruntServer) {
                RESTCLIENT_CONFIG.digest.hostname = device_info.hostname;
                RESTCLIENT_CONFIG.digest.port = device_info.port;
            } else {
                RESTCLIENT_CONFIG.digest.hostName = window.location.hostname;
                RESTCLIENT_CONFIG.digest.port = window.location.port;
            }
            RESTCLIENT_CONFIG.digest.protocol = device_info.protocol;
            RESTCLIENT_CONFIG.digest.username = device_info.user;

            // if username is exist on input parameter, we will use username instead user
            if(device_info.username !== null && device_info.username !== undefined) {
                RESTCLIENT_CONFIG.digest.username = device_info.username;
            }
        } else if (RESTCLIENT_CONFIG.serverType === 'nvr') {
            RESTCLIENT_CONFIG.digest.hostname = device_info.hostname;
            RESTCLIENT_CONFIG.digest.port = device_info.port;
            RESTCLIENT_CONFIG.digest.protocol = device_info.protocol;
            RESTCLIENT_CONFIG.digest.username = device_info.username;
        }

        RESTCLIENT_CONFIG.digest.ClientIPAddress = device_info.ClientIPAddress;
        RESTCLIENT_CONFIG.digest.password = device_info.password;
    }

    var log = function (str) {
        if (loggingOn) {
            console.log('[sunapiClient] ' + str);
        }
    };

    sunapiClient.post = function (uri, jsonData, SuccessFn, FailFn, $scope, fileData, specialHeaders) {
        if (typeof jsonData !== 'undefined') {
            uri += jsonToText(jsonData);
        }

        return ajax_async("POST", uri, SuccessFn, FailFn, $scope, fileData, specialHeaders);
    };

    sunapiClient.get = function (uri, jsonData, SuccessFn, FailFn, $scope, isAsyncCall, isText) {
        uri = encodeURI(uri);
        if (typeof jsonData !== 'undefined') {
            uri += jsonToText(jsonData);

            if (uri.indexOf("attributes.cgi") == -1) {
                var sequencenum = new Date().getTime();
                uri += "&SunapiSeqId=" + sequencenum;
            }
        }

        if (uri.indexOf("configbackup") !== -1 || isAsyncCall === true) {
            return ajax_async("GET", uri, SuccessFn, FailFn, $scope, '', '', isText);
        } else {
            return ajax_sync("GET", uri, SuccessFn, FailFn, isText);
        }
    };

    sunapiClient.mobile = function (uri, device, SuccessFn, FailFn, optionalData) {
        var protocol = 'http',
            reqURL = "",
            xhr = new XMLHttpRequest(),
            auth = false,
            isTimeout = false;

        if (typeof optionalData !== 'undefined') {
            if (typeof optionalData.protocol !== 'undefined') {
                protocol = optionalData.protocol;
            }

            if (typeof optionalData.updateDate !== 'undefined') {
                uri += jsonToText(optionalData.updateDate);
            }
            if (typeof optionalData.auth !== 'undefined') {
                auth = true;
            }
        }

        reqURL = protocol + '://' + device.rtsp_url + ":" + device.rtsp_tunneling_port + uri;
        RESTCLIENT_CONFIG.digest.username = device.rtsp_id;
        RESTCLIENT_CONFIG.digest.password = device.rtsp_pwd;
        var OnErrorEvent = function (evt) {
            FailFn("Network Error");
        };

        // Mobile safari ( for iOS )
        if (Object.prototype.toString.call(window.HTMLElement).indexOf('Constructor') > 0) {
            xhr.onload = xhr.onabort = function () {
                if (this.status === 401) {
                    var wwwAuthenticate = this.getResponseHeader('www-authenticate');
                    var xhr = new XMLHttpRequest();

                    xhr.onload = xhr.onabort = function () {
                        isTimeout = false;
                        if (this.status === 200) {
                            if (typeof this.response !== 'undefined' && this.response !== "") {
                                var result = {};

                                if (this.responseType === 'arraybuffer' || this.responseXML !== null) {
                                    result.data = this.response;
                                    SuccessFn(result);
                                } else {
                                    var resp = JSON.parse(this.response);

                                    if (typeof resp === 'object') {
                                        result.data = resp;
                                        if (result.data.Response === "Fail") {
                                            FailFn(result.data.Error.Details);
                                        } else {
                                            SuccessFn(result);
                                        }
                                    } else {
                                        result.data = this.response;
                                        SuccessFn(result);
                                    }
                                }
                            } else {
                                FailFn("No response");
                            }
                        } else {
                            FailFn(xhr.status);
                        }
                    };

                    xhr.onerror = function () {
                        FailFn(xhr.status);
                    };
                    xhr.ontimeout = function () {
                        FailFn(408);
                    };

                    if (auth) {
                        xhr.open('GET', reqURL, false, RESTCLIENT_CONFIG.digest.username, RESTCLIENT_CONFIG.digest.password);
                    } else {
                        xhr.open('GET', reqURL, true, RESTCLIENT_CONFIG.digest.username, RESTCLIENT_CONFIG.digest.password);
                        xhr.timeout = 10000;
                    }

                    xhr.setRequestHeader('Accept', 'application/json');
                    xhr.setRequestHeader('Cache-Control', 'no-cache');
                    xhr.send();
                } else {
                    isTimeout = false;
                    if (this.status === 200) {
                        if (typeof this.response !== 'undefined' && this.response !== "") {
                            var result = {};

                            if (this.responseType === 'arraybuffer' || this.responseXML !== null) {
                                result.data = this.response;
                                SuccessFn(result);
                            } else {
                                var resp = JSON.parse(this.response);
                                if (typeof resp === 'object') {
                                    result.data = resp;
                                    if (result.data.Response === "Fail") {
                                        FailFn(result.data.Error.Details);
                                    } else {
                                        SuccessFn(result);
                                    }
                                } else {
                                    result.data = this.response;
                                    SuccessFn(result);
                                }
                            }
                        } else {
                            FailFn("No response");
                        }
                    }
                }
            };
            xhr.onerror = function () {
                FailFn(xhr.status);
            };
            xhr.ontimeout = function () {
                FailFn(408);
            };
            // Mobile Chrome
        } else {
            isTimeout = false;
            xhr.onreadystatechange = function () {
                if (this.readyState === 4) {
                    if (this.status === 401) {
                        var wwwAuthenticate = this.getResponseHeader('www-authenticate');
                        var xhr = new XMLHttpRequest();

                        xhr.onreadystatechange = function () {
                            if (this.readyState === 4) {
                                if (this.status === 200) {
                                    if (typeof this.response !== 'undefined' && this.response !== "") {
                                        var result = {};
                                        if (this.responseType === 'arraybuffer' || this.responseXML !== null) {
                                            result.data = this.response;
                                            SuccessFn(result);
                                        } else {
                                            var resp = JSON.parse(this.response);

                                            if (typeof resp === 'object') {
                                                result.data = resp;
                                                if (result.data.Response === "Fail") {
                                                    FailFn(result.data.Error.Details);
                                                } else {
                                                    SuccessFn(result);
                                                }
                                            } else {
                                                result.data = this.response;
                                                SuccessFn(result);
                                            }
                                        }
                                    } else {
                                        FailFn("No response");
                                    }
                                } else {
                                    FailFn(xhr.status);
                                }
                            }
                        };

                        // if(auth) {
                        //   xhr.open('GET', reqURL, false, RESTCLIENT_CONFIG.digest.username, RESTCLIENT_CONFIG.digest.password);
                        // } else {
                        xhr.open('GET', reqURL, true, RESTCLIENT_CONFIG.digest.username, RESTCLIENT_CONFIG.digest.password);
                        xhr.timeout = 5000;
                        // }

                        xhr.setRequestHeader('Accept', 'application/json');
                        xhr.ontimeout = function () {
                            FailFn(408);
                        };
                        xhr.send();
                    } else {
                        if (this.status === 200) {
                            if (typeof this.response !== 'undefined' && this.response !== "") {
                                var result = {};

                                if (this.responseType === 'arraybuffer' || this.responseXML !== null) {
                                    result.data = this.response;
                                    SuccessFn(result);
                                } else {
                                    var resp = JSON.parse(this.response);

                                    if (typeof resp === 'object') {
                                        result.data = resp;
                                        if (result.data.Response === "Fail") {
                                            FailFn(result.data.Error.Details);
                                        } else {
                                            SuccessFn(result);
                                        }
                                    } else {
                                        result.data = this.response;
                                        SuccessFn(result);
                                    }
                                }
                            } else {
                                FailFn("No response");
                            }
                        }
                    }
                }
            };
        }

        // if(auth) {
        //   xhr.open('GET', reqURL, false, RESTCLIENT_CONFIG.digest.username, RESTCLIENT_CONFIG.digest.password);
        // } else {
        xhr.open('GET', reqURL, true, RESTCLIENT_CONFIG.digest.username, RESTCLIENT_CONFIG.digest.password);
        xhr.timeout = 5000;
        // }
        xhr.ontimeout = function () {
            FailFn(408);
        };
        xhr.onerror = function () {
            FailFn(xhr.status);
        };
        xhr.setRequestHeader('Accept', 'application/json');
        xhr.setRequestHeader('Cache-Control', 'no-cache');
        log(reqURL);

        if (Object.prototype.toString.call(window.HTMLElement).indexOf('Constructor') > 0) {
            var process = $timeout(function () {
                isTimeout = true;
                xhr.send();
            }, 500);

            if (auth) {
                $timeout(function () {
                    if (isTimeout) {
                        $timeout.cancel(process);
                        FailFn('408');
                    }
                }, 10000);
            }
        } else {
            xhr.send();
        }
    };

    function setDigestHeader(xhr, method, uri, digestCache) {
        var responseValue, digestAuthHeader;
        if (digestCache) { // by neighbor21 duks  조건으로 구분 - digestCache 없는 경우가 있음.. 없는경우 로직 추가
            if (digestCache.scheme.toLowerCase() === 'digest') {
                digestCache.nc = digestCache.nc + 1;
                digestCache.cnonce = generateCnonce();

                responseValue = formulateResponse(RESTCLIENT_CONFIG.digest.username, RESTCLIENT_CONFIG.digest.password, uri, digestCache.realm, method.toUpperCase(), digestCache.nonce, digestCache.nc, digestCache.cnonce, digestCache.qop);

                digestAuthHeader = digestCache.scheme + ' ' + 'username="' + RESTCLIENT_CONFIG.digest.username + '", ' + 'realm="' + digestCache.realm + '", ' + 'nonce="' + digestCache.nonce + '", ' + 'uri="' + uri + '", ' + 'cnonce="' + digestCache.cnonce + '" ' + 'nc=' + decimalToHex(digestCache.nc, 8) + ', ' + 'qop=' + digestCache.qop + ', ' + 'response="' + responseValue + '"';

                xhr.setRequestHeader("Authorization", digestAuthHeader);
            } else if (digestCache.scheme.toLowerCase() === 'xdigest') {
                digestCache.nc = digestCache.nc + 1;
                digestCache.cnonce = generateCnonce();

                responseValue = formulateResponse(RESTCLIENT_CONFIG.digest.username, RESTCLIENT_CONFIG.digest.password, uri, digestCache.realm, method.toUpperCase(), digestCache.nonce, digestCache.nc, digestCache.cnonce, digestCache.qop);

                digestAuthHeader = digestCache.scheme + ' ' + 'username="' + RESTCLIENT_CONFIG.digest.username + '", ' + 'realm="' + digestCache.realm + '", ' + 'nonce="' + digestCache.nonce + '", ' + 'uri="' + uri + '", ' + 'cnonce="' + digestCache.cnonce + '" ' + 'nc=' + decimalToHex(digestCache.nc, 8) + ', ' + 'qop=' + digestCache.qop + ', ' + 'response="' + responseValue + '"';

                xhr.setRequestHeader("Authorization", digestAuthHeader);
            } else if (digestCache.scheme.toLowerCase() === 'basic') {
                digestAuthHeader = digestCache.scheme + ' ' + btoa(RESTCLIENT_CONFIG.digest.username + ':' + RESTCLIENT_CONFIG.digest.password);

                xhr.setRequestHeader("Authorization", digestAuthHeader);
            }
        } else {
            /// by neighbor21 duks DigestCache 정보 없는 경우 임의로 할당
            digestCache = {
                "scheme": "Digest",
                "realm": "",
                "nonce": null,
                "opaque": null,
                "qop": "auth",
                "nc": null,
                "cnonce": null
            };
            responseValue = formulateResponse(RESTCLIENT_CONFIG.digest.username, RESTCLIENT_CONFIG.digest.password, uri, digestCache.realm, method.toUpperCase(), digestCache.nonce, digestCache.nc, digestCache.cnonce, digestCache.qop);
            digestAuthHeader = digestCache.scheme + ' ' + 'username="' + RESTCLIENT_CONFIG.digest.username + '", ' + 'realm="' + digestCache.realm + '", ' + 'nonce="' + digestCache.nonce + '", ' + 'uri="' + uri + '", ' + 'cnonce="' + digestCache.cnonce + '" ' + 'nc=' + decimalToHex(digestCache.nc, 8) + ', ' + 'qop=' + digestCache.qop + ', ' + 'response="' + responseValue + '"';
            xhr.setRequestHeader("Authorization", digestAuthHeader);
        }
    }

    function isJSON(str) {
        try {
            return (JSON.parse(str) && !!str);
        } catch (e) {
            return false;
        }
    }

    function parseResponse(xhr, successFn, failFn, isText) {
        var result = {};

        if (xhr.responseType === 'blob' || xhr.responseType === 'arraybuffer' || xhr.responseXML !== null || isText) {
            result.data = xhr.response;
            successFn(result);
        } else {
            var resp;

            if (isJSON(xhr.response) === false) {
                resp = getDotEqualStrLineToObj(xhr.response);
            } else {
                resp = JSON.parse(xhr.response);
            }

            if (typeof resp === 'object') {
                result.data = resp;

                if (result.data.Response === "Fail") {
                    failFn(result.data.Error);
                } else {
                    successFn(result);
                }
            } else {
                result.data = xhr.response;
                successFn(result);
            }
        }
    }

    /// by neighbor21 duks 응답 데이터가 카메라와 NVR과 달라 파싱하는 함수를 추가함  -- '=' 로 Value 구분 'aaa.bbb.ccc=vlaue'
    function getDotEqualStrLineToObj(data) {
        var res = {};
        var tmRes = {};
        var strRes = data.split('\r\n');
        for (var i = 0; i < strRes.length; i++) {
            if (!strRes[i]) continue;
            var strKeyArr = strRes[i].split('=');
            var strDotArr = strKeyArr[0].split('.');
            if (strDotArr.length == 1) {
                res[strDotArr[0]] = strKeyArr[1];
            } else {
                for (var j = 0; j < strDotArr.length; j++) {
                    if (j == 0) {
                        if (!res[strDotArr[j]]) res[strDotArr[j]] = {};
                        tmRes = res[strDotArr[j]];
                    } else if (j < strDotArr.length - 1) {
                        if (!tmRes[strDotArr[j]]) tmRes[strDotArr[j]] = {};
                        tmRes = tmRes[strDotArr[j]];
                    } else if (j == strDotArr.length - 1) {
                        tmRes[strDotArr[j]] = strKeyArr[1];

                    }

                }
            }
        }
        log('result : ' + JSON.stringify(res));
        return res;

    }

    function handleAccountBlock(failFn, xhr) {
        ModalManagerService.open('message', {
            'buttonCount': 0,
            'message': "Exceeded maximum login attempts, please try after some time"
        });
        $location.path('/login');
        if (SessionOfUserManager.IsLoginSuccess() === false) {

            failFn("HTTP Error : ", xhr.status);
            log("After calling Account block fail fn");
        }
    }

    function setupAsyncCall(xhr, method, callbackList, uri, failFn) {
        var OnErrorEvent = function (evt) {
            failFn("Network Error");
        };

        if (typeof callbackList !== 'undefined' && callbackList !== '') {
            if (typeof callbackList.ProgressEvent !== 'undefined') {
                xhr.upload.addEventListener("progress", callbackList.ProgressEvent, false);
            }

            if (typeof callbackList.CompleteEvent !== 'undefined') {
                xhr.addEventListener("load", callbackList.CompleteEvent, false);
            }

            if (typeof callbackList.CancelEvent !== 'undefined') {
                xhr.addEventListener("abort", callbackList.CancelEvent, false);
            }

            if (typeof callbackList.FailEvent !== 'undefined') {
                xhr.addEventListener("error", callbackList.FailEvent, false);
            } else {
                xhr.addEventListener("error", OnErrorEvent, false);
            }
        }

        if (method === 'POST') {
            xhr.timeout = 300000;
        } else {
            xhr.timeout = 5000;
        }

        if (uri.indexOf("snapshot") !== -1) {
            xhr.responseType = 'blob';
        }

        if (uri.indexOf("configbackup") !== -1) {
            xhr.responseType = 'arraybuffer';
        }

        if (uri.indexOf("opensdk") !== -1) {
            xhr.withCredentials = true;
        }
    }

    function makeNewRequest(method, uri, isAsync, wwwAuthenticate, isText) {
        var restClientConfig = RESTCLIENT_CONFIG.digest;

        var server = restClientConfig.protocol + '://' + restClientConfig.hostname;

        if (typeof restClientConfig.port !== 'undefined' && restClientConfig.port !== null && restClientConfig.port !== '') {
            server += ':' + restClientConfig.port;
        }

        var xhr = new XMLHttpRequest();
        xhr.open(method, server + uri, isAsync);


        //if(SessionOfUserManager.IsWMFApp() === true  && RESTCLIENT_CONFIG.serverType === 'camera' &&
        //   (checkStaleResponseIssue(uri) === false))
        if (RESTCLIENT_CONFIG.serverType === 'camera' && RESTCLIENT_CONFIG.cors) {
            //Added for same origin request, now using custom digest to avoid browser hang and popups
            xhr.setRequestHeader('XClient', 'XMLHttpRequest');
        }

        if (!isText) {
            xhr.setRequestHeader('Accept', 'application/json');
        }

        /** If there is a new Challenge from server, update the local digest cache  */
        if (wwwAuthenticate !== '' && wwwAuthenticate !== undefined && wwwAuthenticate !== null) {
            // var responseHeaders = wwwAuthenticate.split('\n');

            // // get authenticate header
            // var digestHeaders;
            // for(var i = 0; i < responseHeaders.length; i++) {
            //     if (responseHeaders[i].match(/www-authenticate/i) != null) {
            //         digestHeaders = responseHeaders[i];
            //     }
            // }

            authInfo = getAuthInfoInWwwAuthenticate(wwwAuthenticate);
        }

        if (authInfo !== undefined && authInfo.scheme === 'Digest') {
            setDigestHeader(xhr, method, uri, authInfo);
        }
        // else
        // {
        /** Sometime the digest issued by the server becomes invalid,
        we need to request new digest from server again */
        // if (typeof digestInfo !== 'undefined' && digestInfo !== 'undefined')
        // {
        // setDigestHeader(xhr, method, uri, digestInfo);
        // } else { // by neighbor21  duks
        // setDigestHeader(xhr, method, uri);
        // }
        // }
        return xhr;
    }

    /**
     * When ever server return STALE parameter in digest header, browser shows popup before control coming to
     * XHR callback, Inorder to avaoid it we will remove digest cache in scenarios in which STALE response can happen
     * just a temporary workaround
     */

    function checkStaleResponseIssue(url) {
        var retVal = false;

        /** As of not it happens only after SSL certificate install and delete */
        if (url.indexOf("ssl") !== -1) {
            if (url.indexOf("install") !== -1 || url.indexOf("remove") !== -1) {
                retVal = true;
            }
        }
        return retVal;
    }


    sunapiClient.clearDigestCache = function () {
        log('Clearing the Diegest cache !!!!!!!!!!!! ');
        authInfo = undefined;
    };

    var ajax_sync = function (method, uri, successFn, failFn, isText) {
        var wwwAuthenticate, xhr;
        /*
            if (SessionOfUserManager.IsLoggedin() === true)
            {
                usrName = SessionOfUserManager.getUsername();
                passWord = SessionOfUserManager.getPassword();
            }
            else
            {
                $location.path('/login');
                return;
            }
            */
        //usrName = decode64(getCookie("DATA1"));
        //passWord = decode64(getCookie("DATA5"));

        /*
        if(usrName==''||passWord==''){
             log('ajax_sync cookie userName passWord is empty!!');
             return;
        }
        */

        xhr = makeNewRequest(method, uri, false, '', isText);

        xhr.onreadystatechange = function () {
            var wwwAuthenticate, xhr;
            if (this.readyState === this.HEADERS_RECEIVED) {
                wwwAuthenticate = this.getResponseHeader('www-authenticate');
                xhr = makeNewRequest(method, uri, true, wwwAuthenticate, isText);
            }

            if (this.readyState === XMLHttpRequest.DONE) {
                if (this.status === 401) {
                    wwwAuthenticate = this.getResponseHeader('www-authenticate');
                    xhr = makeNewRequest(method, uri, true, wwwAuthenticate, isText);

                    xhr.onreadystatechange = function () {
                        if (this.readyState === XMLHttpRequest.DONE) {
                            if (this.status === 200) {
                                if (typeof this.response !== 'undefined' && this.response !== "") {
                                    parseResponse(this, successFn, failFn, isText);
                                    // deferred.resolve('Success');
                                } else {
                                    failFn("No response");
                                    // deferred.reject('Failure');
                                }
                            } else {
                                if (this.status === 490) {
                                    ModalManagerService.open('message', {
                                        'buttonCount': 0,
                                        'message': "Exceeded maximum login attempts, please try after some time"
                                    });
                                    $location.path('/login');
                                }
                                failFn("HTTP Error : ", this.status);
                                // deferred.reject('Failure');
                            }
                        }
                    };

                    xhr.onerror = function () {
                        log("error response status" + xhr.status);
                        //if (xhr.status !== 401) {
                        //	self.log('Error ('+self.firstRequest.status+') on unauthenticated request to '+ request.data.url);
                        //	self.errorFn(self.firstRequest.status);
                        //}
                    };

                    log(uri);
                    if (typeof fileData !== 'undefined' && fileData !== null && fileData !== '') {
                        xhr.send(fileData);
                    } else {
                        xhr.send();
                    }
                } else {
                    if (this.status === 200) {
                        if (typeof this.response !== 'undefined' && this.response !== "") {
                            parseResponse(this, successFn, failFn, isText);
                            // deferred.resolve('Success');
                        } else {
                            failFn("No response");
                            // deferred.reject('Failure');
                        }
                    } else {
                        if (this.status === 490) {
                            ModalManagerService.open('message', {
                                'buttonCount': 0,
                                'message': "Exceeded maximum login attempts, please try after some time"
                            });
                            $location.path('/login');
                        }
                        failFn("HTTP Error : ", this.status);
                        // deferred.reject('Failure');
                    }
                }
            }
        };

        // handle error
        xhr.onerror = function () {
            log("error response status" + this.status);
            //if (xhr.status !== 401) {
            //	self.log('Error ('+self.firstRequest.status+') on unauthenticated request to '+ request.data.url);
            //	self.errorFn(self.firstRequest.status);
            //}
        };

        log('=====================================>', xhr);
        xhr.send();

        if (xhr.status === 200) {
            if (typeof xhr.response !== 'undefined' && xhr.response !== "") {
                parseResponse(xhr, successFn, failFn, isText);
            } else {
                failFn("No response");
            }
        } else if (xhr.status === 401) {
            wwwAuthenticate = xhr.getResponseHeader('www-authenticate');
            log("sync wwwAuthenticate : ", wwwAuthenticate);
            xhr = makeNewRequest(method, uri, false, wwwAuthenticate, isText);
            xhr.send();

            if (xhr.status === 200) {
                if (typeof xhr.response !== 'undefined' && xhr.response !== "") {
                    parseResponse(xhr, successFn, failFn, isText);
                } else {
                    failFn("No response");
                }
            } else {
                if (xhr.status === 490) {
                    handleAccountBlock(failFn, xhr);
                } else {
                    failFn("HTTP Error : ", xhr.status);
                }
            }
        } else {
            if (xhr.status === 490) {
                handleAccountBlock(failFn, xhr);
            } else {
                failFn("HTTP Error : ", xhr.status);
            }
        }
    };

    var ajax_async = function (method, uri, successFn, failFn, $scope, fileData, specialHeaders, isText) {
        var wwwAuthenticate, xhr;
        // var deferred = $q.defer();
        /*
                if (SessionOfUserManager.IsLoggedin() === true)
                {
                    usrName = SessionOfUserManager.getUsername();
                    passWord = SessionOfUserManager.getPassword();
                }
                else
                {
                    $location.path('/login');
                    return;
                }
         */
        //      /// by neighbor21 duks 주석처리 후 아래로 변경   
        //usrName = decode64(getCookie('DATA1'));
        //passWord = decode64(getCookie('DATA5'));
        /*
	    if(usrName==''||passWord==''){
	    	console.log('ajax_async cookie userName passWord is empty!!');
	    	return;
	    }
        */
        xhr = makeNewRequest(method, uri, true, '', isText);
        setupAsyncCall(xhr, method, $scope, uri, failFn);

        if (typeof specialHeaders !== 'undefined') {
            var hdrindex = 0;
            for (hdrindex = 0; hdrindex < specialHeaders.length; hdrindex = hdrindex + 1) {
                xhr.setRequestHeader(specialHeaders[hdrindex].Type, specialHeaders[hdrindex].Header);
            }
        }

        xhr.onreadystatechange = function () {
            var wwwAuthenticate, xhr;
            switch (this.readyState) {
                case this.DONE:
                    log("Done");
                    break;
                case this.LOADING:
                    log("Loading");
                    break;
                case this.OPENED:
                    log("Opened");
                    break;
                case this.HEADERS_RECEIVED:
                    log("Header received");
                    break;
                case this.UNSENT:
                    log("Unsent");
                    break;
            }
/*
            if (this.readyState === this.HEADERS_RECEIVED) {
                wwwAuthenticate = this.getResponseHeader('www-authenticate');
                var allResponseHeaders = this.getAllResponseHeaders();
                log("async wwwAuthenticate : ", wwwAuthenticate);
                log("allResponseHeaders: ", allResponseHeaders);

                xhr = makeNewRequest(method, uri, true, wwwAuthenticate, isText);
                setupAsyncCall(xhr, method, $scope, uri, failFn);

                xhr.onreadystatechange = function () {
                    if (this.readyState === this.DONE) {
                        if (this.status === 200) {
                            if (typeof this.response !== 'undefined' && this.response !== "") {
                                parseResponse(this, successFn, failFn, isText);
                                // deferred.resolve('Success');
                            } else {
                                failFn("No response");
                                // deferred.reject('Failure');
                            }
                        } else if (this.status === 401) {
                            wwwAuthenticate = this.getResponseHeader('www-authenticate');
                            log("async wwwAuthenticate : ", wwwAuthenticate);

                            xhr = makeNewRequest(method, uri, true, wwwAuthenticate, isText);
                            setupAsyncCall(xhr, method, $scope, uri, failFn);

                            xhr.onreadystatechange = function () {
                                if (this.readyState === 4) {
                                    if (this.status === 200) {
                                        if (typeof this.response !== 'undefined' && this.response !== "") {
                                            parseResponse(this, successFn, failFn, isText);
                                            // deferred.resolve('Success');
                                        } else {
                                            failFn("No response");
                                            // deferred.reject('Failure');
                                        }
                                    } else {
                                        if (this.status === 490) {
                                            ModalManagerService.open('message', {
                                                'buttonCount': 0,
                                                'message': "Exceeded maximum login attempts, please try after some time"
                                            });
                                            $location.path('/login');
                                        }
                                        failFn("HTTP Error : ", this.status);
                                        // deferred.reject('Failure');
                                    }
                                }
                            };

                            xhr.onerror = function () {
                                log("error response status" + this.status);
                                //if (xhr.status !== 401) {
                                //	self.log('Error ('+self.firstRequest.status+') on unauthenticated request to '+ request.data.url);
                                //	self.errorFn(self.firstRequest.status);
                                //}
                            };

                            log(uri);
                            if (typeof fileData !== 'undefined' && fileData !== null && fileData !== '') {
                                xhr.send(fileData);
                            } else {
                                xhr.send();
                            }
                        } else {
                            if (this.status === 490) {
                                ModalManagerService.open('message', {
                                    'buttonCount': 0,
                                    'message': "Exceeded maximum login attempts, please try after some time"
                                });
                                $location.path('/login');
                            }
                            failFn("HTTP Error : ", this.status);
                            // deferred.reject('Failure');
                        }
                    }
                };

                xhr.onerror = function () {
                    log("error response status" + xhr.status);
                    //if (xhr.status !== 401) {
                    //	self.log('Error ('+self.firstRequest.status+') on unauthenticated request to '+ request.data.url);
                    //	self.errorFn(self.firstRequest.status);
                    //}
                };

                log(uri);
                if (typeof fileData !== 'undefined' && fileData !== null && fileData !== '') {
                    xhr.send(fileData);
                } else {
                    xhr.send();
                }
            }*/

            if (this.readyState === this.DONE) {
                if (this.status === 401) {
                    wwwAuthenticate = this.getResponseHeader('www-authenticate');
                    log("async wwwAuthenticate : ", wwwAuthenticate);

                    xhr = makeNewRequest(method, uri, true, wwwAuthenticate, isText);
                    setupAsyncCall(xhr, method, $scope, uri, failFn);

                    xhr.onreadystatechange = function () {
                        if (this.readyState === this.DONE) {
                            if (this.status === 200) {
                                if (typeof this.response !== 'undefined' && this.response !== "") {
                                    parseResponse(this, successFn, failFn, isText);
                                    // deferred.resolve('Success');
                                } else {
                                    failFn("No response");
                                    // deferred.reject('Failure');
                                }
                            } else {
                                if (this.status === 490) {
                                    if(ModalManagerService !== undefined) {
                                        ModalManagerService.open('message', {
                                            'buttonCount': 0,
                                            'message': "Exceeded maximum login attempts, please try after some time"
                                        });
                                        $location.path('/login');
                                    }
                                    failFn(this.status);
                                }
                                failFn(this.status);
                                // deferred.reject('Failure');
                            }
                        }
                    };

                    xhr.onerror = function () {
                        log("error response status" + this.status);
                        //if (xhr.status !== 401) {
                        //	self.log('Error ('+self.firstRequest.status+') on unauthenticated request to '+ request.data.url);
                        //	self.errorFn(self.firstRequest.status);
                        //}
                    };

                    log(uri);
                    if (typeof fileData !== 'undefined' && fileData !== null && fileData !== '') {
                        xhr.send(fileData);
                    } else {
                        xhr.send();
                    }
                } else {
                    if (this.status === 200) {
                        if (typeof this.response !== 'undefined' && this.response !== "") {
                            log(this.response);
                            parseResponse(this, successFn, failFn, isText);
                            // deferred.resolve('Success');
                        } else {
                            failFn("No response");
                            // deferred.reject('Failure');
                        }
                    } else {
                        if (this.status === 490) {
                            ModalManagerService.open('message', {
                                'buttonCount': 0,
                                'message': "Exceeded maximum login attempts, please try after some time"
                            });
                            $location.path('/login');
                        }
                        failFn("HTTP Error : ", this.status);
                        // deferred.reject('Failure');
                    }
                }
            }
        };

        // handle error
        xhr.onerror = function () {
            log("error response status" + this.status);
            //if (xhr.status !== 401) {
            //	self.log('Error ('+self.firstRequest.status+') on unauthenticated request to '+ request.data.url);
            //	self.errorFn(self.firstRequest.status);
            //}
        };

        log(uri);
        if (typeof fileData !== 'undefined' && fileData !== null && fileData !== '') {
            xhr.send(fileData);
        } else {
            xhr.send();
        }
        // return deferred;
    };

    var response = function(e) {
        var urlCreator = window.URL || window.webkitURL;
        var imageUrl = urlCreator.createObjectURL(this.response);
        // 	document.querySelector("#image").src = imageUrl;
    }

    var generateCnonce = function () {
        var characters = 'abcdef0123456789';
        var token = '';
        for (var i = 0; i < 16; i++) {
            var randNum = Math.round(Math.random() * characters.length);
            token += characters.substr(randNum, 1);
        }
        return token;
    };

    var formulateResponse = function (username, password, uri, realm, method, nonce, nc, cnonce, qop) {
        var HA1 = CryptoJS.MD5(username + ':' + realm + ':' + password).toString();
        var HA2 = CryptoJS.MD5(method + ':' + uri).toString();
        var response = CryptoJS.MD5(HA1 + ':' + nonce + ':' + decimalToHex(nc, 8) + ':' + cnonce + ':' + qop + ':' + HA2).toString();

        return response;
    };

    var getAuthInfoInWwwAuthenticate = function (wwwAuthenticate) {
        var digestHeaders = wwwAuthenticate;
        var scheme = null;
        var realm = null;
        var nonce = null;
        var opaque = null;
        var qop = null;
        var cnonce = null;
        var nc = null;
        var returnValue;

        if (digestHeaders !== null) {
            digestHeaders = digestHeaders.split(',');
            scheme = digestHeaders[0].split(/\s/)[0];

            for (var i = 0; i < digestHeaders.length; i++) {
                var keyVal = digestHeaders[i].split('=');
                var key = keyVal[0];
                var val = keyVal[1].replace(/\"/g, '').trim();

                if (key.match(/realm/i) !== null) {
                    realm = val;
                }

                if (key.match(/nonce/i) !== null) {
                    nonce = val;
                }

                if (key.match(/opaque/i) !== null) {
                    opaque = val;
                }

                if (key.match(/qop/i) !== null) {
                    qop = val;
                }
            }

            cnonce = generateCnonce();
            nc++;

            returnValue = {
                "scheme": scheme,
                "realm": realm,
                "nonce": nonce,
                "opaque": opaque,
                "qop": qop,
                "cnonce": cnonce,
                "nc": nc
            };
        }

        return returnValue;
    };

    var decimalToHex = function (d, padding) {
        var hex = Number(d).toString(16);
        padding = typeof (padding) === 'undefined' || padding === null ? padding = 2 : padding;

        while (hex.length < padding) {
            hex = "0" + hex;
        }
        return hex;
    };

    var jsonToText = function (json) {
        var uri = '';

        for (var key in json) {
            if (typeof json[key] === 'boolean') {
                uri += '&' + key + '=' + (json[key] === true ? "True" : "False");
            } else {
                uri += '&' + key + '=' + json[key];
            }
        }

        return uri;
    };

    var DetectBrowser = function () {
        var BrowserDetectRes = {};
        BrowserDetectRes.isOpera = (!!window.opr && !!opr.addons) || !!window.opera || navigator.userAgent.indexOf(' OPR/') >= 0;
        // Firefox 1.0+
        BrowserDetectRes.isFirefox = typeof InstallTrigger !== 'undefined';
        // At least Safari 3+: "[object HTMLElementConstructor]"
        BrowserDetectRes.isSafari = Object.prototype.toString.call(window.HTMLElement).indexOf('Constructor') > 0;
        // Internet Explorer 6-11
        BrowserDetectRes.isIE = /*@cc_on!@*/ false || !!document.documentMode;
        // Edge 20+
        BrowserDetectRes.isEdge = !BrowserDetectRes.isIE && !!window.StyleMedia;
        // Chrome 1+
        BrowserDetectRes.isChrome = !!window.chrome && !!window.chrome.webstore;
        // Blink engine detection
        BrowserDetectRes.isBlink = (BrowserDetectRes.isChrome || BrowserDetectRes.isOpera) && !!window.CSS;

        return BrowserDetectRes;
    };

    Constructor.prototype = {
        get: function (uri, jsonData, SuccessFn, FailFn, $scope, isAsyncCall, isText) {
            return sunapiClient.get(uri, jsonData, SuccessFn, FailFn, $scope, isAsyncCall, isText);
        },
        post: function (uri, jsonData, SuccessFn, FailFn, $scope, fileData, specialHeaders) {
            return sunapiClient.post(uri, jsonData, SuccessFn, FailFn, $scope, fileData, specialHeaders);
        },
        setTimeout: function (timeout) {
            if (timeout !== 'undefined') {
                RESTCLIENT_CONFIG.digest.timeout = timeout;
            }
        }
    };

    return new Constructor(device_info);
}
// sunapi exception object
// by @young.ho.kim

// Create an object type sunapiException
sunapiException = function() {
};

/**
 * Form a string of relevant information.
 *
 * When providing this method, tools like Firebug show the returned 
 * string instead of [object Object] for uncaught exceptions.
 *
 * @return {String} information about the exception
 */
sunapiException.prototype.toString = function() {
    var name = this.name || 'unknown';
    var message = this.message || 'no description';
    return '[' + name + '] ' + message;
};
// sunapiManager object
// by @inorganik

// dependent upon CryptoJS MD5 hashing:
// http://crypto-js.googlecode.com/svn/tags/3.1.2/build/rollups/md5.js
var sunapiManager = function () {
  "use strict";
  var _version = '0.0.2';
  var log = log4javascript.getLogger();
  var useSunapiClient = true;

  var sunapiClient;
  var uri = {
    URI_PROFILE:          '/stw-cgi/media.cgi?msubmenu=videoprofile',
    URI_PROFILE_POLICY:   '/stw-cgi/media.cgi?msubmenu=videoprofilepolicy',
    URI_STREAM_URI:       '/stw-cgi/media.cgi?msubmenu=streamuri',
    URI_SESSION_KEY:      '/stw-cgi/media.cgi?msubmenu=sessionkey',
    URI_STORAGE_INFO:     '/stw-cgi/recording.cgi?msubmenu=storage',
    URI_RECORDING_SETUP:  '/stw-cgi/recording.cgi?msubmenu=general',
    URI_SEARCH_RECORDING_PERIOD:  '/stw-cgi/recording.cgi?msubmenu=general'
  };

  var cgi = {
    SYSTEM_CGI:                'system.cgi',
    MEDIA_CGI:                  'media.cgi',
    RECORDING_CGI:          'recording.cgi',
    VIDEO_CGI:                  'video.cgi'
  };

  var submenu = {
    DEVICE_INFO:              'deviceinfo',
    VIDEO_PROFILE:              'videoprofile',
    VIDEO_PROFILE_POLICY:       'videoprofilepolicy',
    VIDEO_STREAM_URI:           'streamuri',
    VIDEO_SESSION_KEY:          'sessionkey',
    RECORDING_STORAGE_INFO:     'storage',
    RECORDING_SETUP:            'general',
    RECORDING_SEARCH_PERIOD:    'searchrecordingperiod',
    RECORDING_CALENDAR_SEARCH:  'calendarsearch',
    RECORDING_OVERLAPPED:       'overlapped',
    RECORDING_TIMELINE:         'timeline',
    SNAPSHOT:                           'snapshot'
  };

  var action = {
    VIEW:                       'view',
    SET:                        'set',
    ADD:                        'add',
    UPDATE:                     'update',
    REMOVE:                     'remove',
    CONTROL:                    'control',
    MONITORDIFF:                'monitordiff',
    CHECK:                      'check'
  };

  var SessionKey;
  var VideoProfiles;
  var VideoProfilePolicies;
  var StorageInfo;
  var RecordingSetup;
  var SearchRecordingPeriod;
  var loc_protocol = window.location.protocol;
  var splitProt =loc_protocol.split(":");
  var device = {
    ClientIPAddress: '127.0.0.1',
    cameraIp: '',
    captureName: '',
    username: '',
    password: '',
    port: 80,
    protocol: splitProt[0],
    hostname: '',
    deviceType: 'nvr',
    timeout: 10,
    debug: true,
    async: false
  };
  var LONG_POLLING_TIMEOUT = 15000;

  var isJson = function(str) {
    try {
    JSON.parse(str);
    } catch (e) {
    return false;
    }
    return true;
  };

  var version = function () { 
    return _version;
  };

  function Constructor() {
    Constructor.prototype.version = version();
  }

  Constructor.prototype = {
  /**
   * This function is initialize sunapiManager.
   * @function init
   * @memberof sunapiManager
   * @example
   *     example: sunapiManager.init(info);
   */
  init: function (info) {
    device = info;
  //  device.hostname = info.hostname;

    var loc_protocol = window.location.protocol;
    var splitProt =loc_protocol.split(":");

    if(device.protocol !== splitProt[0]) {
        device.protocol = splitProt[0];
    }

    if(info.deviceType !== 'nvr') {
      info.hostname = info.cameraIp;
      info.username = info.user;
    }

    if(info.port !== window.location.port) {
      device.port = info.port;
    }

    if(sunapiClient !== undefined) {
      sunapiClient = null; 
    }

    if(sunapiClient === undefined) {
      if(useSunapiClient) {
        sunapiClient = new SunapiClient(device);
      } else {
        sunapiClient = new sunapiRestClient();
        sunapiClient.init(device);
      }
    }
  },
  getSunapiClient: function () {
    return sunapiClient;
  },
  setSunapiClient: function (v) {
    sunapiClient = v;
  },
  getDeviceInfo: function() {
    return new Promise(function (resolve, reject) {
      var sunapiURI  = '/stw-cgi/' + cgi.SYSTEM_CGI;
      sunapiURI += '?msubmenu=' + submenu.DEVICE_INFO;
      sunapiURI += '&action=' + action.VIEW;
      var getData = {};
      try{
        sunapiClient.get(sunapiURI, getData,
          function (response) {
            if(typeof response === 'string') {
              response = JSON.parse(response);
            }
            if(response.data !== undefined) {
              response = response.data;
            }
            if (typeof callback !== 'undefined' && callback != null ) { 
              callback(response); 
            } else { 
              resolve(response);
            } 
          },
          function (errorData) {
            if (typeof callback !== 'undefined' && callback != null) { 
              callback(errorData);
            } else {
              reject(errorData);
            }
          }, '', (device.async) ? true : false);
      } catch (error) {
        throw new umpError({
          errorCode: fromHex('0x0700'),
          message: error.message
        });
      }
    });
  },
  getSnapshot: function(profile, channel) {
    return new Promise(function (resolve, reject) {
      var sunapiURI  = '/stw-cgi/' + cgi.VIDEO_CGI;
      sunapiURI += '?msubmenu=' + submenu.SNAPSHOT;
      sunapiURI += '&action=' + action.VIEW;
      if(profile !== null && profile !== undefined) {
        if(Number.isInteger(Number(profile))) {
          sunapiURI += '&Profile=' + profile;
        } else {
          throw new umpError({
            errorCode: fromHex('0x0409'),
            message: "Invalid profile number"
          });  
        }
      }
      if(channel !== null && channel !== undefined) {
        if(Number.isInteger(Number(channel))) {
          sunapiURI += '&Channel=' + channel;
        } else {
          throw new umpError({
            errorCode: fromHex('0x0409'),
            message: "Invalid profile number"
          });  
        }
      } else {
        sunapiURI += '&Channel=0';
      }
      var getData = {};
      try{
        sunapiClient.get(sunapiURI, getData,
          function (response) {
            if(typeof response === 'string') {
              response = JSON.parse(response);
            }
            if(response.data !== undefined && response.data.size !== 0) {
              if (typeof callback !== 'undefined' && callback != null ) { 
                callback(response); 
              } else { 
                resolve(response);
              }  
            }
          },
          function (errorData) {
            if (typeof callback !== 'undefined' && callback != null) { 
              callback(errorData);
            } else {
              reject(errorData);
            }
          }, '', true);
      } catch (error) {
        throw new umpError({
          errorCode: fromHex('0x0700'),
          message: error.message
        });
      }
    });
  },
  getVideoProfileAll: function() {
    return new Promise(function (resolve, reject) {
      var sunapiURI  = '/stw-cgi/' + cgi.MEDIA_CGI;
          sunapiURI += '?msubmenu=' + submenu.VIDEO_PROFILE;
          sunapiURI += '&action=' + action.VIEW;

      var getData = {};
      log.debug("sunapi URI", sunapiURI);
      try {
        sunapiClient.get(sunapiURI, getData,
        function (response) {
          if(typeof response === 'string') {
            response = JSON.parse(response);
          }
          if(response.data !== undefined) {
            response = response.data;
          }
          if (typeof callback !== 'undefined' && callback != null ) { 
            callback(response.VideoProfiles); 
          } else { 
            resolve(response.VideoProfiles);
          } 
        },
        function (errorData) {
          if (typeof callback !== 'undefined' && callback != null) { 
            callback(errorData);
          } else {
            reject(errorData);
          }
        }, '', (device.async) ? true : false);
      } catch (error) {
        throw new umpError({
          errorCode: fromHex('0x0700'),
          message: error.message
        });
      }
    });
  },
  getVideoProfile: function(channel) {
    return new Promise(function (resolve, reject) {
      var sunapiURI  = '/stw-cgi/' + cgi.MEDIA_CGI;
          sunapiURI += '?msubmenu=' + submenu.VIDEO_PROFILE;
          sunapiURI += '&action=' + action.VIEW;
      if(typeof channel !== 'undefined') {
          log.debug("request channel number: " + channel);
          sunapiURI += "&Channel=" + channel;
      }
      //var url = device.protocol + "://" + device.serverAddress + sunapiURI;
      var getData = {};
      log.debug("sunapi URI", sunapiURI);
      try {
        sunapiClient.get(sunapiURI, getData,
        function (response) { 
          if(typeof response === 'string') {
            response = JSON.parse(response);
          }
          if(response.data !== undefined) {
            response = response.data;
          }
          if (typeof callback !== 'undefined' && callback != null ) { 
            callback(response.VideoProfiles); 
          } else {
            //setTimeout(function(){ console.log("sleep 1 second"); resolve(response.VideoProfiles);}, 3000);
            resolve(response.VideoProfiles);
          } 
        },
	    function (errorData) {
        if (typeof callback !== 'undefined' && callback != null) { 
	        callback(errorData);
	      } else {
          reject(errorData);
	      }
	    }, '', (device.async) ? true : false);
      } catch (error) {
        throw new umpError({
          errorCode: fromHex('0x0700'),
          message: error.message
        });
      }
    });
  },
  getVideoProfilePolicyAll: function () {
    return new Promise(function (resolve, reject) {
      var sunapiURI  = '/stw-cgi/' + cgi.MEDIA_CGI;
          sunapiURI += '?msubmenu=' + submenu.VIDEO_PROFILE_POLICY;
          sunapiURI += '&action=' + action.VIEW;

      var getData = {};
      log.debug("sunapi URI", sunapiURI);
      try {
        sunapiClient.get(sunapiURI, getData,
        function (response) {
          if(typeof response === 'string') {
            response = JSON.parse(response);
          }
          if(response.data !== undefined) {
            response = response.data;
          }
          if (typeof callback !== 'undefined' && callback != null ) { 
            callback(response.VideoProfilePolicies); 
          } else { 
            resolve(response.VideoProfilePolicies);
          } 
        },
	    function (errorData) {
          if (typeof callback !== 'undefined' && callback != null) { 
	        callback(errorData);
	      } else {
            //console.log(errorData); 
            reject(errorData);
	      }
	    }, '', (device.async) ? true : false);
      } catch (error) {
        throw new umpError({
          errorCode: fromHex('0x0700'),
          message: error.message
        });
      }
    });
  },
  getVideoProfilePolicy: function (channel) {
    return new Promise(function (resolve, reject) {
      var sunapiURI  = '/stw-cgi/' + cgi.MEDIA_CGI;
          sunapiURI += '?msubmenu=' + submenu.VIDEO_PROFILE_POLICY;
          sunapiURI += '&action=' + action.VIEW;
      if(typeof channel !== 'undefined') {
          log.debug("request channel number: " + channel);
          sunapiURI += "&Channel=" + channel;
      }
      var getData = {};
      log.debug("sunapi URI", sunapiURI);
      try {
        sunapiClient.get(sunapiURI, getData,
        function (response) {
          if(typeof response === 'string') {
            response = JSON.parse(response);
          }
          if(response.data !== undefined) {
            response = response.data;
          }
          if (typeof callback !== 'undefined' && callback != null ) { 
            callback(response.VideoProfilePolicies); 
          } else { 
            resolve(response.VideoProfilePolicies);
          } 
        },
	    function (errorData) {
          if (typeof callback !== 'undefined' && callback != null) { 
	        callback(errorData);
	      } else {
            //console.log(errorData); 
            reject(errorData);
	      }
	    }, '', (device.async) ? true : false);
      } catch (error) {
        throw new umpError({
          errorCode: fromHex('0x0700'),
          message: error.message
        });
      }
    });
  },
  getRtspStreamURL: function (channel, profile, mediaType, mode) {
    return new Promise(function (resolve, reject) {
      log.debug("getRtspURL: channel (" +  channel + "), profile: ("+ profile + ")" + "), MediaType: (" + mediaType + "), mode: (" + mode);
      var sunapiURI  = '/stw-cgi/' + cgi.MEDIA_CGI;
          sunapiURI += '?msubmenu=' + submenu.VIDEO_STREAM_URI;
          sunapiURI += '&action=' + action.VIEW;
          if(typeof channel !== 'undefined') {
            log.debug("request channel number: " + channel);
            sunapiURI += "&Channel=" + channel;
          }
          if(typeof profile !== 'undefined') {
            log.debug("request profile number: " + profile);
            sunapiURI += "&Profile=" + profile;
          }
          if(typeof mode !== 'undefined') {
            sunapiURI += "&Mode=" + mode;
          }  
          if(typeof  mediaType !== 'undefined') {
            sunapiURI += "&MediaType=" + mediaType;
          }
          sunapiURI += "&StreamType=RTPUnicast&TransportProtocol=TCP&RTSPOverHTTP=False&ClientType=PC";
      
      var getData = {};
      log.debug("sunapi URI", sunapiURI);
      try {
        sunapiClient.get(sunapiURI, getData,
        function (response) { 
          if(typeof response === 'string') {
            response = JSON.parse(response);
          }
          if(response.data !== undefined) {
            response = response.data;
          }
          if (typeof callback !== 'undefined' && callback != null ) { 
            callback(response); 
          } else { 
            resolve(response);
          } 
        },
        function (errorData) {
          if (typeof callback !== 'undefined' && callback != null) { 
            callback(errorData);
          } else {
            //console.log(errorData); 
            reject(errorData);
          }
        }, '', (device.async) ? true : false);
      } catch (error) {
        throw new umpError({
          errorCode: fromHex('0x0700'),
          message: error.message
        });
      }
    });
  },
  getSessionKey: function () {
    return new Promise(function (resolve, reject) {
      log.debug("getSessionKey");
      var sunapiURI  = '/stw-cgi/' + cgi.MEDIA_CGI;
          sunapiURI += '?msubmenu=' + submenu.VIDEO_SESSION_KEY;
          sunapiURI += '&action=' + action.VIEW;
      var getData = {};
      log.debug("sunapi URI", sunapiURI);
      try {
        sunapiClient.get(sunapiURI, getData,
        function (response) {
          if(typeof response === 'string') {
            response = JSON.parse(response);
          }
          if(response.data !== undefined) {
            response = response.data;
          }
          SessionKey = response;
          if (typeof callback !== 'undefined' && callback != null ) { 
            callback(response); 
          } else { 
            resolve(response);
          } 
        },
        function (errorData) {
          if (typeof callback !== 'undefined' && callback != null) { 
            callback(errorData);
          } else {
            //console.log(errorData); 
            reject(errorData);
          }
        }, '', (device.async) ? true : false);
        sunapiClient.join();
      } catch (error) {
        throw new umpError({
          errorCode: fromHex('0x0700'),
          message: error.message
        });
      }
    });
  },
  getStorageInfo: function () {
    return new Promise(function (resolve, reject) {
      log.debug("getStorageInfo");
      var sunapiURI  = '/stw-cgi/' + cgi.RECORDING_CGI;
          sunapiURI += '?msubmenu=' + submenu.RECORDING_STORAGE_INFO;
          sunapiURI += '&action=' + action.VIEW;
      var getData = {};
      log.debug("sunapi URI", sunapiURI);
      try {
        sunapiClient.get(sunapiURI, getData,
        function (response) {
          if(typeof response === 'string') {
            response = JSON.parse(response);
          }
          if(response.data !== undefined) {
            response = response.data;
          }
          StorageInfo = response;
          if (typeof callback !== 'undefined' && callback != null ) { 
            callback(response); 
          } else {
            resolve(response);
          } 
        },
        function (errorData) {
          if (typeof callback !== 'undefined' && callback != null) { 
            callback(errorData);
          } else {
            //console.log(errorData); 
            reject(errorData);
          }
        }, '', (device.async) ? true : false);
        sunapiClient.join();
      } catch (error) {
        throw new umpError({
          errorCode: fromHex('0x0700'),
          message: error.message
        });
      }
    });
  },
  getRecordingSetup: function () {
    return new Promise(function (resolve, reject) {
      log.debug("getRecordingSetup");
      var sunapiURI  = '/stw-cgi/' + cgi.RECORDING_CGI;
          sunapiURI += '?msubmenu=' + submenu.RECORDING_SETUP;
          sunapiURI += '&action=' + action.VIEW;
      var getData = {};
      log.debug("sunapi URI", sunapiURI);
      try {
        sunapiClient.get(sunapiURI, getData,
        function (response) {
          if(typeof response === 'string') {
            response = JSON.parse(response);
          }
          if(response.data !== undefined) {
            response = response.data;
          }
          RecordingSetup = response;
          if (typeof callback !== 'undefined' && callback != null ) { 
            callback(response); 
          } else { 
            resolve(response);
          } 
        },
        function (errorData) {
          if (typeof callback !== 'undefined' && callback != null) { 
            callback(errorData);
          } else {
            //console.log(errorData); 
            reject(errorData);
          }
        }, '', (device.async) ? true : false);
        sunapiClient.join();
      } catch (error) {
        throw new umpError({
          errorCode: fromHex('0x0700'),
          message: error.message
        });
      }
    });
  },
  getSearchRecordingPeriod: function () {
    return new Promise(function (resolve, reject) {
      log.debug("getSearchRecordingPeriod");
      var sunapiURI  = '/stw-cgi/' + cgi.RECORDING_CGI;
          sunapiURI += '?msubmenu=' + submenu.RECORDING_SEARCH_PERIOD;
          sunapiURI += '&action=' + action.VIEW;
      var getData = {};
      log.debug("sunapi URI", sunapiURI);
      try {
        sunapiClient.get(sunapiURI, getData,
        function (response) {
          if(typeof response === 'string') {
            response = JSON.parse(response);
          }
          if(response.data !== undefined) {
            response = response.data;
          }
          SearchRecordingPeriod = response;
          if (typeof callback !== 'undefined' && callback != null ) { 
            callback(response); 
          } else { 
            resolve(response);
          } 
        },
        function (errorData) {
          if (typeof callback !== 'undefined' && callback != null) { 
            callback(errorData);
          } else {
            //console.log(errorData); 
            reject(errorData);
          }
        }, '', (device.async) ? true : false);
        sunapiClient.join();
      } catch (error) {
        throw new umpError({
          errorCode: fromHex('0x0700'),
          message: error.message
        });
      }
    });
  },
  getCalendarSearch: function (month, channelIdList) {
    return new Promise(function (resolve, reject) {
      log.debug("getCalendarSearch");
      var sunapiURI  = '/stw-cgi/' + cgi.RECORDING_CGI;
          sunapiURI += '?msubmenu=' + submenu.RECORDING_CALENDAR_SEARCH;
          sunapiURI += '&action=' + action.VIEW;
          if(typeof month !== 'undefined') {
            log.debug("request month: " + month);
            sunapiURI += "&Month=" + month;
          }          
          if(typeof channelIdList !== 'undefined') {
            log.debug("request ChannelIdList number: " + channelIdList);
            sunapiURI += "&ChannelIdList=" + channelIdList;
          } else {
            sunapiClient.setTimeout(LONG_POLLING_TIMEOUT);
          }
      var getData = {};
      log.debug("sunapi URI", sunapiURI);
      try {
        sunapiClient.get(sunapiURI, getData,
        function (response) {
          if(typeof response === 'string') {
            response = JSON.parse(response);
          }
          if(response.data !== undefined) {
            response = response.data;
          }
          if (typeof callback !== 'undefined' && callback != null ) { 
            callback(response);
          } else { 
            resolve(response);
          } 
        },
        function (errorData) {
          if (typeof callback !== 'undefined' && callback != null) { 
            callback(errorData);
          } else {
            reject(errorData);
          }
        }, '', (device.async) ? true : false);
        sunapiClient.join();
      } catch (error) {
        throw new umpError({
          errorCode: fromHex('0x0700'),
          message: error.message
        });
      }
    });
  },
  getOverlappedIdList: function (fromDate, toDate, channelIdList) {
    return new Promise(function (resolve, reject) {
      log.debug("getOverlappedIdList");
      var sunapiURI  = '/stw-cgi/' + cgi.RECORDING_CGI;
          sunapiURI += '?msubmenu=' + submenu.RECORDING_OVERLAPPED;
          sunapiURI += '&action=' + action.VIEW;
          if(typeof fromDate !== 'undefined' && typeof toDate !== 'undefined') {
            log.debug("From Date: " + fromDate + ", ToDate" + toDate);
            sunapiURI += "&FromDate=" + fromDate;
            sunapiURI += "&ToDate=" + toDate;
          } else {
            throw new sunapiException("Invalid Parameter. This request do not execute.");
          }
          if(typeof channelIdList !== 'undefined') {
            log.debug("request ChannelIdList number: " + channelIdList);
            sunapiURI += "&ChannelIdList=" + channelIdList;
          }
      var getData = {};
      log.debug("sunapi URI", sunapiURI);
      try {
        sunapiClient.get(sunapiURI, getData,
        function (response) {
          if(typeof response === 'string') {
            response = JSON.parse(response);
          }
          if(response.data !== undefined) {
            response = response.data;
          }
          if (typeof callback !== 'undefined' && callback != null ) { 
            callback(response);
          } else { 
            resolve(response);
          } 
        },
        function (errorData) {
          if (typeof callback !== 'undefined' && callback != null) { 
            callback(errorData);
          } else {
            reject(errorData);
          }
        }, '', (device.async) ? true : false);
        sunapiClient.join();
      } catch (error) {
        throw new umpError({
          errorCode: fromHex('0x0700'),
          message: error.message
        });
      }
    });
  },
  getTimeline: function (fromDate, toDate, channelIdList, overlappedId, type) {
    return new Promise(function (resolve, reject) {
      log.debug("getTimeline");
      var sunapiURI  = '/stw-cgi/' + cgi.RECORDING_CGI;
          sunapiURI += '?msubmenu=' + submenu.RECORDING_TIMELINE;
          sunapiURI += '&action=' + action.VIEW;
          if(fromDate !== undefined) {
            log.debug("From Date: " + fromDate);
            sunapiURI += "&FromDate=" + fromDate;
          } else {
            throw new sunapiException("Invalid Parameter. This request do not execute.");
          }
          if(toDate !== undefined) {
            log.debug("ToDate" + toDate);
            sunapiURI += "&ToDate=" + toDate;
          } else {
            throw new sunapiException("Invalid Parameter. This request do not execute.");
          }

          if(channelIdList !== undefined) {
            log.debug("request ChannelIdList number: " + channelIdList);
            sunapiURI += "&ChannelIdList=" + channelIdList;
          }
          
          if(typeof overlappedId !== 'undefined') {
            log.debug("request ChannelIdList number: " + overlappedId);
            sunapiURI += "&OverlappedID=" + overlappedId;
          } else {
            sunapiURI += "&OverlappedID=";
          }

          if(typeof type !== 'undefined') {
            sunapiURI += "&Type=" + type;
          } else {
            sunapiURI += "&Type=All";
          }
      var getData = {};
      log.debug("sunapi URI", sunapiURI);
      try {
        sunapiClient.get(sunapiURI, getData,
        function (response) {
          if(typeof response === 'string') {
            response = JSON.parse(response);
          }
          if(response.data !== undefined) {
            response = response.data;
          }
          if (callback !== undefined && callback != null ) {
            callback(response);
          } else {
            resolve(response);
          }
        },
        function (errorData) {
          if (callback !== undefined && callback != null) { 
            callback(errorData);
          } else {
            reject(errorData);
          }
        }, '', (device.async) ? true : false);
        sunapiClient.join();
      } catch (error) {
        //throw new sunapiException("getTimeline error occured");
        throw new umpError({
          errorCode: fromHex('0x0700'),
          message: error.message
        });
      }
    });
  }
  };
  return new Constructor();
};
// digest auth request
// by @inorganik

// dependent upon CryptoJS MD5 hashing:
// http://crypto-js.googlecode.com/svn/tags/3.1.2/build/rollups/md5.js
var sunapiRestClient = function () {
  "use strict";
  var log = log4javascript.getLogger();
  var _version = '0.0.1';

  var DEVICE_CONFIG = {
    serverType: 'camera',        // 'grunt' or 'camera'
    hostname: '',//'211.189.132.70', /// by neighbor21 duks >>> /// 변경  192.168.75.77 -> 211.189.132.70
    port: 80,  /// by neighbor21  duks
    protocol: 'http', /// by neighbor21 duks
    rtspPort: 554,
    ClientIPAddress: '127.0.0.1', //default client ip used for rtsp useragent will be replaced later
    username: '',
    password: ''
  };
  var data = null;
  var successFn;
  var errorFn;
  var worker;
  var authInfo;
  var promise_mode = true;
  var _self;
  var promise;

  var onMessage = function (event) {
    log.debug("onMessage Event: ", JSON.stringify(event));

    if (event.data !== "" &&
      event.data !== null &&
      typeof event.data !== 'undefined') {
      if (event.data.id === 'auth') {
        if (typeof event.data.auth === 'object') {
          authInfo = event.data.auth;
        }
      } else {
        if (event.data.success && event.data.id === 'response') {
          successFn(event.data.response);
        } else {
          errorFn(event.data.status);
        }
        this.terminate();
      }
    }
  };

  var onError = function (err) {
    log.debug("onError Event: " + JSON.stringify(err));
    if (err.message === "Not a critical error") {
      log.debug(err.message);
    } else {
      log.debug(err.message);
    }
    worker.terminate();
  };

  var post = function (uri, jsonData, $scope, fileData, specialHeaders) {
    data = {
      async: true,
      deviceInfo: DEVICE_CONFIG,
      method: 'post',
      uri: uri,
      body: jsonData,
      scope: $scope,
      file: fileData,
      header: specialHeaders,
      isText: isText,
      auth: authInfo,
      promise: promise_mode
    };

    if (!promise_mode) {
      worker = new Worker('/media/ump/Worker/sunapi/sunapiRequestTask.js');
      //worker.onmessage = onMessage;	
      worker.addEventListener('message', onMessage);
      //worker.onerror = onError;
      worker.addEventListener('error', onError);

      worker.postMessage(data);
    } else {
      worker = new Worker('/media/ump/Worker/sunapi/sunapiRequestTask.js');
      promise = new Promise(function (resolve, reject) {
        worker.onmessage = function (event) {
          log.debug("onMessage Event: ", JSON.stringify(event));

          if (event.data !== "" &&
            event.data !== null &&
            typeof event.data !== 'undefined') {
            if (event.data.id === 'auth') {
              if (typeof event.data.auth === 'object') {
                authInfo = event.data.auth;
              }
            } else {
              if (event.data.success && event.data.id === 'response') {
                successFn(event.data.response);
              } else {
                errorFn(event.data);
              }
              resolve();
              this.terminate();
            }
          }
        };
        worker.onerror = function (err) {
          log.error("Worker Error: " + err);
        };
      });
      worker.postMessage(data);
    }
  };

  var get = function (uri, jsonData, $scope, isAsyncCall, isText) {
    data = {
      async: (isAsyncCall) ? true : false,
      deviceInfo: DEVICE_CONFIG,
      method: 'get',
      uri: uri,
      body: jsonData,
      scope: $scope,
      isText: isText,
      auth: authInfo,
      promise: promise_mode
    };

    if (!promise_mode) {
      worker = new Worker('/media/ump/Worker/sunapi/sunapiRequestTask.js');
      //worker.onmessage = onMessage;	
      worker.addEventListener('message', onMessage);
      //worker.onerror = onError;
      worker.addEventListener('error', onError);

      worker.postMessage(data);
    } else {
      worker = new Worker('/media/ump/Worker/sunapi/sunapiRequestTask.js');
      promise = new Promise(function (resolve, reject) {
        worker.onmessage = function (event) {
          log.debug("onMessage Event: ", JSON.stringify(event));

          if (event.data !== "" &&
            event.data !== null &&
            typeof event.data !== 'undefined') {
            if (event.data.id === 'auth') {
              if (typeof event.data.auth === 'object') {
                authInfo = event.data.auth;
              }
            } else {
              if (event.data.success && event.data.id === 'response') {
                successFn(event.data.response);
              } else {
                errorFn(event.data);
              }
              resolve();
              this.terminate();
            }
          }
        };
        worker.onerror = function (err) {
          log.error("Worker Error: " + err);
        };
      });
      worker.postMessage(data);
    }
  };

  var jsonToText = function (json) {
    var uri = '';
    for (var key in json) {
      if (typeof json[key] === 'boolean') {
        uri += '&' + key + '=' + (json[key] === true ? "True" : "False");
      } else {
        uri += '&' + key + '=' + json[key];
      }
    }
    return uri;
  };

  var version = function () {
    return _version;
  };

  function Constructor() {
    _self = this;
    Constructor.prototype.version = version();
  }

  Constructor.prototype = {
    /**
     * This function is initialize sunapiRestClient.
     * @function init
     * @memberof sunapiRestClient
     * @example
     *     example: sunapiRestClient.init(deviceInfo);
     */
    init: function (device_info) {
      log.info("Version: " + Constructor.prototype.version);

      // if deviceType is not defined, default is camera
      if (device_info.deviceType !== undefined &&
        device_info.deviceType !== '' &&
        device_info.deviceType !== null) {
          DEVICE_CONFIG.serverType = device_info.deviceType;
      } else {
        console.warn("The device type is not defined, set to 'camera' by default.");
      }

      // check input parameter
      if (DEVICE_CONFIG.serverType === 'nvr' && (device_info.hostname === undefined ||
        device_info.hostname === '' && device_info.hostname === null)) {
        // if hostname is empty, throw invalid parameter
        throw new umpError({
          errorCode: fromHex('0x0401'),
          place: 'sunapiClient.js:52',
          message: "hostname is empty from input parameter."
        });
      } else if (DEVICE_CONFIG.serverType === 'camera' && (device_info.cameraIp === undefined ||
        device_info.cameraIp === '' || device_info.cameraIp === null)) {
        // if cameraIp is empty, throw invalid parameter
        throw new umpError({
          errorCode: fromHex('0x0400'),
          place: 'sunapiClient.js:60',
          message: "cameraIP is empty from input parameter."
        });
      }

      if (DEVICE_CONFIG.serverType === 'nvr' && (device_info.username === undefined ||
        device_info.username === '' || device_info.username === null)) {
        // if cameraIp is empty, throw invalid parameter
        throw new umpError({
          errorCode: fromHex('0x0402'),
          place: 'sunapiClient.js:70',
          message: "username is empty from input parameter."
        });
      } else if (DEVICE_CONFIG.serverType === 'camera' && (device_info.user === undefined ||
        device_info.user === '' || device_info.user === null)) {
        // if cameraIp is empty, throw invalid parameter
        throw new umpError({
          errorCode: fromHex('0x0402'),
          place: 'sunapiClient.js:78',
          message: "user id is empty from input parameter."
        });
      }

      if (device_info.password === undefined ||
        device_info.password === '' || device_info.password === null) {
        // if cameraIp is empty, throw invalid parameter
        throw new umpError({
          errorCode: fromHex('0x0403'),
          place: 'sunapiClient.js:80',
          message: "password is empty from input parameter."
        });
      }
    

      var loc_protocol = window.location.protocol;
      var splitProt = loc_protocol.split(":");

      DEVICE_CONFIG.serverType = device_info.deviceType;
      DEVICE_CONFIG.hostname = device_info.hostname;
      DEVICE_CONFIG.port = device_info.port;
      DEVICE_CONFIG.protocol = splitProt[0];
      DEVICE_CONFIG.ClientIPAddress = device_info.ClientIPAddress;
      DEVICE_CONFIG.username = device_info.username;
      DEVICE_CONFIG.password = device_info.password;
    },
    get: function (uri, jsonData, SuccessFn, FailFn, $scope, isAsyncCall, isText) {
      successFn = SuccessFn;
      errorFn = FailFn;
      return get(uri, jsonData, $scope, isAsyncCall, isText);
    },
    post: function (uri, jsonData, SuccessFn, FailFn, $scope, fileData, specialHeaders) {
      successFn = SuccessFn;
      errorFn = FailFn;

      return post(uri, jsonData, $scope, fileData, specialHeaders);
    },
    join: function () {
      if (!promise_mode) {
        log.warning('this function is support only promise mode!!');
        return;
      }

      Promise.resolve(promise);
    },
    setTimeout: function (timeout) {
      if (timeout !== 'undefined') {
        DEVICE_CONFIG.timeout = timeout;
      }
    }
  };

  return new Constructor();
};
var RTSP = function () {
  "use strict";

  var version = '1.0.0';
  var rtsp_log = log4javascript.getLogger('rtsp:parser');

  var AuthType = {};
  AuthType.Enum(
    'Basic', // 0
    'Digest', // 1
  );

  var CommandType = {};
  CommandType.Enum(
    'OPTIONS ', // 0: An OPTIONS request returns the request types the server will accept.
    'DESCRIBE', // 1: A DESCRIBE request includes an RTSP URL (rtsp://...), and the type of reply data that can be handled. This reply includes the presentation description, typically in Session Description Protocol (SDP) format. Among other things, the presentation description lists the media streams controlled with the aggregate URL. In the typical case, there is one media stream each for audio and video.
    'SETUP', // 2: A SETUP request specifies how a single media stream must be transported. This must be done before a PLAY request is sent. The request contains the media stream URL and a transport specifier. This specifier typically includes a local port for receiving RTP data (audio or video), and another for RTCP data (meta information). The server reply usually confirms the chosen parameters, and fills in the missing parts, such as the server's chosen ports. Each media stream must be configured using SETUP before an aggregate play request may be sent.
    'PLAY', // 3: A PLAY request will cause one or all media streams to be played. Play requests can be stacked by sending multiple PLAY requests. The URL may be the aggregate URL (to play all media streams), or a single media stream URL (to play only that stream). A range can be specified. If no range is specified, the stream is played from the beginning and plays to the end, or, if the stream is paused, it is resumed at the point it was paused.
    'PAUSE', // 4: A PAUSE request temporarily halts one or all media streams, so it can later be resumed with a PLAY request. The request contains an aggregate or media stream URL. A range parameter on a PAUSE request specifies when to pause. When the range parameter is omitted, the pause occurs immediately and indefinitely.
    'GET_PARAMETER', // 5: The GET_PARAMETER request retrieves the value of a parameter of a presentation or stream specified in the URI. The content of the reply and response is left to the implementation. GET_PARAMETER with no entity body may be used to test client or server liveness ("ping").
    'SET_PARAMETER', // 6: This method requests to set the value of a parameter for a presentation or stream specified by the URI.
    'RECORD', // 7: This method initiates recording a range of media data according to the presentation description. The time stamp reflects start and end time(UTC). If no time range is given, use the start or end time provided in the presentation description. If the session has already started, commence recording immediately. The server decides whether to store the recorded data under the request URI or another URI. If the server does not use the request URI, the response should be 201 and contain an entity which describes the states of the request and refers to the new resource, and a Location header.
    'ANNOUNCE', // 8: The ANNOUNCE method serves two purposes: When sent from client to server, ANNOUNCE posts the description of a presentation or media object identified by the request URL to a server. When sent from server to client, ANNOUNCE updates the session description in real-time. If a new media stream is added to a presentation (e.g., during a live presentation), the whole presentation description should be sent again, rather than just the additional components, so that components can be deleted.
    'REDIRECT', // 9: A REDIRECT request informs the client that it must connect to another server location. It contains the mandatory header Location, which indicates that the client should issue requests for that URL. It may contain the parameter Range, which indicates when the redirection takes effect. If the client wants to continue to send or receive media for this URI, the client MUST issue a TEARDOWN request for the current session and a SETUP for the new session at the designated host.
    'TEARDOWN', // 10: A TEARDOWN request is used to terminate the session. It stops all media streams and frees all session related data on the server.
  );

  function Constructor() {
    Constructor.prototype.channelId = 0;
  }

  Constructor.prototype = {
    init: function () {
      rtsp_log.info("Session::init");
      this.sequence_number = 0;
      this.version = 0;
      this.status = new RtspStatusCode(-1);
      this.auth = AuthType.Basic;
    },
    rtspParser: function (message) {
      var TokenziedLines;

      /*Handling only the RTSP Response and not SDP*/
      if (message.search("Content-Type: application/sdp") !== -1) {
        var messageTok = message.split("\r\n\r\n");
        message = messageTok[0];
      }

      TokenziedLines = message.split("\r\n");
      var this_ = this;

      // parser RTSP status header
      TokenziedLines.forEach(function (entry) {
        if (entry.toLowerCase().indexOf('rtsp') >= 0) {
          var temp = entry.split(' ');
          var this__ = this_;
          temp.forEach(function (instance) {
            // get RTSP version
            if (instance.toLowerCase().indexOf('rtsp') >= 0) {
              this__.version = instance.split("/")[1];
              //console.log(this.version);
              rtsp_log.debug('RTSP Version:', this__.version);

              // TODO check RTSP Version
              // if RTSP version is not 1.0, throw RTSP version exception
            }
            // get RTSP status code
            if (!isNaN(parseInt(instance))) {
              this__.status = new RtspStatusCode(parseInt(instance));
              rtsp_log.debug('RTSP Status:', this__.status.getStatusCode(), this__.status.getDescription());
            }
          });
        }

        if (entry.toLowerCase().indexOf('cseq') >= 0) {
          var seekPoint = entry.search('CSeq: ') + 5;
          this_.CSeq = parseInt(message.slice(seekPoint, seekPoint + 10)) + 1;

          rtsp_log.debug('RTSP CSeq:', this_.CSeq);
        }
        // parser www authenticate header
        if (entry.toLowerCase().indexOf("www-authenticate") >= 0) {
          var temp = entry.split(' ');
          rtsp_log.debug('RTSP Authenticate Info.:', JSON.stringify(temp));
          var this__ = this_;
          temp.forEach(function (instance) {
            if (instance.toLowerCase().indexOf('basic') >= 0) {
              this__.auth = AuthType.Basic;
            } else if (instance.toLowerCase().indexOf('digest') >= 0) {
              this__.auth = AuthType.Digest;
            }

            if (instance.toLowerCase().indexOf('realm') >= 0) {
              var pattern = /[",]/g;
              this__.realm = instance.split('=')[1].replace(pattern, '');
              rtsp_log.debug('RTSP realm Info.:', JSON.stringify(this__.realm));
            }

            if (instance.toLowerCase().indexOf('nonce') >= 0) {
              var pattern = /[",]/g;
              this__.nonce = instance.split('=')[1].replace(pattern, '');
              rtsp_log.debug('RTSP nonce Info.:', JSON.stringify(this__.nonce));
            }

            if (instance.toLowerCase().indexOf('opaque') >= 0) {
              var pattern = /[",]/g;
              this__.opaque = instance.split('=')[1].replace(pattern, '');
              rtsp_log.debug('RTSP opaque Info.:', JSON.stringify(this__.opaque));
            }

            if (instance.toLowerCase().indexOf('qop') >= 0) {
              var pattern = /[",]/g;
              this__.qop = instance.split('=')[1].replace(pattern, '');
              rtsp_log.debug('RTSP qop Info.:', JSON.stringify(this__.qop));
            }

            if (instance.toLowerCase().indexOf('algorithm') >= 0) {
              var pattern = /[",]/g;
              this__.algorithm = instance.split('=')[1].replace(pattern, '');
              rtsp_log.debug('RTSP qop Info.:', JSON.stringify(this__.algorithm));
            }
          });
        }

        // parser date
        if (entry.toLowerCase().indexOf("date:") >= 0) {
          this_.date = new Date(entry.split(': ')[1]);
          rtsp_log.debug('RTSP date Info.:', this_.date);
        }

        // parser date
        if (entry.toLowerCase().indexOf("public:") >= 0) {
          var pattern = /[ ]/g;
          var temp = entry.split(': ')[1].replace(pattern, '');
          this_.control_messages = temp.split(',');
          rtsp_log.debug('RTSP public Info.:', JSON.stringify(this_.control_messages));
        }

      });
    },
    onOptionMessage: function (message) {

    },
    onDescribeMessage: function (message) {

    },
    onSetupMessage: function (message) {

    },
  };

  /**
   * This property is to return the interleaved channel number of Session.
   * @property interleaved channel number
   * @memberof Session
   * @example
   *     Session.CSeq = 0;
   */
  Object.defineProperty(this, "CSeq", {
    get: function () {
      return sequence_number_;
    },
    set: function (v) {
      sequence_number_ = v;
    },
  });

  /**
   * This property is to return the interleaved channel number of RTSP.
   * @property interleaved channel number
   * @memberof Session
   * @example
   *     Session.CSeq = 0;
   */
  Object.defineProperty(this, "status", {
    get: function () {
      return status_;
    },
    set: function (v) {
      status_ = v;
    },
  });

  /**
   * This property is to return the interleaved channel number of RTSP.
   * @property RTSP Version information
   * @memberof RTSP
   * @example
   *     var string = 'RTSP/1.0 200 OK';
   *     var rtsp = new RTSP();
   *     rtsp.init();
   *     rtsp.rtspParser(string);
   *     var version = rtsp.version;
   */
  Object.defineProperty(this, "version", {
    get: function () {
      return version_;
    },
    set: function (v) {
      version_ = v;
    },
  });

  /**
   * This property is to return the interleaved channel number of RTSP.
   * @property RTSP Auth Scheme information
   * @memberof RTSP
   * @example
   *     var string = 'RTSP/1.0 200 OK';
   *     var rtsp = new RTSP();
   *     rtsp.init();
   *     rtsp.rtspParser(string);
   *     var version = rtsp.version;
   */
  Object.defineProperty(this, "auth", {
    get: function () {
      return auth_;
    },
    set: function (v) {
      auth_ = v;
    },
  });

  /**
   * This property is to return the interleaved channel number of RTSP.
   * @property RTSP Auth Scheme information
   * @memberof RTSP
   * @example
   *     var string = 'RTSP/1.0 200 OK';
   *     var rtsp = new RTSP();
   *     rtsp.init();
   *     rtsp.rtspParser(string);
   *     var version = rtsp.version;
   */
  Object.defineProperty(this, "realm", {
    get: function () {
      return realm_;
    },
    set: function (v) {
      realm_ = v;
    },
  });

  /**
   * This property is to return the interleaved channel number of RTSP.
   * @property RTSP Auth Scheme information
   * @memberof RTSP
   * @example
   *     var string = 'RTSP/1.0 200 OK';
   *     var rtsp = new RTSP();
   *     rtsp.init();
   *     rtsp.rtspParser(string);
   *     var version = rtsp.version;
   */
  Object.defineProperty(this, "nonce", {
    get: function () {
      return nonce_;
    },
    set: function (v) {
      nonce_ = v;
    },
  });

  /**
   * This property is to return the interleaved channel number of RTSP.
   * @property RTSP Auth Scheme information
   * @memberof RTSP
   * @example
   *     var string = 'RTSP/1.0 200 OK';
   *     var rtsp = new RTSP();
   *     rtsp.init();
   *     rtsp.rtspParser(string);
   *     var version = rtsp.version;
   */
  Object.defineProperty(this, "date", {
    get: function () {
      return date_;
    },
    set: function (v) {
      date_ = v;
    },
  });

  /**
   * This property is to return the interleaved channel number of RTSP.
   * @property RTSP Auth Scheme information
   * @memberof RTSP
   * @example
   *     var string = 'RTSP/1.0 200 OK';
   *     var rtsp = new RTSP();
   *     rtsp.init();
   *     rtsp.rtspParser(string);
   *     var version = rtsp.version;
   */
  Object.defineProperty(this, "control_messages", {
    get: function () {
      return control_messages_;
    },
    set: function (v) {
      control_messages_ = v;
    },
  });
  return new Constructor();
}
var RtspClient = function (mediaRouter) {
  "use strict";
  var _version = '1.0.0';
  var rtspclient_log = log4javascript.getLogger('rtsp');

  var module = {};
  var rtspUrl;
  var id;
  var pw;
  var userAgent;
  var wsUrl;
  var audioOutStatus = 'off';
  var checkAliveCommand = 'GET_PARAMETER';
  var Authentication = '';
  var SDPinfo = [];
  var transport;
  var digestGenerator = new DigestGenerator();
  var CSeq = 1;
  var sunapiClient;
  var isConnected = false;
  var aliveCounter = 0;

  var errorCallbackFunc,
      statusCallbackFunc;

  var currentState,
      nextState,
      setupSDPIndex,
      SessionId = null,
      mode = '',
      rangeClock,
      scale,
      deviceType,
      flag = true,
      audioTalkServiceStatus = false,
      getParameterIntervalHandler = null,
      checkAliveIntervalHandler = null,
      isRTPRunning = false,
      isPausing = false,
      checkRtspAlive = false,
      isGetParameterRequest = false;

  var rtsp = new RTSP();
  var rtspSDPData = {};
  var AACCodecInfo = {};
  var rtpClient = new RtpClient(mediaRouter);

  var version = function () {
    return _version;
  };

  var CommandConstructor = function (method, requestURL, extHeader) {
    var sendMessage = '';
    var AudioBackChannel = 'Require: www.onvif.org/ver20/backchannel\r\n';
    var UserAgentField = 'User-Agent: ' + userAgent + '\r\n';

    switch (method) {
      case 'OPTIONS':
      case 'TEARDOWN':
      case 'GET_PARAMETER':
      case 'SET_PARAMETERS':
        sendMessage = method + ' ' + rtspUrl + ' RTSP/1.0\r\nCSeq: ' + CSeq + '\r\n' + Authentication + UserAgentField + '\r\n';
        break;
      case 'DESCRIBE':
        if (audioOutStatus == 'on') {
          sendMessage = method + ' ' + rtspUrl + ' RTSP/1.0\r\nCSeq: ' + CSeq + '\r\n' + Authentication + AudioBackChannel + UserAgentField + '\r\n';
        } else {
          sendMessage = method + ' ' + rtspUrl + ' RTSP/1.0\r\nCSeq: ' + CSeq + '\r\n' + Authentication + UserAgentField + '\r\n';
        }
        break;
      case 'SETUP':
        if (requestURL.toLowerCase().indexOf("rtsp:") !== -1) {
          sendMessage = method + ' ' + requestURL + ' RTSP/1.0\r\nCSeq: ' + CSeq + '\r\n' + Authentication + UserAgentField;
        } else {
          if (rtspSDPData.ContentBase !== undefined) {
            sendMessage = method + ' ' + rtspSDPData.ContentBase + requestURL + ' RTSP/1.0\r\nCSeq: ' + CSeq + '\r\n' + Authentication + UserAgentField;
          } else {
            sendMessage = method + ' ' + rtspUrl + '/' + requestURL + ' RTSP/1.0\r\nCSeq: ' + CSeq + '\r\n' + Authentication + UserAgentField;
          }
        }

        if (extHeader) {
          sendMessage += extHeader;
        }
        sendMessage += '\r\n';
        break;
      case 'PLAY':
        if (requestURL) {
          sendMessage = method + ' ' + requestURL + ' RTSP/1.0\r\n';
          rtspUrl = requestURL;
        } else {
          sendMessage = method + ' ' + rtspUrl + ' RTSP/1.0\r\n';
        }
        sendMessage += 'CSeq: ' + CSeq + '\r\n' + 'Session: ' + SessionId + '\r\n';
        sendMessage += UserAgentField;
        if (mode === 'playback' || mode === 'backup') {
          if(deviceType === 'camera') {
            sendMessage += 'Require: samsung-replay-timezone' + '\r\n';
          } else {
            sendMessage += 'Require: onvif-replay' + '\r\n';
          }
        }

        if (extHeader) {
          sendMessage += extHeader;
        }

        sendMessage += '\r\n';
        break;
      case 'PAUSE':
        if (requestURL) {
          sendMessage = method + ' ' + requestURL + ' RTSP/1.0\r\n';
          rtspUrl = requestURL;
        } else {
          sendMessage = method + ' ' + rtspUrl + ' RTSP/1.0\r\n';
        }
        sendMessage += 'CSeq: ' + CSeq + '\r\n' + 'Session: ' + SessionId + '\r\n';
        sendMessage += UserAgentField;

        if (extHeader) {
          sendMessage += extHeader;
        }

        sendMessage += '\r\n';
        break;
      default:
        break;
    }

    rtspclient_log.debug("RTSP Send [Channel " + mediaRouter.getChannel() + "]: " + sendMessage);

    return sendMessage;
  };

  module.parseDescribeResponse = function (message1) {
    var SDPData = {};
    var Sessions = [];
    SDPData.Sessions = Sessions;
    var message;

    if (message1.search("Content-Type: application/sdp") !== -1) {
      var messageTok = message1.split("\r\n\r\n");
      message = messageTok[1];
    } else {
      message = message1;
    }

    var TokenziedDescribe = message.split("\r\n");
    var cnt;
    var mediaFound = false;
    for (cnt = 0; cnt < TokenziedDescribe.length; cnt++) {
      var SDPLineTokens = TokenziedDescribe[cnt].split("=");
      if (SDPLineTokens.length > 0) {
        switch (SDPLineTokens[0]) {
          case 'a':
            var aLineToken = SDPLineTokens[1].split(":");
            if (aLineToken.length > 1) {
              if (aLineToken[0] == "control") {
                var pos = TokenziedDescribe[cnt].search("control:");
                if (mediaFound == true) {
                  if (pos !== -1) {
                    SDPData.Sessions[SDPData.Sessions.length - 1].ControlURL = TokenziedDescribe[cnt].substr(pos + 8);
                  }
                } else {
                  if (pos !== -1) {
                    SDPData.BaseURL = TokenziedDescribe[cnt].substr(pos + 8);
                  }
                }
              } else if (aLineToken[0] == "rtpmap") {
                var rtpmapLine = aLineToken[1].split(" ");
                SDPData.Sessions[SDPData.Sessions.length - 1].PayloadType = rtpmapLine[0];

                var MimeLine = rtpmapLine[1].split("/");
                SDPData.Sessions[SDPData.Sessions.length - 1].CodecMime = MimeLine[0];
                if (MimeLine.length > 1) {
                  SDPData.Sessions[SDPData.Sessions.length - 1].ClockFreq = MimeLine[1];
                }
              } else if (aLineToken[0] == "framesize") {
                var framesizeLine = aLineToken[1].split(" ");
                if (framesizeLine.length > 1) {
                  var framesizeinf = framesizeLine[1].split("-");
                  SDPData.Sessions[SDPData.Sessions.length - 1].Width = framesizeinf[0];
                  SDPData.Sessions[SDPData.Sessions.length - 1].Height = framesizeinf[1];
                }
              } else if (aLineToken[0] == "framerate") {
                SDPData.Sessions[SDPData.Sessions.length - 1].Framerate = aLineToken[1];
              } else if (aLineToken[0] == "fmtp") {

                var sessLine = TokenziedDescribe[cnt].split(" ");

                if (sessLine.length < 2)
                  continue;
                for (var ii = 1; ii < sessLine.length; ii++) {
                  var sessToken = sessLine[ii].split(";");
                  var sessprmcnt;
                  for (sessprmcnt = 0; sessprmcnt < sessToken.length; sessprmcnt++) {
                    var ppos = sessToken[sessprmcnt].search("mode=");
                    if (ppos !== -1) {
                      SDPData.Sessions[SDPData.Sessions.length - 1].mode = sessToken[sessprmcnt].substr(ppos + 5);
                    }

                    ppos = sessToken[sessprmcnt].search("config=");
                    if (ppos !== -1) {
                      SDPData.Sessions[SDPData.Sessions.length - 1].config = sessToken[sessprmcnt].substr(ppos + 7);
                      AACCodecInfo.config = SDPData.Sessions[SDPData.Sessions.length - 1].config;
                      AACCodecInfo.clockFreq = SDPData.Sessions[SDPData.Sessions.length - 1].ClockFreq;
                      AACCodecInfo.bitrate = SDPData.Sessions[SDPData.Sessions.length - 1].Bitrate;
                    }

                    ppos = sessToken[sessprmcnt].search("sprop-vps=");
                    if (ppos !== -1) {
                      SDPData.Sessions[SDPData.Sessions.length - 1].VPS = sessToken[sessprmcnt].substr(ppos + 10);
                    }

                    ppos = sessToken[sessprmcnt].search("sprop-sps=");
                    if (ppos !== -1) {
                      SDPData.Sessions[SDPData.Sessions.length - 1].SPS = sessToken[sessprmcnt].substr(ppos + 10);
                    }

                    ppos = sessToken[sessprmcnt].search("sprop-pps=");
                    if (ppos !== -1) {
                      SDPData.Sessions[SDPData.Sessions.length - 1].PPS = sessToken[sessprmcnt].substr(ppos + 10);
                    }

                    ppos = sessToken[sessprmcnt].search("sprop-parameter-sets=");
                    if (ppos !== -1) {
                      var SPSPPS = sessToken[sessprmcnt].substr(ppos + 21);
                      var SPSPPSTokenized = SPSPPS.split(",");
                      if (SPSPPSTokenized.length > 1) {
                        SDPData.Sessions[SDPData.Sessions.length - 1].SPS = SPSPPSTokenized[0];
                        SDPData.Sessions[SDPData.Sessions.length - 1].PPS = SPSPPSTokenized[1];
                      }
                    }

                  }
                }
              }

            }
            break;
          case 'm':
            var mLineToken = SDPLineTokens[1].split(" ");
            var Session = {};
            Session.Type = mLineToken[0];
            Session.Port = mLineToken[1];
            Session.Payload = mLineToken[3];
            SDPData.Sessions.push(Session);
            mediaFound = true;
            break;
          case 'b':
            if (mediaFound == true) {
              var bLineToken = SDPLineTokens[1].split(":");
              SDPData.Sessions[SDPData.Sessions.length - 1].Bitrate = bLineToken[1];
            }
            break;
        }
      }
    }
    return SDPData;
  };

  module.toStringExtensionScale = function (value) {
    var extraheader = "";
    if (typeof value === 'string') {
      extraheader += 'Scale: ' + value + '\r\n';
    } else {
      if (Number(value) === 0) {
        // default forward
        extraheader += 'Scale: ' + '+' + value.toFixed(1).toString() + '\r\n';
      } else {
        extraheader += 'Scale: ' + value.toFixed(1).toString() + '\r\n';
      }
    }
    return extraheader;
  };

  module.parseRtspResponse = function (message1) {
    var RtspResponseData = {};
    var cnt, cnt1, ttt, LineTokens;

    /*Handling only the RTSP Response and not SDP*/
    var message;
    if (message1.search("Content-Type: application/sdp") !== -1) {
      var messageTok = message1.split("\r\n\r\n");
      message = messageTok[0];
    } else {
      message = message1;
    }

    var TokenziedResponseLines = message.split("\r\n");

    var ResponseCodeTokens = TokenziedResponseLines[0].split(" ");
    if (ResponseCodeTokens.length > 2) {
      RtspResponseData.ResponseCode = parseInt(ResponseCodeTokens[1]);
      RtspResponseData.ResponseMessage = ResponseCodeTokens[2];
    }

    if (RtspResponseData.ResponseCode === 200) {
      for (cnt = 1; cnt < TokenziedResponseLines.length; cnt++) {
        LineTokens = TokenziedResponseLines[cnt].split(":");
        if (LineTokens[0] === "Public") {
          RtspResponseData.MethodsSupported = LineTokens[1].split(",");
        } else if (LineTokens[0] === "CSeq") {
          RtspResponseData.CSeq = parseInt(LineTokens[1]);
        } else if (LineTokens[0] === "Content-Type") {
          RtspResponseData.ContentType = LineTokens[1];
          if (RtspResponseData.ContentType.search("application/sdp") !== -1) {
            RtspResponseData.SDPData = this.parseDescribeResponse(message1);
          }
        } else if (LineTokens[0] === "Content-Length") {
          RtspResponseData.ContentLength = parseInt(LineTokens[1]);
        } else if (LineTokens[0] === "Content-Base") {
          var ppos = TokenziedResponseLines[cnt].search("Content-Base:");
          if (ppos !== -1) {
            RtspResponseData.ContentBase = TokenziedResponseLines[cnt].substr(ppos + 13);
          }
        } else if (LineTokens[0] === "Session") {
          var SessionTokens = LineTokens[1].split(";");
          RtspResponseData.SessionID = parseInt(SessionTokens[0]);
        } else if (LineTokens[0] === "Transport") {
          var TransportTokens = LineTokens[1].split(";");
          for (cnt1 = 0; cnt1 < TransportTokens.length; cnt1++) {
            var tpos = TransportTokens[cnt1].search("interleaved=");
            if (tpos !== -1) {
              var interleaved = TransportTokens[cnt1].substr(tpos + 12);
              var interleavedTokens = interleaved.split("-");
              if (interleavedTokens.length > 1) {
                RtspResponseData.RtpInterlevedID = parseInt(interleavedTokens[0]);
                RtspResponseData.RtcpInterlevedID = parseInt(interleavedTokens[1]);
              }
            }
          }
        } else if (LineTokens[0] === "RTP-Info") {
          LineTokens[1] = TokenziedResponseLines[cnt].substr(9);
          var RTPInfoTokens = LineTokens[1].split(",");
          RtspResponseData.RTPInfoList = [];
          for (cnt1 = 0; cnt1 < RTPInfoTokens.length; cnt1++) {
            var RtpTokens = RTPInfoTokens[cnt1].split(";");
            var RtpInfo = {};
            var cnt2;
            for (cnt2 = 0; cnt2 < RtpTokens.length; cnt2++) {
              var poss = RtpTokens[cnt2].search("url=");
              if (poss !== -1) {
                RtpInfo.URL = RtpTokens[cnt2].substr(poss + 4);
              }
              poss = RtpTokens[cnt2].search("seq=");
              if (poss !== -1) {
                RtpInfo.Seq = parseInt(RtpTokens[cnt2].substr(poss + 4));
              }

            }
            RtspResponseData.RTPInfoList.push(RtpInfo);
          }

        }

      }
    } else if (RtspResponseData.ResponseCode === 401) {
      for (cnt = 1; cnt < TokenziedResponseLines.length; cnt++) {
        LineTokens = TokenziedResponseLines[cnt].split(":");
        if (LineTokens[0] === "CSeq") {
          RtspResponseData.CSeq = parseInt(LineTokens[1]);
        } else if (LineTokens[0] === "WWW-Authenticate") {
          var AuthTokens = LineTokens[1].split(",");
          for (cnt1 = 0; cnt1 < AuthTokens.length; cnt1++) {
            var pos = AuthTokens[cnt1].search("Digest realm=");
            if (pos !== -1) {
              ttt = AuthTokens[cnt1].substr(pos + 13);
              var realmtok = ttt.split("\"");
              RtspResponseData.Realm = realmtok[1];
            }
            pos = AuthTokens[cnt1].search("nonce=");
            if (pos !== -1) {
              ttt = AuthTokens[cnt1].substr(pos + 6);
              var noncetok = ttt.split("\"");
              RtspResponseData.Nonce = noncetok[1];
            }
          }
        }
      }
    }

    return RtspResponseData;
  };

  var formDigestAuthHeader = function (stringMessage) {
    var wwwAuthenticate = stringMessage.slice(stringMessage.search("WWW-Authenticate"), stringMessage.length);
    var digestInfo = digestGenerator.getDigestInfoInWwwAuthenticate(wwwAuthenticate);
    var responseValue;
    var getData = {};

    getData.Method = currentState.toUpperCase();
    getData.Realm = digestInfo.realm;
    getData.Nonce = digestInfo.nonce;
    getData.Uri = encodeURIComponent(rtspUrl);

    if (pw !== undefined && pw !== null && (typeof pw === 'string' && pw !== ''))   {
      responseValue = digestGenerator.formulateResponse(id, pw, rtspUrl, getData.Realm, getData.Method, getData.Nonce);
      Authentication = 'Authorization:' + ' Digest ' + 'username="' + id + '", ' + 'realm="' + digestInfo.realm + '", ';
      Authentication += 'nonce="' + digestInfo.nonce + '", ' + 'uri="' + rtspUrl + '", ' + 'response="' + responseValue + '"\r\n';

      SendUnauthorizedRtspCmd();
    } else if (sunapiClient !== null && sunapiClient !== undefined) {
      sunapiClient.get('/stw-cgi/security.cgi?msubmenu=digestauth&action=view', getData,
        function (response) {
          if(deviceType === 'camera') {
              responseValue = response.data.Response;
          } else {
            if(response.data !== undefined) {
              responseValue = response.data.Response;
            } else {
              responseValue = response.Response;
            }
            // TODO: get from device using sunapi API
          }
          Authentication = 'Authorization:' + ' Digest ' + 'username="' + id + '", ' + 'realm="' + digestInfo.realm + '", ';
          Authentication += 'nonce="' + digestInfo.nonce + '", ' + 'uri="' + rtspUrl + '", ' + 'response="' + responseValue + '"\r\n';
          SendUnauthorizedRtspCmd();
        },
        function (errorData, errorCode) {
          rtspclient_log.error(errorData);
        }, '', true);
    } else {
      // TODO: exception without password and sunapiclient
      throw new umpError({
        channelId: mediaRouter.getChannel(),
        errorCode: fromHex('0x0403'),
        place: 'rtspClient.js:404',
        message: 'The sunapi client & password is not exist. If you want to connect deivce, you have to put the user password or sunapi client for device connect'
      });
    }
  };

  var SendUnauthorizedRtspCmd = function () {
    var extraheader = '';
    if (currentState === 'Options') {
      transport.SendRtspCommand(CommandConstructor('OPTIONS', null, null));
    } else if (currentState === 'Describe') {
      transport.SendRtspCommand(CommandConstructor('DESCRIBE', null, null));
    } else if (currentState === 'Setup') {
      extraheader = 'Transport: RTP/AVP/TCP;unicast;interleaved=' + (2 * setupSDPIndex).toString() + '-' + ((2 * setupSDPIndex) + 1).toString() + '\r\n';
      transport.SendRtspCommand(CommandConstructor('SETUP', SDPinfo[setupSDPIndex].trackID, extraheader));
    } else if (currentState === 'Play') {
      if (mode === 'playback') {
        extraheader = 'Immediate: yes' + '\r\n' + 'Scale: ' + '1.000000' + '\r\n' + 'Range: npt=0.000-' + '\r\n' + 'Rate-Control: yes' + '\r\n';
      } else if (mode === 'backup') {
        /*download mode*/
        extraheader += 'Rate-Control: no' + '\r\n';
      }
      transport.SendRtspCommand(CommandConstructor('PLAY', null, extraheader));
      isPausing = false;
    } else if (currentState === 'Pause') {
      transport.SendRtspCommand(CommandConstructor('PAUSE', null, null));
      isPausing = true;
    } else if (currentState === 'Teardown') {
      transport.SendRtspCommand(CommandConstructor('TEARDOWN', null, null));
    }
  };

  var checkIsAvaliablePlayback = function (mode) {
    var playbackAliveCount = 0;
    if (mode === 'backup' || mode === 'playback') {
      if (checkAliveIntervalHandler === null) {
        checkAliveIntervalHandler = setInterval(function () {
          if (!isRTPRunning) {
            if (playbackAliveCount > 3) {
              clearInterval(checkAliveIntervalHandler);
              checkAliveIntervalHandler = null;
              errorCallbackFunc({
                errorCode: fromHex('0x0601'),
                oldErrorCode: "990",
                description: "end of backup",
                place: "RtspClient.js:473",
                channelId: mediaRouter.getChannel()
              });
//              rtspclient_log.error("RTP disconnection detect from checkIsAvaliablePlayback");
              return;
            }
            playbackAliveCount++;
          } else {
            playbackAliveCount = 0;
          }
          isRTPRunning = false;
        }, 1000);
      }
    }
  };

  function getParameterIntervalHandlerFunc() {
    return setInterval(function () {
        if (transport) {
          transport.SendRtspCommand(CommandConstructor(checkAliveCommand, null, null));
          isGetParameterRequest = true;
        }
      }, 10000);
  }

  function checkAliveIntervalHandlerFunc() {
    return setInterval(function () {
      rtspclient_log.debug("RTP running = ", isRTPRunning, ", alive counter = ", aliveCounter);
      if (!isRTPRunning) {
        if (aliveCounter > 6) {
          clearInterval(checkAliveIntervalHandler);
          clearInterval(getParameterIntervalHandler);
          checkAliveIntervalHandler = null;
          getParameterIntervalHandler = null;

          if (isConnected) {
            try {
              transport.SendRtspCommand(CommandConstructor(checkAliveCommand, null, null));
              checkRtspAlive = true;

              setTimeout(function() {
                if (checkRtspAlive) {
                  checkRtspAlive = false;
                  errorCallbackFunc({
                    errorCode: fromHex('0x0209'),
                    oldErrorCode: "999",
                    description: "no rtsp response",
                    place: "RtspClient.js:515",
                    channelId: mediaRouter.getChannel()
                  });
                }
              }, 5000);
            } catch (e) {
              errorCallbackFunc({
                errorCode: fromHex('0x0209'),
                oldErrorCode: "999",
                description: "no rtsp response",
                place: "RtspClient.js:525",
                channelId: mediaRouter.getChannel()
              });
            }
          } else {
            errorCallbackFunc({
              errorCode: fromHex('0x0006'),
              type: 'rtsp',
              description: "tranport is not exist",
              place: "RtspClient.js:534",
              channelId: mediaRouter.getChannel()
            });
          }

          //rtspclient_log.error("RTP disconnection detect from checkAliveIntervalHandlerFunc, channel: " + mediaRouter.getChannel());
          return;
        }
        aliveCounter++;
      }

      if(!module.instantplayback) {
       if(isPausing || mode === "live") {
          isRTPRunning = false;
        }
      }
    }, 1000);
  }

  module.RtspResponseHandler = function (stringMessage) {
    var rtspResponseMsg = {},
         extraheader = '',
         status;

    rtsp.rtspParser(stringMessage);
    rtspclient_log.debug("RTSP Version", rtsp.version, "RTSP Status:", rtsp.status.toString(), "RTSP CSeq:", rtsp.CSeq);

    var seekPoint = stringMessage.search('CSeq: ') + 5;
    CSeq = parseInt(stringMessage.slice(seekPoint, seekPoint + 10)) + 1;

    rtspclient_log.debug("RTSP Recv [Channel " + mediaRouter.getChannel() + "]: " + stringMessage);

    rtspResponseMsg = module.parseRtspResponse(stringMessage);

    if (checkRtspAlive) {
      checkRtspAlive = false;
      if (rtspResponseMsg.ResponseCode === 200) {
        getParameterIntervalHandler = getParameterIntervalHandlerFunc();
        checkAliveIntervalHandler = checkAliveIntervalHandlerFunc();
      } else {
        errorCallbackFunc({
          errorCode: fromHex('0x0209'),
          oldErrorCode: "999",
          description: "no rtsp response",
          place: "RtspClient.js:572",
          channelId: mediaRouter.getChannel()
        });
      }
    }

    if (rtspResponseMsg.ResponseCode === 401/* && Authentication === ''*/) {
      /*unauthorized*/
      formDigestAuthHeader(stringMessage);
    } else if (rtspResponseMsg.ResponseCode === 200) {
      if (currentState === 'Options') {
        currentState = 'Describe';
        transport.SendRtspCommand(CommandConstructor('DESCRIBE', null, null));
        nextState = 'Setup';
      } else if (currentState === 'Describe') {
        /*Parse Describe Response*/
        audioTalkServiceStatus = false;
        rtspSDPData = module.parseDescribeResponse(stringMessage);
        if (rtspResponseMsg.ContentBase !== undefined) {
          rtspSDPData.ContentBase = rtspResponseMsg.ContentBase;
        }

        var idx = 0;
        var sessionIndex;
        for (idx = 0; idx < rtspSDPData.Sessions.length; idx = idx + 1) {
          var sdpInfoObj = {};
          if (rtspSDPData.Sessions[idx].CodecMime === 'JPEG' ||
              rtspSDPData.Sessions[idx].CodecMime === 'H264' ||
              rtspSDPData.Sessions[idx].CodecMime === 'H265'/* ||
        rtspSDPData.Sessions[idx].CodecMime === 'MP4V-ES'*/) {
            sdpInfoObj.codecName = rtspSDPData.Sessions[idx].CodecMime;
            sdpInfoObj.trackID = rtspSDPData.Sessions[idx].ControlURL;
            sdpInfoObj.ClockFreq = rtspSDPData.Sessions[idx].ClockFreq;
            sdpInfoObj.Port = parseInt(rtspSDPData.Sessions[idx].Port);
            if (rtspSDPData.Sessions[idx].Framerate !== undefined) {
              sdpInfoObj.Framerate = parseInt(rtspSDPData.Sessions[idx].Framerate);
            }
            SDPinfo.push(sdpInfoObj);
          } else if (rtspSDPData.Sessions[idx].CodecMime === 'PCMU' ||
            rtspSDPData.Sessions[idx].CodecMime.search('G726-16') !== -1 ||
            rtspSDPData.Sessions[idx].CodecMime.search('G726-24') !== -1 ||
            rtspSDPData.Sessions[idx].CodecMime.search('G726-32') !== -1 ||
            rtspSDPData.Sessions[idx].CodecMime.search('G726-40') !== -1) {
            if (rtspSDPData.Sessions[idx].ControlURL.search('trackID=t') !== -1 ||
                rtspSDPData.Sessions[idx].ControlURL.search('trackID=back') !== -1) {
              sdpInfoObj.codecName = 'G.711';
              sdpInfoObj.trackID = rtspSDPData.Sessions[idx].ControlURL;
              sdpInfoObj.Port = parseInt(rtspSDPData.Sessions[idx].Port);
              sdpInfoObj.Bitrate = parseInt(rtspSDPData.Sessions[idx].Bitrate);
              SDPinfo.push(sdpInfoObj);
              audioTalkServiceStatus = true;
            } else {
              if (rtspSDPData.Sessions[idx].CodecMime === 'PCMU') {
                sdpInfoObj.codecName = 'G.711';
              } else if (rtspSDPData.Sessions[idx].CodecMime === 'G726-16') {
                sdpInfoObj.codecName = 'G.726-16';
              } else if (rtspSDPData.Sessions[idx].CodecMime === 'G726-24') {
                sdpInfoObj.codecName = 'G.726-24';
              } else if (rtspSDPData.Sessions[idx].CodecMime === 'G726-32') {
                sdpInfoObj.codecName = 'G.726-32';
              } else if (rtspSDPData.Sessions[idx].CodecMime === 'G726-40') {
                sdpInfoObj.codecName = 'G.726-40';
              }
              sdpInfoObj.trackID = rtspSDPData.Sessions[idx].ControlURL;
              sdpInfoObj.ClockFreq = rtspSDPData.Sessions[idx].ClockFreq;
              sdpInfoObj.Port = parseInt(rtspSDPData.Sessions[idx].Port);
              sdpInfoObj.Bitrate = parseInt(rtspSDPData.Sessions[idx].Bitrate);
              SDPinfo.push(sdpInfoObj);
            }
          } else if (rtspSDPData.Sessions[idx].CodecMime === 'mpeg4-generic') {
            sdpInfoObj.codecName = 'mpeg4-generic';
            sdpInfoObj.trackID = rtspSDPData.Sessions[idx].ControlURL;
            sdpInfoObj.ClockFreq = rtspSDPData.Sessions[idx].ClockFreq;
            sdpInfoObj.Port = parseInt(rtspSDPData.Sessions[idx].Port);
            sdpInfoObj.Bitrate = parseInt(rtspSDPData.Sessions[idx].Bitrate);
            sdpInfoObj.config = rtspSDPData.Sessions[idx].config;
            SDPinfo.push(sdpInfoObj);
          } else if (rtspSDPData.Sessions[idx].CodecMime === 'vnd.onvif.metadata') {
            sdpInfoObj.codecName = 'MetaData';
            sdpInfoObj.trackID = rtspSDPData.Sessions[idx].ControlURL;
            sdpInfoObj.ClockFreq = rtspSDPData.Sessions[idx].ClockFreq;
            sdpInfoObj.Port = parseInt(rtspSDPData.Sessions[idx].Port);

            SDPinfo.push(sdpInfoObj);
          } else {
            rtspclient_log.debug("Unknown codec type:", rtspSDPData.Sessions[idx].CodecMime, rtspSDPData.Sessions[idx].ControlURL);
            errorCallbackFunc({
              errorCode: fromHex('0x0300'),
              description: "Unknown codec type:" + rtspSDPData.Sessions[idx].CodecMime +
                                ", Control URL:" + rtspSDPData.Sessions[idx].ControlURL,
              place: "RtspClient.js:661",
              channelId: mediaRouter.getChannel()
            });
          }
        }
        setupSDPIndex = 0;
        currentState = 'Setup';
        extraheader = 'Transport: RTP/AVP/TCP;unicast;interleaved=' + (2 * setupSDPIndex).toString() + '-' + ((2 * setupSDPIndex) + 1).toString() + '\r\n';
        transport.SendRtspCommand(CommandConstructor('SETUP', SDPinfo[setupSDPIndex].trackID, extraheader));
        nextState = (SDPinfo.length > 1) ? 'Setup' : 'Play';

      } else if (currentState === 'Setup') {
        if (setupSDPIndex < SDPinfo.length) {
          SDPinfo[setupSDPIndex].RtpInterlevedID = rtspResponseMsg.RtpInterlevedID;
          SDPinfo[setupSDPIndex].RtcpInterlevedID = rtspResponseMsg.RtcpInterlevedID;

          SessionId = rtspResponseMsg.SessionID;
          setupSDPIndex += 1;
          if (setupSDPIndex !== SDPinfo.length) {
            extraheader = 'Transport: RTP/AVP/TCP;unicast;interleaved=' + (2 * setupSDPIndex).toString() + '-' + ((2 * setupSDPIndex) + 1).toString() + '\r\n';
            transport.SendRtspCommand(CommandConstructor('SETUP', SDPinfo[setupSDPIndex].trackID, extraheader));
          } else {
            rtpClient.sendSdpInfo(SDPinfo);
            if (audioTalkServiceStatus) {
              rtpClient.addListener('audioTalk', module.SendAudioTalkData);
            }
            currentState = 'Play';
            if (mode === 'playback') {
              extraheader = 'Immediate: yes' + '\r\n'; // + 'Rate-Control: yes' + '\r\n';
              //extraheader = 'Immediate: yes' + '\r\n' + 'Scale: ' + '+0.0' + '\r\n' + 'Rate-Control: yes' + '\r\n';

              if(deviceType === 'camera') {
                extraheader += 'Scale: ' + '1.000000' + '\r\n';
              } else {
                extraheader += module.toStringExtensionScale(scale);
              }

              if(typeof rangeClock !== 'undefined' ) {
                extraheader += 'Range: clock=' + rangeClock;
                if( rangeClock.search("-") === -1) {
                  extraheader += '-';
                }
                extraheader += '\r\n';
              } else {
                extraheader += 'Range: npt=0.000-\r\n';
              }
            } else if (mode === 'backup') {
              extraheader += 'Rate-Control: no' + '\r\n';
            }
            transport.SendRtspCommand(CommandConstructor('PLAY', null, extraheader));
            nextState = 'Playing';
            if (mode === 'backup') {
              setTimeout(function () {
                checkIsAvaliablePlayback(mode);
              }, 1000);
            }
          }
        } else {
          rtspclient_log.debug("Unknown setup SDP index", SDPinfo);
        }
      } else if (currentState === 'Play') {
        // console.log("RTSP player respose: ");
        // console.log(rtspResponseMsg);
        status = new RtspStatusCode(rtspResponseMsg.ResponseCode);

        SessionId = rtspResponseMsg.SessionID;
        errorCallbackFunc({
          errorCode: fromHex('0x0000'),
          currentState: currentState,
          oldErrorCode: "200",
          rtspCode: status.getStatusCode(),
          description: "RTSP Play Streaming: " + status.getStatusCode() +
                            ", error message: " + status.getDescription(),
          name: status.getName(),
          place: "RtspClient.js:730",
          channelId: mediaRouter.getChannel()
        });

        /*for maintain rtsp connection*/
        getParameterIntervalHandler = getParameterIntervalHandlerFunc();

        if (mode === 'live') {
          checkAliveIntervalHandler = checkAliveIntervalHandlerFunc();
        } else if (mode === 'backup') {
          checkIsAvaliablePlayback(mode);
        }
        // else if( mode === 'playback' ) {
        //   setTimeout(function(){
        //     checkIsAvaliablePlayback(mode);
        //   }, 1000);
        // }

        currentState = 'Playing';
        rtspclient_log.debug("Current State: " + currentState + ", Pausing: " + isPausing + ", RTPRunning: " + isRTPRunning + ", instant playback = " + module.instantplayback)
      } else if (currentState === 'Playing') {
        /*for live GET_PARAMETER rtsp response comes here*/
        if(isPausing && isRTPRunning) {
          currentState = 'Pause';
          // errorCallbackFunc({
          //   errorCode: "200",
          //   currentState: currentState,
          //   pause: isPausing,
          //   description: "Pause Streaming",
          //   place: "RtspClient.js:758",
          //   channelId: mediaRouter.getChannel()
          // });

          status = new RtspStatusCode(rtspResponseMsg.ResponseCode);
          SessionId = rtspResponseMsg.SessionID;
          errorCallbackFunc({
            errorCode: fromHex('0x0000'),
            oldErrorCode: "200",
            currentState: currentState,
            pause: isPausing,
            rtspCode: status.getStatusCode(),
            description: "RTSP Pause Streaming: " + status.getStatusCode() +
                              ", error message: " + status.getDescription(),
            name: status.getName(),
            place: "RtspClient.js:773",
            channelId: mediaRouter.getChannel()
          });
        } else if (mode === 'playback') {
          if ( !isGetParameterRequest ) {
            status = new RtspStatusCode(rtspResponseMsg.ResponseCode);
            SessionId = rtspResponseMsg.SessionID;
            errorCallbackFunc({
              errorCode: fromHex('0x0000'),
              oldErrorCode: "200",
              currentState: currentState,
              pause: isPausing,
              rtspCode: status.getStatusCode(),
              description: "RTSP Seek Streaming: " + status.getStatusCode() +
                                ", error message: " + status.getDescription(),
              name: status.getName(),
              place: "RtspClient.js:790",
              channelId: mediaRouter.getChannel()
            });
          }
        }

        rtspclient_log.info("Current State: " + currentState + ", Pausing: " + isPausing + ", RTPRunning: " + isRTPRunning)
      } else if (currentState === 'Pause') {
        if(!isPausing && isRTPRunning) {
          currentState = 'Playing';
          // errorCallbackFunc({
          //   errorCode: "200",
          //   currentState: 'Resume',
          //   pause: isPausing,
          //   description: "Resume Streaming",
          //   place: "RtspClient.js:786",
          //   channelId: mediaRouter.getChannel()
          // });

          status = new RtspStatusCode(rtspResponseMsg.ResponseCode);
          SessionId = rtspResponseMsg.SessionID;
          errorCallbackFunc({
            errorCode: fromHex('0x0000'),
            oldErrorCode: "200",
            currentState: 'Resume',
            pause: isPausing,
            rtspCode: status.getStatusCode(),
            description: "RTSP Resume Streaming: " + status.getStatusCode() +
                              ", error message: " + status.getDescription(),
            name: status.getName(),
            place: "RtspClient.js:801",
            channelId: mediaRouter.getChannel()
          });

        }
        rtspclient_log.debug("Current State: " + currentState + ", Pausing: " + isPausing + ", RTPRunning: " + isRTPRunning + ", instant playback = " + module.instantplayback);
      } else {
        rtspclient_log.error("unknown rtsp state:", currentState);
      }
      if ( isGetParameterRequest ) {
        isGetParameterRequest = false;
      }
    } else if (rtspResponseMsg.ResponseCode === 503) {
      if (currentState === 'Setup' &&
         (SDPinfo[setupSDPIndex].trackID.search('trackID=t') !== -1 ||
          SDPinfo[setupSDPIndex].trackID.search('trackID=back') !== -1)) {

        SDPinfo[setupSDPIndex].RtpInterlevedID = -1;
        SDPinfo[setupSDPIndex].RtcpInterlevedID = -1;

        /*skip the sesson*/
        setupSDPIndex += 1;
        audioTalkServiceStatus = false;

        errorCallbackFunc({
          errorCode: fromHex('0x020A'),
          oldErrorCode: "504",
          description: "Talk Service Unavilable",
          place: "RtspClient.js:824",
          channelId: mediaRouter.getChannel()
        });

        if (setupSDPIndex < SDPinfo.length) {
          extraheader = 'Transport: RTP/AVP/TCP;unicast;interleaved=' + (2 * setupSDPIndex).toString() + '-' + ((2 * setupSDPIndex) + 1).toString() + '\r\n';
          transport.SendRtspCommand(CommandConstructor('SETUP', SDPinfo[setupSDPIndex].trackID, extraheader));
        } else {
          currentState = 'Play';
          if (mode === 'playback') {
            extraheader = 'Immediate: yes' + '\r\n' + 'Rate-Control: yes' + '\r\n';

            if(deviceType === 'camera') {
              extraheader += 'Scale: ' + '1.000000' + '\r\n';
            } else {
              extraheader += this.toStringExtensionScale(scale);
            }

            if(typeof rangeClock !== 'undefined') {
              extraheader += 'Range: clock=' + rangeClock;
              if( rangeClock.search("-") === -1) {
                extraheader += '-';
              }
              extraheader += '\r\n';
            } else {
              extraheader += 'Range: npt=0.000-\r\n';
            }
          }
          transport.SendRtspCommand(CommandConstructor('PLAY', null, extraheader));
          nextState = 'Playing';
        }
      } else {
        rtspclient_log.debug("2nd unknown rtsp state:", currentState);
        status = new RtspStatusCode(rtspResponseMsg.ResponseCode);
        errorCallbackFunc({
          errorCode: fromHex('0x0201'),
          oldErrorCode: "503",
          rtspCode: status.getStatusCode(),
          description: "RTSP error code: " + status.getStatusCode() +
                            ", error message: " + status.getDescription(),
          name: status.getName(),
          place: "RtspClient.js:861",
          channelId: mediaRouter.getChannel()
        });
      }
    } else  if (rtspResponseMsg.ResponseCode === 560) {
      status = new RtspStatusCode(rtspResponseMsg.ResponseCode);
      errorCallbackFunc({
        errorCode: fromHex('0x0204'),
        rtspCode: status.getStatusCode(),
        description: "RTSP error code: " + status.getStatusCode() +
                          ", error message: " + status.getDescription(),
        name: status.getName(),
        place: "RtspClient.js:873",
        channelId: mediaRouter.getChannel()
      });
    } else if (rtspResponseMsg.ResponseCode === 404) {
      if (currentState === 'Options') {
        status = new RtspStatusCode(rtspResponseMsg.ResponseCode);
        errorCallbackFunc({
          errorCode: fromHex('0x0205'),
          oldErrorCode: "404",
          rtspCode: status.getStatusCode(),
          description: "RTSP error code: " + status.getStatusCode() +
                            ", error message: " + status.getDescription(),
          name: status.getName(),
          place: "RtspClient.js:886",
          channelId: mediaRouter.getChannel()
        });
        return;
      }
    } else if (rtspResponseMsg.ResponseCode === 490) {
      if (currentState === 'Options') {
        status = new RtspStatusCode(rtspResponseMsg.ResponseCode);
        errorCallbackFunc({
          errorCode: fromHex('0x020B'),
          oldErrorCode: "490",
          rtspCode: status.getStatusCode(),
          description: "RTSP error code: " + status.getStatusCode() +
                            ", error message: " + status.getDescription(),
          name: status.getName(),
          place: "RtspClient.js:901",
          channelId: mediaRouter.getChannel()
        });
        return;
      }
    } else {
      rtspclient_log.warn("RTSP Response: ", JSON.stringify(rtspResponseMsg));
      status = new RtspStatusCode(rtspResponseMsg.ResponseCode);
      errorCallbackFunc({
          errorCode: fromHex('0x0203'),
          rtspCode: status.getStatusCode(),
          description: "RTSP error code: " + status.getStatusCode() +
                            ", error message: " + status.getDescription(),
          name: status.getName(),
          place: "RtspClient.js:915",
          channelId: mediaRouter.getChannel()
        });
    }
  };

  module.RtpDataHandler = function (rtspinterleave, rtpheader, rtpPacketArray) {
    rtpClient.sendRtpData(rtspinterleave, rtpheader, rtpPacketArray);
    isRTPRunning = true;
    // if aliveCounter is not zero, reinitialized
    if(aliveCounter !== 0) {
      aliveCounter = 0;
    }
  };

  module.SendAudioTalkData = function (rtpdata) {
    if (transport && audioTalkServiceStatus && audioOutStatus === 'on') {
      transport.SendRtpData(rtpdata);
    }
  };

  module.connectionCbFunc = function (type, statusObject) {
    if (type === 'open') {
      CSeq = 1;
      currentState = 'Options';
      nextState = 'Describe';
      transport.SendRtspCommand(CommandConstructor('OPTIONS', null, null));
    } else if (type === 'error') {
      rtspclient_log.debug("connection error" + JSON.stringify(statusObject.getObject()));
      if (statusObject.getStatusCode() === '999') {
        // websocket disconnet
      } else if (mode === 'backup') {
        errorCallbackFunc({
          errorCode: fromHex('0x0602'),
          oldErrorCode: -5,
          description: "backup has error",
          place: "RtspClient.js:996",
          channelId: mediaRouter.getChannel()
        });
      } else {
        errorCallbackFunc({
          //errorCode: statusObject.getStatusCode(),
          errorCode: fromHex('0x0003'),
          description: 'websocket disconnected error: status code (' + statusObject.getStatusCode() + '), Message: ' + statusObject.getDescription(),
          place: "RtspClient.js:1004",
          channelId: mediaRouter.getChannel()
        });
        transport.Disconnect();
      }
      currentState = "Options";
      nextState = 'Describe';
      CSeq = 1;
    } else if (type === 'close') {
      currentState = 'Teardown';
      transport = null;
      errorCallbackFunc({
        errorCode: fromHex('0x0001'),
        description: 'websocket closed: status code (' + statusObject.getStatusCode() + '), Message: ' + statusObject.getDescription(),
        place: "RtspClient.js:962",
        channelId: mediaRouter.getChannel()
      });
    }
  };

  module.SetErrorCallback = function (callbackFunc) {
    errorCallbackFunc = callbackFunc;
  };

  module.addEventListener = function (event, callbackFunc) {
    switch(event) {
      case 'error':
        if(typeof callbackFunc !== 'undefined') {
          errorCallbackFunc = callbackFunc;
        }
      break;
      case 'status':
        if(typeof callbackFunc !== 'undefined') {
          statusCallbackFunc = callbackFunc;
        }
      break;
      default:
      rtspclient_log.error("undefined callback function");
      break;
    }
  };

  module.SetSunapiClient = function (sunapiClientObj) {
    sunapiClient = sunapiClientObj;
  };

  module.SetDeviceInfo = function (deviceInfo) {
    id = deviceInfo.id;
    pw = deviceInfo.pw;
    wsUrl = deviceInfo.wsUrl;
    rtspUrl = deviceInfo.rtspUrl;
    mode = deviceInfo.mode;
    rangeClock = deviceInfo.rangeClock;
    scale = deviceInfo.scale;
    userAgent = deviceInfo.useragent;
    deviceType = deviceInfo.deviceType;
    audioOutStatus = deviceInfo.audioOutStatus;
  };

  module.Connect = function () {
    try {
      if (transport === null || transport === undefined) {
        transport = new Transport(wsUrl);
        transport.setChannel(mediaRouter.getChannel());
        transport.SetCallback(this.connectionCbFunc, this.RtspResponseHandler, this.RtpDataHandler, errorCallbackFunc);
        transport.Connect();
        isConnected = true;
      }
    } catch (error) {
        rtspclient_log.error("Connection error occurred", error);
    }
  };

  module.Disconnect = function () {
    if (transport !== null && transport !== undefined) {
      transport.SendRtspCommand(CommandConstructor('TEARDOWN', null, null));
      transport.Disconnect();
      transport = null;
    }
    clearInterval(getParameterIntervalHandler);
    clearInterval(checkAliveIntervalHandler);
    getParameterIntervalHandler = null;
    checkAliveIntervalHandler = null;
    isConnected = false;
    SDPinfo = [];
    Authentication = '';
  };

  module.close = function () {
    transport.close();
  };

  module.ControlStream = function (controlInfo) {
    var extraheader = '';
    var cmd = null;

    if (transport) {
      if (controlInfo.media.requestInfo.cmd === 'resume') {
        /*PLAY command*/
        cmd = 'PLAY';
        if (controlInfo.media.type === 'playback') {
          extraheader += 'Rate-Control: yes' + '\r\n';

          if(typeof controlInfo.media.requestInfo.scale !== 'undefined') {
            extraheader += this.toStringExtensionScale(controlInfo.media.requestInfo.scale);
          } else {
            extraheader += 'Scale: ' + '1.00000' + '\r\n';
          }

          if(typeof controlInfo.media.requestInfo.rangeClock !== 'undefined') {
            extraheader += 'Range: clock=' + controlInfo.media.requestInfo.rangeClock;
            if( controlInfo.media.requestInfo.rangeClock.search("-") === -1) {
              extraheader += '-';
            }
            extraheader += '\r\n';
          } else {
            extraheader += 'Range: npt=0.000-\r\n';
          }
          if (controlInfo.media.needToImmediate === true) {
            extraheader += 'Immediate: yes' + '\r\n';
          }
        } else if (controlInfo.media.type === 'backup') {
          /*download mode*/
          extraheader += 'Rate-Control: no' + '\r\n';
        }
        transport.SendRtspCommand(CommandConstructor(cmd, controlInfo.media.requestInfo.url, extraheader));
        isPausing = false;
      } else if (controlInfo.media.requestInfo.cmd === 'seek') {
        /*Seek Command*/
        cmd = 'PLAY';
        if (controlInfo.media.type === 'playback' || controlInfo.media.type === 'step') {
          extraheader += 'Immediate: yes' + '\r\n' + 'Rate-Control: yes' + '\r\n';
          if (typeof controlInfo.media.requestInfo.scale !== 'undefined') {
            extraheader += this.toStringExtensionScale(controlInfo.media.requestInfo.scale);
          } else {
            extraheader += 'Scale: ' + '1.00000' + '\r\n';
          }

          if(typeof controlInfo.media.requestInfo.rangeClock !== 'undefined') {
            extraheader += 'Range: clock=' + controlInfo.media.requestInfo.rangeClock;
            if( controlInfo.media.requestInfo.rangeClock.search("-") === -1) {
              extraheader += '-';
            }
            extraheader += '\r\n';
          } else {
            extraheader += 'Range: npt=0.000-\r\n';
          }
        } else if (controlInfo.media.type === 'backup') {
          /*download mode*/
          extraheader += 'Rate-Control: no' + '\r\n' + 'Immediate: yes' + '\r\n';
        }
        transport.SendRtspCommand(CommandConstructor(cmd, controlInfo.media.requestInfo.url, extraheader));
        isPausing = false;
      } else if (controlInfo.media.requestInfo.cmd === 'forward') {
        /*Seek Command*/
        cmd = 'PLAY';
        if (controlInfo.media.type === 'playback' || controlInfo.media.type === 'step') {
          extraheader += 'Immediate: yes' + '\r\n' + 'Rate-Control: yes' + '\r\n';
          if(typeof controlInfo.media.requestInfo.scale !== 'undefined') {
            extraheader += this.toStringExtensionScale(controlInfo.media.requestInfo.scale);
          } else {
            extraheader += 'Scale: ' + '1.00000' + '\r\n';
          }

          if(typeof controlInfo.media.requestInfo.rangeClock !== 'undefined') {
            extraheader += 'Range: clock=' + controlInfo.media.requestInfo.rangeClock;
            if( controlInfo.media.requestInfo.rangeClock.search("-") === -1) {
              extraheader += '-';
            }
            extraheader += '\r\n';
          } else {
            extraheader += 'Range: npt=0.000-\r\n';
          }
        } else if (controlInfo.media.type === 'backup') {
          /*download mode*/
          extraheader += 'Rate-Control: no' + '\r\n' + 'Immediate: yes' + '\r\n';
        }
        transport.SendRtspCommand(CommandConstructor(cmd, controlInfo.media.requestInfo.url, extraheader));
      } else if (controlInfo.media.requestInfo.cmd === 'backward') {
        /*Seek Command*/
        cmd = 'PLAY';
        if (controlInfo.media.type === 'playback' || controlInfo.media.type === 'step') {
          extraheader += 'Immediate: yes' + '\r\n' + 'Rate-Control: yes' + '\r\n';
          if(typeof controlInfo.media.requestInfo.scale !== 'undefined') {
            extraheader += this.toStringExtensionScale(controlInfo.media.requestInfo.scale);
          } else {
            extraheader += 'Scale: ' + '1.00000' + '\r\n';
          }

          if(typeof controlInfo.media.requestInfo.rangeClock !== 'undefined') {
            extraheader += 'Range: clock=' + controlInfo.media.requestInfo.rangeClock;
            if( controlInfo.media.requestInfo.rangeClock.search("-") === -1) {
              extraheader += '-';
            }
            extraheader += '\r\n';
          } else {
            extraheader += 'Range: npt=0.000-\r\n';
          }
        } else if (controlInfo.media.type === 'backup') {
          /*download mode*/
          extraheader += 'Rate-Control: no' + '\r\n' + 'Immediate: yes' + '\r\n';
        }
        transport.SendRtspCommand(CommandConstructor(cmd, controlInfo.media.requestInfo.url, extraheader));
      } else if (controlInfo.media.requestInfo.cmd === 'pause') {
        /*PAUSE command*/
        cmd = 'PAUSE';
        extraheader += 'Scale: ' + '1.000000' + '\r\n'; // + 'Range: npt=0.000-' + '\r\n';

        if(typeof controlInfo.media.requestInfo.rangeClock !== 'undefined') {
          extraheader += 'Range: clock=' + controlInfo.media.requestInfo.rangeClock;
          if( controlInfo.media.requestInfo.rangeClock.search("-") === -1) {
            extraheader += '-';
          }
          extraheader += '\r\n';
        } else {
          extraheader += 'Range: npt=0.000-\r\n';
        }

        transport.SendRtspCommand(CommandConstructor(cmd, controlInfo.media.requestInfo.url, extraheader));
        isPausing = true;
      } else if (controlInfo.media.requestInfo.cmd === 'speed') {
        /*FAST Forward or FAST Backward a stream*/
        cmd = 'PLAY';
        if(typeof controlInfo.media.requestInfo.scale !== 'undefined') {
          extraheader += this.toStringExtensionScale(controlInfo.media.requestInfo.scale);
        } else {
          extraheader += 'Scale: ' + '1.00000' + '\r\n';
        }
        extraheader += 'Rate-Control: yes' + '\r\n';

        if(typeof controlInfo.media.requestInfo.rangeClock !== 'undefined') {
          extraheader += 'Range: clock=' + controlInfo.media.requestInfo.rangeClock;
          if( controlInfo.media.requestInfo.rangeClock.search("-") === -1) {
            extraheader += '-';
          }
          extraheader += '\r\n';
        } else {
          extraheader += 'Range: npt=0.000-\r\n';
        }

        if(deviceType === 'camera') {
          if (controlInfo.media.requestInfo.scale < -1 || controlInfo.media.requestInfo.scale > 1) {
            extraheader += 'Frames: intra' + '\r\n';
          }
        }

        transport.SendRtspCommand(CommandConstructor(cmd, controlInfo.media.requestInfo.url, extraheader));
      } else if (controlInfo.media.requestInfo.cmd === 'backup') {
        /*PLAY command*/
        cmd = 'PLAY';
        extraheader += 'Rate-Control: no' + '\r\n';
        transport.SendRtspCommand(CommandConstructor(cmd, controlInfo.media.requestInfo.url, extraheader));
      } else {
        rtspclient_log.error("RTSP ControlStream- Unknown command:", controlInfo.cmd);
      }
    } else {
      rtspclient_log.error("RTSP ControlStream- Web socket does not exist:");
    }
  };

  module.getCurrentState = function () {
    return currentState;
  };

  /**
   * This property is to return instant playback state of RtspClient.
   * @property instantplayback
   * @memberof RtspClient
   * @example
   *     RtspClient.instantplayback = true;
   */
  Object.defineProperty(this, "instantplayback", {
    get: function() {
        return instantplayback;
    },
    set: function(v) {
      instantplayback = v;
    },
  });

  module.instantplayback = false;

  return module;
};
var RtspClientManager = (function () {
  var rtspManagerInstance;
  var createRtspClientManager = function () {
    var RtspClientList = [];

    var CreateRtspClient = function () {
      var newRtspClient = RtspClient();
      RtspClientList.push(newRtspClient);
      return RtspClient;
    };

    var DeleteRtspClient = function (rtspclient) {
      if ((idx = RtspClientList.indexOf(rtspclient)) !== -1) {
        RtspClientList.splice(idx, 1);
      }
    };

    var GetRtspClientCount = function () {
      return RtspClientList.length;
    };

    return {
      CreateRtspClient: CreateRtspClient,
      DeleteRtspClient: DeleteRtspClient,
      GetRtspClientCount: GetRtspClientCount
    };
  };

  return {
    getInstance: function () {
      if (!rtspManagerInstance) {
        rtspManagerInstance = createRtspClientManager();
      }
      return rtspManagerInstance;
    }
  };
})();


// Example Can use this like below,
//var RtspClientMgr = RtspClientManager.getInstance();
//var RtspClientInst = RtspClientMgr.CreateRtspClient();
var RtspStatusCode = function (statusCode) {
  "use strict";

  var _version = '1.0.0';
  var log = log4javascript.getLogger();

  var _self;

  var StatusCode = {
    Continue: { value: 100, name: 'Continue', description: 'RTSP 100 Continue' },
    OK: { value: 200, name: 'OK', description: 'RTSP 200 OK' },
    Created: { value: 201, name: 'Created', description: 'RTSP 201 Created' },
    LowonStorageSpace: { value: 250, name: 'Low on Storage Space', description: 'RTSP 250 Low on Storage Space' },
    MultipleChoices: { value: 300, name: 'Multiple Choices', description: 'RTSP 300 Multiple Choices' },
    MovedPermanently: { value: 301, name: 'Moved Permanently', description: 'RTSP 301 Moved Permanently' },
    MovedTemporarily: { value: 302, name: 'Moved Temporarily', description: 'RTSP 302 Moved Temporarily' },
    SeeOther: { value: 303, name: 'See Other', description: 'RTSP 303 See Other' },
    NotModified: { value: 304, name: 'Not Modified', description: 'RTSP 304 Not Modified' },
    UseProxy: { value: 305, name: 'Use Proxy', description: 'RTSP 305 Use Proxy' },
    BadRequest: { value: 400, name: 'Bad Request', description: 'RTSP 400 Bad Request' },
    Unauthorized: { value: 401, name: 'Unauthorized', description: 'RTSP 401 Unauthorized' },
    PaymentRequired: { value: 402, name: 'Payment Required', description: 'RTSP 402 Payment Required' },
    Forbidden: { value: 403, name: 'Forbidden', description: 'RTSP 403 Forbidden' },
    NotFound: { value: 404, name: 'Not Found', description: 'RTSP 404 Not Found' },
    MethodNotAllowed: { value: 405, name: 'Method Not Allowed', description: 'RTSP 405 Method Not Allowed' },
    NotAcceptable: { value: 406, name: 'Not Acceptable', description: 'RTSP 406 Not Acceptable' },
    ProxyAuthenticationRequired: { value: 407, name: 'Proxy Authentication Required', description: 'RTSP 407 Proxy Authentication Required' },
    RequestTimeout: { value: 408, name: 'Request Time-out', description: 'RTSP 408 Request Time-out' },
    Gone: { value: 410, name: 'Gone', description: 'RTSP 410 Gone' },
    LengthRequired: { value: 411, name: 'Length Required', description: 'RTSP 411 Length Required' },
    PreconditionFailed: { value: 412, name: 'Precondition Failed', description: 'RTSP 412 Precondition Failed' },
    RequestEntityTooLarge: { value: 413, name: 'Request Entity Too Large', description: 'RTSP 413 Request Entity Too Large' },
    RequestURITooLarge: { value: 414, name: 'Request-URI Too Large', description: 'RTSP 414 Request-URI Too Large' },
    UnsupportedMediaType: { value: 415, name: 'Unsupported Media Type', description: 'RTSP 415 Unsupported Media Type' },
    ParameterNotUnderstood: { value: 451, name: 'Parameter Not Understood', description: 'RTSP 451 Parameter Not Understood' },
    ConferenceNotFound: { value: 452, name: 'Conference Not Found', description: 'RTSP 452 Conference Not Found' },
    NotEnoughBandwidth: { value: 453, name: 'Not Enough Bandwidth', description: 'RTSP 453 Not Enough Bandwidth' },
    SessionNotFound: { value: 454, name: 'Session Not Found', description: 'RTSP 454 Session Not Found' },
    MethodNotValidinThisState: { value: 455, name: 'Method Not Valid in This State', description: 'RTSP 455 Method Not Valid in This State' },
    HeaderFieldNotValidforResource: { value: 456, name: 'Header Field Not Valid for Resource', description: 'RTSP 456 Header Field Not Valid for Resource' },
    InvalidRange: { value: 457, name: 'Invalid Range', description: 'RTSP 457 Invalid Range' },
    ParameterIsReadOnly: { value: 458, name: 'Parameter Is Read-Only', description: 'RTSP 458 Parameter Is Read-Only' },
    AggregateOperationNotAllowed: { value: 459, name: 'Aggregate operation not allowed', description: 'RTSP 459 Aggregate operation not allowed' },
    OnlyAggregateOperationAllowed: { value: 460, name: 'Only aggregate operation allowed', description: 'RTSP 460 Only aggregate operation allowed' },
    UnsupportedTransport: { value: 461, name: 'Unsupported transport', description: 'RTSP 461 Unsupported transport' },
    DestinationUnreachable: { value: 462, name: 'Aggregate operation not allowed', description: 'RTSP 462 Destination unreachable' },
    KeyManagementFailure: { value: 463, name: 'Key management Failure', description: 'RTSP 463 Key management Failure' },
    AccountBlocked: { value: 490, name: 'Account Blocked', description: 'RTSP 490 Account Blocked' },
    InternalServerError: { value: 500, name: 'Internal Server Error', description: 'RTSP 500 Internal Server Error' },
    NotImplemented: { value: 501, name: 'Not Implemented', description: 'RTSP 501 Not Implemented' },
    BadGateway: { value: 502, name: 'Bad Gateway', description: 'RTSP 502 Bad Gateway' },
    ServiceUnavailable: { value: 503, name: 'Service Unavailable', description: 'RTSP 503 Service Unavailable' },
    GatewayTimeout: { value: 504, name: 'Gateway Time-out', description: 'RTSP 504 Gateway Time-out' },
    RTSPVersionNotSupported: { value: 505, name: 'RTSP Version not supported', description: 'RTSP 505 RTSP Version not supported' },
    OptionNotSupported: { value: 551, name: 'Option not supported', description: 'RTSP 551 Option not supported' },
    MaximumUserReached: { value: 560, name: 'Maximum user Reached', description: 'RTSP 560 Maximum user Reached for HTW NVR Device' },
    InvalidRequestSearchTime: { value: 702, name: 'Invalid Request Search Time', description: 'RTSP 702 Invalid Request Search Time' },
    Unknown: { value: -1, name: 'Unknown', description: 'RTSP -1 Unknown' },
  };

  function version() {
    return _version;
  }

  function Constructor(statusCode) {
    _self = this;

    switch (Number(statusCode)) {
      case 100:
        Constructor.prototype.status = StatusCode.Continue;
        break;
      case 200:
        Constructor.prototype.status = StatusCode.OK;
        break;
      case 201:
        Constructor.prototype.status = StatusCode.Created;
        break;
      case 250:
        Constructor.prototype.status = StatusCode.LowonStorageSpace;
        break;
      case 300:
        Constructor.prototype.status = StatusCode.MultipleChoices;
        break;
      case 301:
        Constructor.prototype.status = StatusCode.MovedPermanently;
        break;
      case 302:
        Constructor.prototype.status = StatusCode.MovedTemporarily;
        break;
      case 303:
        Constructor.prototype.status = StatusCode.SeeOther;
        break;
      case 304:
        Constructor.prototype.status = StatusCode.NotModified;
        break;
      case 305:
        Constructor.prototype.status = StatusCode.UseProxy;
        break;
      case 400:
        Constructor.prototype.status = StatusCode.BadRequest;
        break;
      case 401:
        Constructor.prototype.status = StatusCode.Unauthorized;
        break;
      case 402:
        Constructor.prototype.status = StatusCode.PaymentRequired;
        break;
      case 403:
        Constructor.prototype.status = StatusCode.Forbidden;
        break;
      case 404:
        Constructor.prototype.status = StatusCode.NotFound;
        break;
      case 405:
        Constructor.prototype.status = StatusCode.MethodNotAllowed;
        break;
      case 406:
        Constructor.prototype.status = StatusCode.NotAcceptable;
        break;
      case 407:
        Constructor.prototype.status = StatusCode.ProxyAuthenticationRequired;
        break;
      case 408:
        Constructor.prototype.status = StatusCode.RequestTimeout;
        break;
      case 410:
        Constructor.prototype.status = StatusCode.Gone;
        break;
      case 411:
        Constructor.prototype.status = StatusCode.LengthRequired;
        break;
      case 412:
        Constructor.prototype.status = StatusCode.PreconditionFailed;
        break;
      case 413:
        Constructor.prototype.status = StatusCode.RequestEntityTooLarge;
        break;
      case 414:
        Constructor.prototype.status = StatusCode.RequestURITooLarge;
        break;
      case 415:
        Constructor.prototype.status = StatusCode.UnsupportedMediaType;
        break;
      case 451:
        Constructor.prototype.status = StatusCode.ParameterNotUnderstood;
        break;
      case 452:
        Constructor.prototype.status = StatusCode.ConferenceNotFound;
        break;
      case 453:
        Constructor.prototype.status = StatusCode.NotEnoughBandwidth;
        break;
      case 454:
        Constructor.prototype.status = StatusCode.SessionNotFound;
        break;
      case 455:
        Constructor.prototype.status = StatusCode.MethodNotValidinThisState;
        break;
      case 456:
        Constructor.prototype.status = StatusCode.HeaderFieldNotValidforResource;
        break;
      case 457:
        Constructor.prototype.status = StatusCode.InvalidRange;
        break;
      case 458:
        Constructor.prototype.status = StatusCode.ParameterIsReadOnly;
        break;
      case 459:
        Constructor.prototype.status = StatusCode.AggregateOperationNotAllowed;
        break;
      case 460:
        Constructor.prototype.status = StatusCode.OnlyAggregateOperationAllowed;
        break;
      case 461:
        Constructor.prototype.status = StatusCode.UnsupportedTransport;
        break;
      case 462:
        Constructor.prototype.status = StatusCode.DestinationUnreachable;
        break;
      case 463:
        Constructor.prototype.status = StatusCode.KeyManagementFailure;
        break;
      case 490:
        Constructor.prototype.status = StatusCode.AccountBlocked;
        break;
      case 500:
        Constructor.prototype.status = StatusCode.InternalServerError;
        break;
      case 501:
        Constructor.prototype.status = StatusCode.NotImplemented;
        break;
      case 502:
        Constructor.prototype.status = StatusCode.BadGateway;
        break;
      case 503:
        Constructor.prototype.status = StatusCode.ServiceUnavailable;
        break;
      case 504:
        Constructor.prototype.status = StatusCode.GatewayTimeout;
        break;
      case 505:
        Constructor.prototype.status = StatusCode.RTSPVersionNotSupported;
        break;
      case 551:
        Constructor.prototype.status = StatusCode.OptionNotSupported;
        break;
      case 560:
        Constructor.prototype.status = StatusCode.MaximumUserReached;
        break;
      case 702:
        Constructor.prototype.status = StatusCode.InvalidRequestSearchTime;
        break;
      default:
        status = StatusCode.Unknown;
        break;
    }
  }

  Constructor.prototype = {
    getDescription: function () {
      return Constructor.prototype.status.description;
    },
    getStatusCode: function () {
      return Constructor.prototype.status.value;
    },
    getName: function () {
      return Constructor.prototype.status.name;
    },
    getObject: function () {
      return Constructor.prototype.status;
    },
    toString: function () {
      return JSON.stringify(Constructor.prototype.status);
    }
  };
  return new Constructor(statusCode);
};
var Transport = function (serverAddr) {
  "use strict";

  var version = '1.0.0';
  var transport_log = log4javascript.getLogger('transport');

  var module = {};
  var websock = null;
  var rtspCallback;
  var rtpCallback;
  var channelId;

  //rtp packet data buffer
  var rtpPacketArray;
  //rtsp response buffer
  var RTSPResArray;
  //partial rtp pcaket data buffer
  var partialRtpPacketArray;
  //partial rtsp response buffer
  var partialRTSPResArray;
  //rtsp interleave header
  var rtspinterleave;
  //rtp header
  var rtpheader;

  //current socket buffer position
  var curpos = 0;
  var partialCurpos = 0;

  var totalsockData = 0;
  var sockDataRead = 0;
  var sockDataRemaining = 0;

  var IsPartialRTPData = false;
  var IsPartialRTSPData = false;

  var RTPPacketTotalSize = 0;
  var RTPPacketBytesRead = 0;
  var RTPPacketRemaningBytes = 0;
  var RTPDataRemaningBytes = 0;
  var RTSPDataRead = 0;
  var rtspmsgcnt = 0;
  var rtppcktcnt = 0;

  var IsDescribe = false;
  var describekey = false;
  var tempBuffer = null;
  var tempBufferLen = 0;
  var connectionCallback = null;
  var errorCallback;
  var rtpEmbeddedBinaryDataLength = 4;
  var rtpHeaderLength = 12;
  var PreceiveUint8 = new Uint8Array();

  var stringToUint8Array = function (inputString) {
    var stringLength = inputString.length;
    var outputUint8Array = new Uint8Array(new ArrayBuffer(stringLength));

    for (var i = 0; i < stringLength; i++) {
      outputUint8Array[i] = inputString.charCodeAt(i);
    }
    return outputUint8Array;
  };

  var appendBuffer = function (buffer1, buffer2) {
    if ((buffer1.byteLength + buffer2.byteLength) > buffer1.byteLength) {
      var tmp = buffer1;
      buffer1 = null;
      buffer1 = new Uint8Array(tmp.length + buffer2.length);
      buffer1.set(tmp, 0);
      buffer1.set(buffer2, tmp.length);
      tmp = null;
    }
    return buffer1;
  };

  var ReadSocketData = function (receiveBlobMsg) {
    try {
      var receiveUint8 = new Uint8Array(receiveBlobMsg);
      //Append the new received socket data
      PreceiveUint8 = appendBuffer(PreceiveUint8, receiveUint8);
      receiveUint8 = null;

      sockDataRemaining = PreceiveUint8.length;
      //transport_log.info("sockDataRemaining:before while ", sockDataRemaining);
      while (sockDataRemaining > 0) {
        //serach for $;
        //var searchMsg = String.fromCharCode.apply(null, receiveUint8);
        //var posret = searchMsg.indexOf("$", curpos);
        if (PreceiveUint8[0] !== 0x24) { // the case of RTSP
          //copy rtsp data to rtsp buffer
          //check for rtsp data is complete or not
          var PreceiveMsg = String.fromCharCode.apply(null, PreceiveUint8);
          var rtspendpos = null;
          if (IsDescribe === true) {
            rtspendpos = PreceiveMsg.lastIndexOf("\r\n");
            IsDescribe = false;
          } else {
            rtspendpos = PreceiveMsg.search("\r\n\r\n");
          }

          var rtspstartpos = PreceiveMsg.search("RTSP");
          if (rtspstartpos !== -1) {
            if (rtspendpos !== -1) {
              //rtsp response complete
              RTSPResArray = PreceiveUint8.subarray(rtspstartpos, rtspendpos + 4);
              PreceiveUint8 = PreceiveUint8.subarray(rtspendpos + 4);
              var receiveMsg = String.fromCharCode.apply(null, RTSPResArray);
              //we got complete rtsp response - inform to rtsp client
              rtspCallback(receiveMsg);
              sockDataRemaining = PreceiveUint8.length;

              RTSPResArray = null;
              receiveMsg = null;
              // console.log("sockDataRemaining after RTSP ", sockDataRemaining);
            } else {
              //rtsp response is partial - we do not know size of rtsp remaining bytes here,
              // just keep holding the remained data
              sockDataRemaining = PreceiveUint8.length;
              return;
            }
          } else {
            transport_log.error("Invalid rtsp data in the channel: " + channelId);
            throw new umpError({
              channelId: channelId,
              errorCode: fromHex('0x0200'),
              place: 'transport.js:139',
              message: "Invalid rtsp data in the channel  [" + error.message + "]"
            });
            //          return;
          }
        } else { // case of $ in the firsts position
          try {
            transport_log.debug("Magic: 0x" + PreceiveUint8[0].toString(16) +
            ", Channel: " + PreceiveUint8[1] +
            ", Length: " + PreceiveUint8[2] * 256 + PreceiveUint8[3] +
            ", Data: 0x" + PreceiveUint8[4].toString(16));
          } catch(err) {
          }
          //copy data to rtp buffer
          //check rtp data is complete or not
          RTPPacketTotalSize = PreceiveUint8[2] * 256 + PreceiveUint8[3]; // rtp packet size
          if (RTPPacketTotalSize + rtpEmbeddedBinaryDataLength <= PreceiveUint8.length) {
            rtspinterleave = PreceiveUint8.subarray(0, rtpEmbeddedBinaryDataLength); // 4 is the size of interleave header
            rtpheader = PreceiveUint8.subarray(rtpEmbeddedBinaryDataLength, rtpEmbeddedBinaryDataLength + rtpHeaderLength);
            rtpPacketArray = PreceiveUint8.subarray(rtpEmbeddedBinaryDataLength + rtpHeaderLength, RTPPacketTotalSize + rtpEmbeddedBinaryDataLength);
            rtpCallback(rtspinterleave, rtpheader, rtpPacketArray);
            PreceiveUint8 = PreceiveUint8.subarray(RTPPacketTotalSize + rtpEmbeddedBinaryDataLength);
            sockDataRemaining = PreceiveUint8.length;

            rtspinterleave = null;
            rtpheader = null;
            rtpPacketArray = null;
            //console.log("sockDataRemaining after RTP ", sockDataRemaining);
          } else {
            //rtp response is partial - we do not know size of rtsp remaining bytes here,
            // just keep holding the remained data
            sockDataRemaining = PreceiveUint8.length;
            //console.log("A part of RTP is still remaining", sockDataRemaining);
            return;
          }
        }
      }
    } catch (error) {
      console.error("unknown error: ", error.stack);
      throw new umpError({
        channelId: channelId,
        errorCode: error.errorCode,
        place: error.place,
        message: error.message
      });
    }
  };

  /**
   * @description Receive RTSP/RTP/RTCP data from web socket
   * @param {object} event Websocket recveived data
   */
  var OnReceive = function (event) {
    try {
      ReadSocketData(event.data);
      //sleep(10);
    } catch (error) {
      if(typeof errorCallback !== 'undefined') {
        errorCallback({
          channelId: error.channel,
          errorCode: error.errorCode,
          place: error.place,
          description: error.message
        });
      }
    }
  };
  /**
   * @description Websocket open event listener function when the connection is opened
   * @param {string} message
   */
  var OnOpen = function (message) {
    transport_log.info("----- open websocket [" + channelId + "]-----");
    connectionCallback('open', message);
  };
  /**
   * @description Websocket close event listener function when the connection is closed
   * @param {object} error
   */
  var OnClose = function (event) {
    var status;
    transport_log.info("----- event onclose from  websocket [" + channelId + "]-----");
    if (event.wasClean === false) {
      transport_log.error("error1: websocket closed [" + channelId + "]", event);
      status = new WebsocketStatusCode(event.code);
      if(typeof errorCallback !== 'undefined') {
        errorCallback({
          channelId: channelId,
          errorCode: fromHex('0x0005'),
          place: "transport.js:230",
          description: "Error Code: " + status.getStatusCode() + ", Name: " + status.getName() + ", Desc: " + status.getDescription()
        });
      }

      connectionCallback('error', status);
    } else if (event.wasClean === true &&
      websock !== null &&
      websock.readyState === WebSocket.CLOSED) {
        transport_log.debug("error: websocket closed [" + channelId + "]");
      status = new WebsocketStatusCode(event.code);
      connectionCallback('close', status);
    } else {
      // reference from Websocket Status code
      // https://developer.mozilla.org/en-US/docs/Web/API/CloseEvent
      transport_log.error("error2: websocket closed [" + channelId + "]", event);
      status = new WebsocketStatusCode(event.code);
/*      throw new umpError({
        channelId: channelId,
        errorCode: 5,
        place: 'transport.js:246',
        message: status.getDescription()
      });*/
      connectionCallback('error', status);
    }
    websock = null;
  };
    /**
   * @description Websocket open event listener function when the connection is opened
   * @param {object} event
   */
  var OnError = function (event) {
    transport_log.info("----- event onerror from  websocket [" + channelId + "]-----");
    if (websock.readyState == 1) {
      console.error(event);
      transport_log.debug('error: websocket event ' + event.type);
    }
  };
  /**
   * @description 카메라 또는 저장장치의 채널 정보를 설정한다.
   * @param {number} channelid set number of channel
   */
  module.setChannel = function (channelid) {
    channelId = (channelid === null ? 0 : channelid);
    transport_log.debug("set to transport channel number: " + channelId);
  };
  /**
   * @description 카메라 또는 저장장치의 채널 정보를 가져온다.
   * @param {number} channelid get number of channel
   */
  module.getChannel = function (channelid) {
    return channelId;
  };
  /**
   * @description Transport 객체의 Callback 함수를 설정한다.
   * @param {object} connectionCbFunc Connection 데이터의 callback 함수
   * @param {object} rtspCbFunc rtsp 데이터의 callback 함수
   * @param {obejct} rtpCbFunc rtp 데이터의 callback 함수
   * @param {object} errorCbFunc error 데이터의 callback 함수
   */
  module.SetCallback = function (connectionCbFunc, rtspCbFunc, rtpCbFunc, errorCbFunc) {
    rtspCallback = rtspCbFunc;
    rtpCallback = rtpCbFunc;
    connectionCallback = connectionCbFunc;
    errorCallback = errorCbFunc;
  };
  /**
   * @description Transport Connect 함수
   */
  module.Connect = function () {
    try {
      websock = new WebSocket(serverAddr);
      websock.binaryType = 'arraybuffer';
      websock.onmessage = OnReceive;
      websock.onopen = OnOpen;
      websock.onclose = OnClose;
      websock.onerror = OnError;
    } catch (error) {
      transport_log.error("Fail to connect websocket with error in: [" + channelId + "]");
      throw new umpError({
        channelId: channelId,
        errorCode: fromHex('0x0002'),
        place: 'transport.js:310',
        message: "Fail to disconnect websock with error: " + error.message
      });
    }
  };
  /**
   * @description Transport disconnect 함수
   */
  module.Disconnect = function () {
    try {
      if (websock !== null && websock.readyState === WebSocket.OPEN) {
        websock.close();
        transport_log.info("Success to disconnect websock [" + channelId + "]-----");
      }
    } catch (error) {
      transport_log.error("Fail to disconnect websock with error in : [" + channelId + "]");
      throw new umpError({
        channelId: channelId,
        errorCode: fromHex('0x0003'),
        place: 'transport.js:330',
        message: "error of weboskcet disconnect: " + error.message
      });
    }
  };
  /**
   * @description RTSP 명령을 Websocket 을 사용해 장비로 전송한다.
   * @param {string} sendMessage RTSP command string
   */
  module.SendRtspCommand = function (sendMessage) {
    try {
      if (websock !== null && websock.readyState === WebSocket.OPEN) {
        if (describekey === false) {
          var describeCmd = sendMessage.search("DESCRIBE");
          if (describeCmd !== -1) {
            IsDescribe = true;
            describekey = true;
          }
        }
        websock.send(stringToUint8Array(sendMessage));
        //transport_log.debug("----- send message [" + channelId + "]-----" + sendMessage);
      }
    } catch (error) {
      transport_log.error("SendRtspCommand - send rtsp data error: [" + channelId + "]");
      throw new umpError({
        channelId: channelId,
        errorCode: fromHex('0x0004'),
        place: 'transport.js:356',
        message: "error of rtsp packet transmission: " + error.message
      });
    }
  };
  /**
   * @description send RTP data
   * @param {object} rtpdata rtp packet from rtp packtized
   */
  module.SendRtpData = function (rtpdata) {
    try {
      if (websock !== null && websock.readyState === WebSocket.OPEN) {
        websock.send(rtpdata);
      } else {
        transport_log.error("SendRtpData - send rtp data error: [" + channelId + "]");
        throw new umpError({
          channelId: channelId,
          errorCode: fromHex('0x0004'),
          place: 'transport.js:374',
          message: "error of send rtp packet transmission: " + error.message
        });
      }
    } catch (error) {

    }
  };
  /**
   * @description close transport
   */
  module.close = function () {
    try {
      if (websock.readyState === WebSocket.OPEN) {
        websock.close();
        websock = null;
      }
      transport_log.info("----- close websock [" + channelId + "]-------");
    } catch (error) {
      transport_log.error("close - Web socket closed error: [" + channelId + "]");
      throw new umpError({
        channelId: channelId,
        errorCode: fromHex('0x0005'),
        place: 'transport.js:396',
        message: "error of websocket close: " + error.message
      });
    }
  };

  return module;
};
function WebsocketStatusCode(errorCode) {
  "use strict";

  var version = '1.0.0';
  var log = log4javascript.getLogger();

  var _self;

  var StatusCode = {
    Reserved_0_999: { value: 999, name: 'Reserved', description: 'Reserved and not used.' },
    NormalClosure : { value: 1000, name: 'Normal Closure', description: 'Normal closure; the connection successfully completed whatever purpose for which it was created.' },
    GoingAway	 : { value: 1001, name: 'Going Away', description: 'The endpoint is going away, either because of a server failure or because the browser is navigating away from the page that opened the connection.' },
    ProtocolError : { value: 1002, name: 'Protocol Error', description: 'The endpoint is terminating the connection due to a protocol error.'},
    UnsupportedData : { value: 1003, name: 'Unsupported Data', description: 'The connection is being terminated because the endpoint received data of a type it cannot accept (for example, a text-only endpoint received binary data).'},
    Reserved_1004 : { value: 1004, name: 'Reserved', description: 'Reserved. A meaning might be defined in the future.'},
    NoStatusRecvd : { value: 1005, name: 'No Status Recvd', description: 'Reserved.  Indicates that no status code was provided even though one was expected.'},
    AbnormalClosure : { value: 1006, name: 'Abnormal Closure', description: 'Reserved. Used to indicate that a connection was closed abnormally (that is, with no close frame being sent) when a status code is expected.'},
    InvalidFramePayloadData : { value: 1007, name: 'Invalid frame payload data', description: 'The endpoint is terminating the connection because a message was received that contained inconsistent data (e.g., non-UTF-8 data within a text message).'},
    PolicyViolation : { value: 1008, name: 'Policy Violation', description: 'The endpoint is terminating the connection because it received a message that violates its policy. This is a generic status code, used when codes 1003 and 1009 are not suitable.'},
    MessageTooBig : { value: 1009, name: 'Message too big', description: 'The endpoint is terminating the connection because a data frame was received that is too large.'},
    MissingExtension : { value: 1010, name: 'Missing Extension', description: "The client is terminating the connection because it expected the server to negotiate one or more extension, but the server didn't."},
    InternalError : { value: 1011, name: 'Internal Error', description: 'The server is terminating the connection because it encountered an unexpected condition that prevented it from fulfilling the request.'},
    ServiceRestart	 : { value: 1012, name: 'Service Restart', description: 'The server is terminating the connection because it is restarting.'},
    TryAgainLater	 : { value: 1013, name: 'Try Again Later', description: 'The server is terminating the connection due to a temporary condition, e.g. it is overloaded and is casting off some of its clients.'},
    BadGateway		 : { value: 1014, name: 'Bad Gateway	', description: 'The server was acting as a gateway or proxy and received an invalid response from the upstream server. This is similar to 502 HTTP Status Code.'},
    TLSHandshake	 : { value: 1015, name: 'TLS Handshake', description: "Reserved. Indicates that the connection was closed due to a failure to perform a TLS handshake (e.g., the server certificate can't be verified)."},
    Reserved_1016_1999	 : { value: 1016, name: 'Reserved', description: 'Reserved for future use by the WebSocket standard.'},
    Reserved_2000_2999	 : { value: 2000, name: 'Reserved', description: 'Reserved for use by WebSocket extensions.'},
    Reserved_3000_3999	 : { value: 3000, name: 'Reserved', description: 'Available for use by libraries and frameworks. May not be used by applications. Available for registration at the IANA via first-come, first-serve.'},
    Reserved_4000_4999	 : { value: 4000, name: 'Reserved', description: 'Available for use by applications.'},
    Reserved_12592	 : { value: 12592, name: 'Host was closed the websocket', description: 'Host was closed the websocket.'},
    Unknown: { value: -1, name: 'Unknown', description: 'Unknown Status code.'},
  };

  function Constructor(statusCode) {
    _self = this;
    
    if(Number(statusCode) <= 999) {
      Constructor.prototype.status = StatusCode.Reserved_0_999;
      return;
    } else if (Number(statusCode) >= 1016 && Number(statusCode) <= 1999) {
      Constructor.prototype.status = StatusCode.Reserved_1016_1999;
      return;
    } else if (Number(statusCode) >= 2000 && Number(statusCode) <= 2999) {
      Constructor.prototype.status = StatusCode.Reserved_2000_2999;
      return;
    } else if (Number(statusCode) >= 3000 && Number(statusCode) <= 3999) {
      Constructor.prototype.status = StatusCode.Reserved_3000_3999;
      return;
    } else if (Number(statusCode) >= 4000 && Number(statusCode) <= 4999) {
      Constructor.prototype.status = StatusCode.Reserved_4000_4999;
      return;
    } else {
      switch (Number(statusCode)) {
        case 1000:
          Constructor.prototype.status = StatusCode.NormalClosure;
          break;
        case 1001:
          Constructor.prototype.status = StatusCode.GoingAway;
          break;
        case 1002:
          Constructor.prototype.status = StatusCode.ProtocolError;
          break;
        case 1003:
          Constructor.prototype.status = StatusCode.UnsupportedData;
          break;
        case 1004:
          Constructor.prototype.status = StatusCode.Reserved1004;
          break;
        case 1005:
          Constructor.prototype.status = StatusCode.NoStatusRecvd;
          break;
        case 1006:
          Constructor.prototype.status = StatusCode.AbnormalClosure;
          break;
        case 1007:
          Constructor.prototype.status = StatusCode.InvalidFramePayloadData;
          break;
        case 1008:
          Constructor.prototype.status = StatusCode.PolicyViolation;
          break;
        case 1009:
        Constructor.prototype.status = StatusCode.MessageTooBig;
          break;
        case 1010:
          Constructor.prototype.status = StatusCode.MissingExtension;
          break;
        case 1011:
          Constructor.prototype.status = StatusCode.InternalError;
          break;
        case 1012:
          Constructor.prototype.status = StatusCode.ServiceRestart;
          break;
        case 1013:
          Constructor.prototype.status = StatusCode.TryAgainLater;
          break;
        case 1014:
          Constructor.prototype.status = StatusCode.BadGateway;
          break;
        case 1015:
          Constructor.prototype.status = StatusCode.TLSHandshake;
          break;
        case 12592:
          Constructor.prototype.status = StatusCode.Reserved_12592;
          break;
        default:
        Constructor.prototype.status = StatusCode.Unknown;
          break;
      }
    }
  }

  Constructor.prototype = {
    getDescription: function() {
      return Constructor.prototype.status.description;
    },
    getStatusCode: function() {
      return Constructor.prototype.status.value;
    },
    getName: function () {
      return Constructor.prototype.status.name;
    },
    getObject: function() {
      return Constructor.prototype.status;
    }
  };
  return new Constructor(errorCode);
}


function G711AudioEncoder() {

  var localSampleRate = 48000;

  var BIAS   =  0x84;

  var CLIP = 8159;

  var seg_end = [0xFF, 0x1FF, 0x3FF, 0x7FF, 0xFFF, 0x1FFF, 0x3FFF, 0x7FFF];

  var seg_uend = [0x3F, 0x7F, 0xFF, 0x1FF,0x3FF, 0x7FF, 0xFFF, 0x1FFF];

  var self = this;

  var codecInfo = {
		type: "G.711",
		samplingRate : 8000
		// bitrate : 64000
  };

  var remainBuffer = null;

  this.setSampleRate = function(_sampleRate) {
  	localSampleRate = _sampleRate;
  };

  this.encode = function(buffer) {
		var float32Array = null;

		if(remainBuffer !== null){
			float32Array = new Float32Array(buffer.length + remainBuffer.length);
			float32Array.set(remainBuffer, 0);
			float32Array.set(buffer, remainBuffer.length);
		}else{
			float32Array = buffer;
		}

		float32Array = downsampleBuffer(float32Array, codecInfo.samplingRate);

		var pcmArray = new Int16Array(float32Array.length);

		var ulawArray = new Uint8Array(pcmArray.length);

		for(var i = 0, float32Array_length = float32Array.length; i < float32Array_length; i++){
		  pcmArray[i] = float32Array[i] * Math.pow(2,15);
		  ulawArray[i] = lin2Mulaw(pcmArray[i]);
		}

		return ulawArray;
  };

  function downsampleBuffer(buffer, rate) {
		if (rate === localSampleRate) {
		  return buffer;
		}
		if (rate > localSampleRate) {
		  throw "Downsampling rate show be smaller than original sample rate";
		}
		var sampleRateRatio = localSampleRate / rate;

		var newLength = Math.floor(buffer.length / sampleRateRatio);
		var result = new Float32Array(newLength);
		var offsetResult = 0;
		var offsetBuffer = 0;

		while (offsetResult < result.length) {
		  var nextOffsetBuffer = Math.round((offsetResult + 1) * sampleRateRatio);
		 
		  var accum = 0, count = 0;
		  for (var i = offsetBuffer, buffer_length = buffer.length; i < nextOffsetBuffer && i < buffer_length; i++) {
				accum += buffer[i];
				count++;
		  }

		  result[offsetResult] = accum / count;
		  offsetResult++;
		  offsetBuffer = nextOffsetBuffer;
		}

		remainBuffer = null;
		if(Math.round(offsetResult*sampleRateRatio) !== buffer.length){
			var remainStartIndex = Math.round(offsetResult*sampleRateRatio);
			remainBuffer = new Float32Array(buffer.subarray(remainStartIndex,buffer.length));
		}
		
		return result;
  }

  function lin2Mulaw (pcm_val){
	var mask, seg, uval;
	if (pcm_val < 0) {
		pcm_val = BIAS - pcm_val;
		mask = 0x7F;
	} else {
		pcm_val += BIAS;
		mask = 0xFF;
	}
	seg = search(pcm_val, seg_end);
	if (seg >= 8){		// out of range, return maximum value. 
		return (0x7F ^ mask);
	}
	else {
		uval = (seg << 4) | ((pcm_val >> (seg + 3)) & 0xF);
		return (uval ^ mask);
	}
}
  

  function search(val, table)
  {
	for (var i=0, table_length = table.length; i<table_length; i++){
	  if (val<=table[i])
		return i;
	}
	return table.length;
  }

  this.getCodecInfo = function() {
	return codecInfo;
  };

  // constructor.prototype = {
  //   getCodecInfo: function() {
  //     return codecInfo;
  //   },
  //   encode: function(buffer) {
  //     return encode(buffer);
  //   }
  // };
  // return new constructor();
}
function Talk() {
	"use strict";

	var	audioContext = null,
	gainOutNode = null,
	bufferSize = 4096, //1024, // var bufferSize = 1024; //must be power num
	scriptNode = null,
	localSampleRate = null,
	isStreaming = false,
	currentLocalStream = null,
	streamNode = null;
	

	var constraints = {
		audio: true,
		video: false
	};

	var sendAudioBufferCallback = null;


	function cleanBuffer() {
		chunkCounter = 0;
		bufferedArray = null;
	}

	function Constructor() {}

	Constructor.prototype = {
		init: function(){
			//initWebAudio();
			//get audio context
			if (typeof audioContext === "undefined" || audioContext === null) {
				try {
					window.AudioContext = window.AudioContext       ||
					window.webkitAudioContext ||
					window.mozAudioContext    ||
					window.oAudioContext      ||
					window.msAudioContext;
					audioContext = new AudioContext();
					audioContext.onstatechange = function() {
						console.info('Audio Context State changed :: ' + audioContext.state);
					};
				} catch (error) {
					console.error("Web Audio API is not supported in this web browser! : " + error);
					return false;
				}      
			}else{
				// console.info('Audio context already defined!'); //audio_context already defined
			}
			return true;
		},
		initAudioOut: function(){
			//setAudioOutNodes();
			return new Promise(function(resolve, reject){
				if(gainOutNode === null || scriptNode === null) {
					gainOutNode = audioContext.createGain();
					// var biquadFilter = audioContext.createBiquadFilter();
					scriptNode = audioContext.createScriptProcessor(bufferSize, 1, 1);
					scriptNode.onaudioprocess = function(e){
						if(currentLocalStream !==null) {
						var recordChunk = e.inputBuffer.getChannelData(0);
							if(sendAudioBufferCallback !== null && isStreaming === true) {
								sendAudioBufferCallback(recordChunk);
							}
						}
					};
					gainOutNode.connect(scriptNode);
					scriptNode.connect(audioContext.destination);
					localSampleRate = audioContext.sampleRate;
					gainOutNode.gain.value =1;
					
					/* gainOutNode.connect(biquadFilter);
					biquadFilter.connect(scriptNode);
					scriptNode.connect(audioContext.destination);
					localSampleRate = audioContext.sampleRate;
					biquadFilter.type = 'lowpass';
					biquadFilter.frequency.value = 2000;
					biquadFilter.gain.value = 10;   */
				} 
				
				// init getusermedia
				if(typeof navigator.mediaDevices === "undefined") {
					navigator.mediaDevices = {};
				}
				if(typeof navigator.mediaDevices.getUserMedia === "undefined") {
					//navigator.mediaDevices.getUserMedia = promisifiedOldGUM;
					navigator.mediaDevices.getUserMedia = function (constraints, successCallback, errorCallback) {
						// First get ahold of getUserMedia, if present
						var getUserMedia = (navigator.getUserMedia ||
						navigator.webkitGetUserMedia ||
						navigator.mozGetUserMedia ||
						navigator.msGetUserMedia);
						// Some browsers just don't implement it - return a rejected promise with an error
						// to keep a consistent interface
						if(!getUserMedia) {
							return Promise.reject(new Error('getUserMedia is not implemented in this browser'));
						} else {
							// Otherwise, wrap the call to the old navigator.getUserMedia with a Promise
							return new Promise(function(successCallback, errorCallback) {
								getUserMedia.call(navigator, constraints, successCallback, errorCallback);
							});
						}
					};
				}
				if(navigator.mediaDevices.getUserMedia) {
					navigator.mediaDevices.getUserMedia(constraints).then(function(stream) {
						currentLocalStream = stream;
						streamNode = audioContext.createMediaStreamSource(stream);
						streamNode.connect(gainOutNode);
						isStreaming = true;
						resolve(localSampleRate);
					}).catch(function(error) {
						console.error(error);
						reject(new Error(error));
					});
				} else {
					console.error('Cannot open local media stream! :: navigator.mediaDevices.getUserMedia is not defined!');
					reject(new Error('Cannot open local media stream! :: navigator.mediaDevices.getUserMedia is not defined!'));				
				}
			});
		},
		controlVolumeOut: function(volumn) {
			// setAudioOutNodes(); // in case control volume before turn on
			var tVol = volumn / 20 * 2;
			if(tVol <= 0) { //min
				gainOutNode.gain.value = 0;
			} else {
				if (tVol >= 10) { //max
					gainOutNode.gain.value = 10;
				} else {
					gainOutNode.gain.value = tVol;
				}
			}
		},
		stopAudioOut: function(){       //after stopAudioOut, initAudioOut needs to be called to restart.
			// if(currentLocalStream.active) {
			if(currentLocalStream !== null) {  
				if(isStreaming){
					try{
						var audioTracks = currentLocalStream.getAudioTracks();
						for(var i = 0, audioTracks_length = audioTracks.length; i < audioTracks_length; i++) {
							audioTracks[i].stop();
						}
						isStreaming = false;
						currentLocalStream = null;
					}catch(e){
						console.log(e);
					}
				}
			}
			// } else {
			//   console.info('Current Local Stream is not active!');
			// }        
		},
		terminate: function(){
			//self.stopAudioIn();
			this.stopAudioOut();
			audioContext.close();        
			gainOutNode = null;
			scriptNode = null;
		},
		setSendAudioTalkBufferCallback: function(callbackFn){
			sendAudioBufferCallback = callbackFn;
		}
	};
	return new Constructor();
}
/* global Size, YUVWebGLCanvas, */

/**
 * canvasRenderer
 * @class canvasRenderer
 */
function CanvasRenderer() {
  "use strict";

  var version = '1.0.0';
  var log = log4javascript.getLogger('player:canvas:renderer');

  //common variables
  var canvasElement = null,
      drawer = null,
      mapDrawer = null,
      codecType = null,
      captureFlag = false,
      fileName = null,
      size = null,
      minimapInfo = {
        isUpdate: false,
        element: null
      },
      _self;

  function Constructor() {
    _self = this;
  }

  function capture() {
    if (canvasElement.updatedCanvas === true) {
      captureFlag = false;
//      doCapture(canvasElement.toDataURL(), fileName);

      canvasElement.toBlob(function (blob) {
        if(fileName !== null && fileName !== undefined) {
          saveAs(blob, fileName + '.png');
        } else {
          if(_self.eventCaptureCallback !== null && _self.eventCaptureCallback !== undefined) {
            var data = {
              channelId: _self.channelId,
              blob: blob
            };
            _self.eventCaptureCallback(data);
          } else {
            throw new umpError({
              channelId: _self.channelId,
              errorCode: fromHex('0x0909'),
              place: 'canvasRenderer.js:53',
              message: "can not return capture blob"
            });
          }
        }
      });
    }
  }

  function drawCanvas(data) {
    if (drawer === null) {
      return;
    }

    drawer.drawCanvas(data);
    canvasElement.updatedCanvas = true;

    if (captureFlag) {
      capture();
    }

    if (mapDrawer !== null && minimapInfo.isUpdate) {
      mapDrawer.drawCanvas(data);
      minimapInfo.isUpdate = false;
    }
  }

  var Image2DCanvas = (function () {
    function Constructor(canvas, ctx, size) {
      this.canvas = canvas;
      this.ctx = ctx;
      if (size) {
        this.canvas.width = size.w;
        this.canvas.height = size.h;
      }
    }

    Constructor.prototype = {
      drawCanvas: function (image) {
        this.canvas.width = image.width;
        this.canvas.height = image.height;
        this.ctx.drawImage(image, 0, 0);
      },
      initCanvas: function () {
        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
      },
      destroy: function () { },
    };
    return Constructor;
  })();

  Constructor.prototype = {
    /**
     * This function is init canvasRenderer.
     * @function init
     * @memberof canvasRenderer
     * @example
     *     example: canvasRenderer.init();
     */
    init: function (element) {
      if(element === undefined) {
        throw new umpError({
          channelId: _self.channelId,
          errorCode: fromHex('0x0901'),
          place: 'canvasRenderer.js:47',
          message: "canvas tag element is undefined"
        });
      }

      canvasElement = element;
    },
    /**
     * This function is setting renderer.
     * @function setCanvas
     * @memberof canvasRenderer
     * @param {string} codecType 'H264', 'H265', 'MJPEG'
     * @param {Number} frameSize frame size
     * @param {object} videoInfo videoInfo object
     * @param {string} videoInfo.frameType "I" or "P"
     * @param {number} videoInfo.spsPayload sps
     * @param {number} videoInfo.ppsPayload pps
     * @param {number} videoInfo.framerate frame rate
     * @param {number} videoInfo.width width for mjpeg
     * @param {number} videoInfo.height height for mjpeg
     * @example
     *     example: canvasRenderer.setCanvas(codecType, frameSize);
     */
    setCanvas: function (codec, videoInfo) {
      if (drawer === null) {
        size = new Size(videoInfo.width, videoInfo.height);
        codecType = codec;
        switch (codecType) {
          case 'H264':
          case 'H265':
            drawer = new YUVWebGLCanvas(canvasElement, canvasElement.getContext("webgl"), size);
            break;
          case 'MJPEG':
            drawer = new Image2DCanvas(canvasElement, canvasElement.getContext("2d"), size);
            break;
          default:
            break;
        }
      }
    },
    /**
     * This function is setting renderer.
     * @function setCaptureData
     * @memberof canvasRenderer
     * @param {string} name capture fileName
     * @example
     *     example: canvasRenderer.setCaptureName(name);
     */
    setCaptureName: function (name) {
      captureFlag = true;
      fileName = name;
    },
    /**
     * This function is setting renderer.
     * @function draw
     * @memberof canvasRenderer
     * @param {Uint8Array} frameData frame array data
     * @param {object} videoInfo videoInfo object
     * @param {string} videoInfo.frameType "I" or "P"
     * @param {number} videoInfo.spsPayload sps
     * @param {number} videoInfo.ppsPayload pps
     * @param {number} videoInfo.framerate frame rate
     * @param {number} videoInfo.width width for mjpeg
     * @param {number} videoInfo.height height for mjpeg
     * @param {number} videoInfo.sizeInfo sizeInfo for H264, H265
     * @example
     *     example: canvasRenderer.draw(frameData, videoInfo);
     */
    draw: function (frameData, videoInfo) {
      if (codecType === 'MJPEG') {
        var image = new Image(videoInfo.width, videoInfo.height);
        image.onload = function () {
          drawCanvas(image);
          window.URL.revokeObjectURL(image.src);
        }
        image.src = window.URL.createObjectURL(new Blob([frameData.buffer]));
      } else {
        drawCanvas(frameData);
      }
    },
    /**
     * This function is init canvas.
     * @function renewCanvas
     * @memberof canvasRenderer
     * @example
     *     example: canvasRenderer.renewCanvas();
     */
    renewCanvas: function () {
      if ( drawer !== null) {
        drawer.initCanvas();
      }
    },
    /**
     * This function is control digital zoom.
     * @function digitalZoom
     * @memberof canvasRenderer
     * @param {object} bufferData Zoom data (x, y, z)
     * @example
     *     example: canvasRenderer.digitalZoom(bufferData);
     */
    digitalZoom: function (bufferData) {
      if (drawer !== null) {
        drawer.updateVertexArray(bufferData);
      }
    },
    destroy : function() {
      canvasElement = null;
      if (drawer !== null) {
        drawer.initCanvas();
        drawer.destroy();
        drawer = null;
      }
      if (mapDrawer !== null) {
        mapDrawer.initCanvas();
        mapDrawer.destroy();
        mapDrawer = null;
      }
    },
    updateMinimapInfo : function(info) {
      var command = info.mode;
      if ( minimapInfo.element === null && typeof info.target !== 'undefined' && info.target !==null) {
        minimapInfo.element = info.target;
        var mapWidth = minimapInfo.element.getAttribute('width');
        var mapHeight = minimapInfo.element.getAttribute('height');
        var _size = null;
        if ( mapDrawer === null ) {
          _size = new Size(size.w, size.h, mapWidth, mapHeight);
          switch (codecType) {
            case 'H264':
            case 'H265':
              mapDrawer = new YUVWebGLCanvas(minimapInfo.element, minimapInfo.element.getContext('webgl'), _size);
              break;
            case 'MJPEG':
              mapDrawer = new Image2DCanvas(minimapInfo.element, minimapInfo.element.getContext('2d'), _size);
              break;
          }
        }
      }
      if ( command === 'draw') {
        minimapInfo.isUpdate = true;
      } else if( command ==='off'){
        mapDrawer = null;
        minimapInfo = {
          isUpdate : false,
          element : null
        };
      }
    },
    /**
     * This function add event listener on canvasRenderer.js
     * @function addEventListener
     * @memberof CanvasRenderer
     * @example
     *     canvasRenderer.addEventListener('capture', <callback function>);
     */
    addEventListener: function (event, callback) {
      switch (event) {
        case 'capture':
          this.eventCaptureCallback = callback;
          break;
      }
    },
  }

  /**
   * This property is channel number.
   * @function channelId
   * @memberof CanvasRenderer
   * @example
   *    CanvasRenderer.channelId = ;
   */
  Object.defineProperty(this, "channelId", {
    get: function() {
        return channel;
    },
    set: function(v) {
      channel = v;
    },
  });

  return new Constructor();
}
/* global inheritObject, CanvasRenderer, StepBufferList, VideoPlayer, PlaybackBufferManager */

/**
 * CanvasTagPlayer
 * @class CanvasTagPlayer
 */
function CanvasTagPlayer() {
  "use strict";

  var version = '1.0.0';
  var canvastag_log = log4javascript.getLogger('player:canvas');

  //common variables
  var renderer = null;
  var canvasElement = null;
  var rendererCheck = false;

  //callback variables
  var videoSizeCallback = null;
  var errorCallback = null;

  //timeStamp variables
  var timeStampCallback = null;

  //decoder variables
  var decoderWorker = null;
  var frameCount = 0;

  //step variables
  var stepVideoList = null;

  var bufferManager = null;
  var latency, odd;
  var displayDecodingTime = false;
  var miniMapElement = null;
  var _self;

  function Constructor() {
    _self = this;
  }

  function createDecoderWorker(codecType, videoInfo) {
    decoderWorker = new Worker('./media/ump/Worker/VideoDecoder/decoderWorker.js');
    decoderWorker.onmessage = decoderWorkerMessage;

    var message = {
      'channelId': _self.channelId,
      'type': 'createDecoder',
      'data': codecType
    };
    decoderWorker.postMessage(message);

    // reference t size from getAPI_ff3.c
    message = {
      'type': 'setOutputSize',
      'data': (videoInfo.width * videoInfo.height) +
                ((videoInfo.width * videoInfo.height) / 4) +
                ((videoInfo.width * videoInfo.height) / 4)
    };
    decoderWorker.postMessage(message);

    // set maximum frame rate
    message = {
      'type': 'setFrameRate',
      'data': _self.getFrameRate()
    };
    decoderWorker.postMessage(message);

    // set maximum frame rate
    message = {
      'type': 'useDropPacket',
      'data': _self.isDropPacket()
    };
    decoderWorker.postMessage(message);

  }

  var checkedPlayer = false;

  function checkPlayer(streamData, videoInfo) {
    if (checkedPlayer === true) {
      return;
    }
    if (streamData.codecType !== 'MJPEG') {
      createDecoderWorker(streamData.codecType, videoInfo, streamData.codecType);
    }
    renderer.setCanvas(streamData.codecType, videoInfo);
    checkedPlayer = true;
  }

  function checkFrameDrop(codec, dropOut) {
    if (codec === 'MJPEG') {
      if (dropOut === 1 ) {
        frameCount = 0;
      } else {
        frameCount += 1;
      }
      if (dropOut > 1 && frameCount % dropOut === 0 ) {
        return true;
      }
    }
    return false;
  }

  function decoderWorkerMessage(event) {
    var message = event.data;
    switch (message.type) {
      case 'decoded':
        if (bufferManager !== null) {
          Constructor.prototype.popNextFrame(true);
        }

        var specialWidth = [192, 368, 608, 1088, 1472, 1952, 3008];

        for (var i in specialWidth) {
          if (message.data.width === specialWidth[i]) {
            message.data.width -= 8;
            break;
          }
        }

        if(canvasElement !== null && canvasElement !== undefined) {
          if (message.data.width === canvasElement.width && message.data.height === canvasElement.height) {
            renderer.draw(message.data.frame);
            resizeCheck(message.data.width, message.data.height);
            if (displayDecodingTime) {
              if (message.data.receiveClock !== undefined && message.data.receiveClock !== null) {
                latency = performance.now() - message.data.receiveClock;
                canvastag_log.debug("decoding latency: ", latency);
              }
            }
          } else {
            // try to change canvas element size to output image size
            if(canvasElement !== null && canvasElement !== undefined) {
              canvastag_log.warn("Ths canvas element size not matched with image size (" + canvasElement.width + "" + canvasElement.height + "), changed canvas element size (" +   message.data.width + "," + message.data.height + ")");
              canvasElement.setAttribute('width', message.data.width);
              canvasElement.setAttribute('height', message.data.height);
            } else {
              // TODO: if canvas element is not defined, check tag's width and height attribute
              canvastag_log.warn("TODO: if canvas element is not defined, check tag's width and height attribute");
              throw new umpError({
                channelId: _self.channelId,
                errorCode: fromHex('0x0904'),
                place: 'canvasTagPlayer.js:113',
                message: "The canvas size does not matched with image size"
              });
            }
          }
        } else {
          // TODO: if canvas element is not defined, check tag's width and height attribute
          canvastag_log.warn("TODO: if canvas element is not defined, check tag's width and height attribute");
          throw new umpError({
            channelId: _self.channelId,
            errorCode: fromHex('0x0904'),
            place: 'canvasTagPlayer.js:113',
            message: "The canvas size does not matched with image size"
          });
        }

        if (message.data.time !== null) {
          message.data.time.channelId = _self.channelId;
          timeStampCallback(message.data.time);
        }
        message.data.frame = null;
        message.data = null;
        break;
      case 'notReady':
        if (bufferManager !== null) {
          bufferManager.front();
          setTimeout(function () {
            Constructor.prototype.popNextFrame(false);
          }, 500);
        }
        break;
      case 'terminated':
        if (decoderWorker !== null && typeof decoderWorker !== "undefined") {
          decoderWorker.terminate();
          decoderWorker = null;

          canvastag_log.info("terminated decoder worker");
        }

        if (bufferManager !== null && typeof bufferManager !== "undefined") {
          bufferManager = null;
          canvastag_log.info("clear buffer Manager");
        }
        break;
      default:
        canvastag_log.debug("canvasTagPlayer::decoderWorker unknown data = " + message.data);
        throw new umpError({
          channelId: _self.channelId,
          errorCode: fromHex('0x0905'),
          place: 'canvasTagPlayer.js:168',
          message: "The decoder worker returned unknown data	"
        });
    }
  }

  function stepPlay(cmd) {
    var node = null;
    if (cmd === "forward") {
      node = stepVideoList.forward();
    } else {
      node = stepVideoList.backward();
    }

    if (node === null) {
      renderer.renewCanvas();
      return false;
    }

    Constructor.prototype.onVideoData(node.playMode, node.streamData, node.videoInfo);
    return true;
  }

  function resizeCheck(width, height) {
    if (rendererCheck === false) {
      rendererCheck = true;
      if (window.jQuery) {
        canvastag_log.info("jquery $(window).trigger('resize')");
        $(window).trigger('resize');
      } else {
        canvastag_log.info("windows.dispatchEvent('resizeEvent')");
        var evt = document.createEvent("HTMLEvents");
        evt.initEvent('resize', true, false);
        window.dispatchEvent(evt);
      }
      //videoSizeCallback(this.channelId, "canvas", width, height);
    }
  }

  function onHandleContextLost(event) {
    canvastag_log.debug("WEBGL Context Lost detect!");
    if ( typeof event !== 'undefined') {
      event.preventDefault();
    }
    errorCallback({
      channelId: _self.channelId,
      errorCode: fromHex('0x0902'),
      place: 'canvasTagPlayer.js:178',
      description: "CanvasTagPlayer: WebGL Context Lost detect"
    });
  }

  Constructor.prototype = inheritObject(new VideoPlayer(), {
    /**
     * This function is initialize CanvasTagPlayer.
     * @function init
     * @memberof CanvasTagPlayer
     * @example
     *     example: CanvasTagPlayer.init(element);
     */
    init: function (element) {
      canvastag_log.debug("CanvasTagPlayer::init");
      canvasElement = element.cloneNode(true);
      element.parentNode.replaceChild(canvasElement, element);

      renderer = new CanvasRenderer();
      renderer.channelId = this.channelId;
      renderer.addEventListener('capture', this.eventCaptureCallback);
      renderer.init(canvasElement);
      stepVideoList = new StepBufferList();
      canvasElement.addEventListener('webglcontextlost', onHandleContextLost, false);
    },
    /**
     * Pop next frame and Call onVideoData
     * @function popNextFrame
     * @memberof CanvasTagPlayer
     */
    popNextFrame: function (isDecoderReady) {
      if ( bufferManager === null || 
          bufferManager.isReadyToPop() === false) {
        return;
      }
      var ret = true;
      ret = bufferManager.pop(isDecoderReady);
      if (typeof ret === 'object') {
        this.onVideoData(ret.playMode, ret.streamData,
          ret.videoInfo);
      }
    },
    /**
     * This function is receive video data.
     * @function onVideoData
     * @memberof CanvasTagPlayer
     * @param {string} playMode "Live" or "Playback"
     * @param {object} streamData streamData object
     * @param {string} streamData.codecType "MJPEG", "H264", "H265"
     * @param {Uint8Array} streamData.frameData Depacketized frame data
     * @param {object} streamData.timeStamp Timestamp data object
     * @param {number} streamData.timeStamp.rtpTimeStamp RTP timeStamp
     * @param {number} streamData.timeStamp.timestamp Frame timestamp
     * @param {number} streamData.timeStamp.timestamp_usec Frame timestamp millisecond
     * @param {number} streamData.timeStamp.timezone timezone
     * @param {object} videoInfo videoInfo object
     * @param {string} videoInfo.frameType "I" or "P"
     * @param {number} videoInfo.spsPayload sps
     * @param {number} videoInfo.ppsPayload pps
     * @param {number} videoInfo.framerate frame rate
     * @param {number} videoInfo.width width for mjpeg
     * @param {number} videoInfo.height height for mjpeg
     * @example
     *     example: CanvasTagPlayer.onVideoData(playMode, streamData, videoInfo);
     */
    onVideoData: function (playMode, streamData, videoInfo) {
      checkPlayer(streamData, videoInfo);

      if (checkFrameDrop(streamData.codecType, videoInfo.dropOut) === true) {
        timeStampCallback(streamData.timeStamp);
        return;
      }

      if (renderer !== null) {
        if (streamData.codecType === 'MJPEG') {
          renderer.draw(streamData.frameData, videoInfo);
          resizeCheck(videoInfo.width, videoInfo.height);
          if (playMode === "Playback") {
            streamData.timeStamp.channelId = _self.channelId;
            timeStampCallback(streamData.timeStamp);
          }
        } else {
          var message = {
            'type': 'decode',
            'data': {
              'playMode': playMode,
              'timeStamp': (playMode === "Playback" ? streamData.timeStamp : null),
              'frameData': streamData.frameData,
              'frameType': videoInfo.frameType,
              'width': videoInfo.width,
              'height': videoInfo.height,
              'receiveClock': streamData.receiveClock
            }
          };

          decoderWorker.postMessage(message);
        }
      } else {
        canvastag_log.debug("CanvasTagPlayer::drawer is null");
        throw new umpError({
          channelId: this.channelId,
          errorCode: fromHex('0x0903'),
          place: 'canvasTagPlayer.js:290',
          message: "CanvasTagPlayer: canvas tag renderer is null"
        });
      }
    },
    /**
     * This function is to stack frame data for step play.
     * @function bufferingVideoData
     * @memberof CanvasTagPlayer
     * @param {string} playMode "Live" or "Playback"
     * @param {object} streamData streamData object
     * @param {string} streamData.codecType "MJPEG", "H264", "H265"
     * @param {Uint8Array} streamData.frameData Depacketized frame data
     * @param {object} streamData.timeStamp Timestamp data object
     * @param {number} streamData.timeStamp.rtpTimeStamp RTP timeStamp
     * @param {number} streamData.timeStamp.timestamp Frame timestamp
     * @param {number} streamData.timeStamp.timestamp_usec Frame timestamp millisecond
     * @param {number} streamData.timeStamp.timezone timezone
     * @param {object} videoInfo videoInfo object
     * @param {string} videoInfo.frameType "I" or "P"
     * @param {number} videoInfo.spsPayload sps
     * @param {number} videoInfo.ppsPayload pps
     * @param {number} videoInfo.framerate frame rate
     * @param {number} videoInfo.width width for mjpeg
     * @param {number} videoInfo.height height for mjpeg
     * @param {string} stepCmd "forward" or "backward"
     * @example
     *     example: CanvasTagPlayer.bufferingVideoData(playMode, streamData, videoInfo);
     */
    bufferingVideoData: function (playMode, streamData, videoInfo, stepCmd) {
      checkPlayer(streamData, videoInfo);

      return stepVideoList.push(playMode, streamData, videoInfo);
    },
    /**
     * This function make BufferManager to control playback stream.
     * @function sendToBufferManager
     * @memberof CanvasTagPlayer
     * @param {string} playMode "Live" or "Playback"
     * @param {object} streamData streamData object
     * @param {string} streamData.codecType "MJPEG", "H264", "H265"
     * @param {Uint8Array} streamData.frameData Depacketized frame data
     * @param {object} streamData.timeStamp Timestamp data object
     * @param {number} streamData.timeStamp.rtpTimeStamp RTP timeStamp
     * @param {number} streamData.timeStamp.timestamp Frame timestamp
     * @param {number} streamData.timeStamp.timestamp_usec Frame timestamp millisecond
     * @param {number} streamData.timeStamp.timezone timezone
     * @param {object} videoInfo videoInfo object
     * @param {string} videoInfo.frameType "I" or "P"
     * @param {number} videoInfo.spsPayload sps
     * @param {number} videoInfo.ppsPayload pps
     * @param {number} videoInfo.framerate frame rate
     * @param {number} videoInfo.width width for mjpeg
     * @param {number} videoInfo.height height for mjpeg
     * @example
     *     example: CanvasTagPlayer.sendToBufferManager(playMode, streamData, videoInfo);
     */
    sendToBufferManager: function (playMode, streamData, videoInfo, errorCallback) {
      if (bufferManager === null) {
        bufferManager = new PlaybackBufferManager();
        bufferManager.init(errorCallback);
        bufferManager.channelId = this.channelId;
      }
      checkPlayer(streamData, videoInfo);

      var bufferInfo = {
        'playMode': playMode,
        'streamData': streamData,
        'videoInfo': videoInfo
      };
      var results = bufferManager.push(bufferInfo);

      if (results === true) {
        this.popNextFrame(false);
      }
    },
    /**
     * This function is save image file.
     * @function capture
     * @memberof CanvasTagPlayer
     * @example
     *     example: CanvasTagPlayer.capture(fileName);
     */
    capture: function (fileName) {
      renderer.setCaptureName(fileName);
    },
    /**
     * This function is to set timestamp callback function.
     * @function setTimeStampCallback
     * @memberof CanvasTagPlayer
     * @param {function} func timestamp callback function
     * @example
     *     example: CanvasTagPlayer.setTimeStampCallback(function);
     */
    setTimeStampCallback: function (func) {
      timeStampCallback = func;
    },
    /**
     * This function is set resize callback function.
     * @function setResizeCallback
     * @memberof CanvasTagPlayer
     * @param {function} func resize callback function
     * @example
     *     example: CanvasTagPlayer.setResizeCallback(func);
     */
    setResizeCallback: function (func) {
      videoSizeCallback = func;
    },
    /**
     * This function is set error callback function.
     * @function setErrorCallback
     * @memberof CanvasTagPlayer
     * @param {function} func error callback function
     * @example
     *     example: CanvasTagPlayer.setErrorCallback(func);
     */
    setErrorCallback: function (func) {
      errorCallback = func;
    },
    /**
     * This function is play CanvasTagPlayer.
     * @function play
     * @memberof CanvasTagPlayer
     * @example
     *     example: CanvasTagPlayer.play();
     */
    play: function () {
      canvastag_log.debug("CanvasTagPlayer::play");
    },
    /**
     * This function is pause CanvasTagPlayer.
     * @function pause
     * @memberof CanvasTagPlayer
     * @example
     *     example: CanvasTagPlayer.pause();
     */
    pause: function () {
      canvastag_log.debug("CanvasTagPlayer::pause");
      if (bufferManager !== null) {
        bufferManager.pause();
      }
    },
    resume: function () {
      canvastag_log.debug("CanvasTagPlayer::resume");
      if (bufferManager !== null) {
        var ret = bufferManager.resume();
        if (ret === true) {
          this.popNextFrame(false);
        }
      }
    },
    /**
     * This function is stop CanvasTagPlayer.
     * @function stop
     * @memberof CanvasTagPlayer
     * @example
     *     example: CanvasTagPlayer.stop();
     */
    stop: function () {
      canvastag_log.debug("CanvasTagPlayer::stop");
    },
    /**
     * This function is control step play for step begin
     * @function controlStepPlay
     * @memberof CanvasTagPlayer
     * @param {function} object timestamp
     * @param {number} object.timestamp Frame timestamp
     * @param {number} object.timestamp_usec Frame timestamp millisecond
     * @param {number} object.timezone timezone.
     * @param {string} stepCmd "forward" or "backward"
     * @example
     *     example: CanvasTagPlayer.controlStepPlay(timestamp, stepCmd);
     */
    controlStepPlay: function (timestamp, stepCmd) {
      stepVideoList.searchTimestamp(timestamp);
      var node = stepVideoList.findIFrame(stepCmd);
      this.onVideoData(node.playMode, node.streamData, node.videoInfo);
    },
    /**
     * This function is forward CanvasTagPlayer.
     * @function forward
     * @memberof CanvasTagPlayer
     * @example
     *     example: CanvasTagPlayer.forward();
     */
    forward: function () {
      return stepPlay("forward");
    },
    /**
     * This function is backward CanvasTagPlayer.
     * @function backward
     * @memberof CanvasTagPlayer
     * @example
     *     example: CanvasTagPlayer.backward();
     */
    backward: function () {
      return stepPlay("backward");
    },
    clearBuffer : function() {
      stepVideoList.bufferClear();
    },
    /**
     * This function is control digital zoom.
     * @function digitalZoom
     * @memberof CanvasTagPlayer
     * @param {object} bufferData Zoom data (x, y, z)
     * @example
     *     example: CanvasTagPlayer.digitalZoom(bufferData);
     */
    digitalZoom: function (bufferData) {
      if (renderer !== null && rendererCheck) {
        renderer.digitalZoom(bufferData);
      }
    },
    updateMiniMapInfo : function(data) {
      renderer.updateMinimapInfo (data)
    },
    /**
     * This function is close CanvasTagPlayer.
     * @function close
     * @memberof CanvasTagPlayer
     * @example
     *     example: CanvasTagPlayer.close();
     */
    close: function () {
      canvastag_log.debug("CanvasTagPlayer::close");
      if (canvasElement !== null && canvasElement !== undefined) {
        canvasElement.removeEventListener('webglcontextlost', onHandleContextLost, false);
        canvasElement = null;
        canvastag_log.info("clear canvas elementss");
      }

      if (renderer !== null && typeof renderer !== "undefined") {
        renderer.renewCanvas();
        renderer.destroy();
        canvastag_log.debug("destory renderer");
      }

      if (decoderWorker !== null) {
        var message = {
          'channelId': _self.channelId,
          'type': 'terminate'
        };
        decoderWorker.postMessage(message);
        canvastag_log.debug("request terminate decoder worker");
      } else {
        canvastag_log.debug("decoder worker already terminated");
      }
    }
  });

  return new Constructor();
}

var StepBufferList = function () {
  "use strict";

  var BUFFERING_LENGTH = 240;
  var listLength = 0;
  var curIndex = 0;
  var stepList = [];

  function Constructor() {}

  function clear() {
    while (stepList.length) {
      stepList.pop();
    }
    curIndex = 0;
    listLength = 0;
  }

  Constructor.prototype = inheritObject(new BufferList(), {
    /**
     * This function is to stack step buffer list.
     * @function push
     * @memberof stepBufferList
     * @param {string} playMode "Live" or "Playback"
     * @param {object} streamData streamData object
     * @param {string} streamData.codecType "MJPEG", "H264", "H265"
     * @param {Uint8Array} streamData.frameData Depacketized frame data
     * @param {object} streamData.timeStamp Timestamp data object
     * @param {number} streamData.timeStamp.rtpTimeStamp RTP timeStamp
     * @param {number} streamData.timeStamp.timestamp Frame timestamp
     * @param {number} streamData.timeStamp.timestamp_usec Frame timestamp millisecond
     * @param {number} streamData.timeStamp.timezone timezone.
     * @param {object} videoInfo videoInfo object
     * @param {string} videoInfo.frameType "I" or "P"
     * @param {number} videoInfo.spsPayload sps
     * @param {number} videoInfo.ppsPayload pps
     * @param {number} videoInfo.framerate frame rate
     * @param {number} videoInfo.width width for mjpeg
     * @param {number} videoInfo.height height for mjpeg
     * @example
     *     example: stepBufferList.push(playMode, streamData, videoInfo);
     */
    push: function (playMode, streamData, videoInfo) {
      if (stepList.length ===1) {
        this.setBufferingLength(videoInfo.framerate*4);
      }
      if (stepList.length < BUFFERING_LENGTH) {
        var node = {
          'playMode': playMode,
          'streamData': streamData,
          'videoInfo': videoInfo
        };
        node.streamData.frameData = new Uint8Array(streamData.frameData);

        stepList.push(node);
        listLength = stepList.length;
      }
      
      return (stepList.length >= BUFFERING_LENGTH) ? false:true;
    },
    /**
     * This function is to forward
     * @function forward
     * @memberof stepBufferList
     * @example
     *     example: stepBufferList.forward();
     */
    forward: function () {
      if (++curIndex < listLength) {
        return stepList[curIndex];
      }
      clear();
      return null;
    },
    /**
     * This function is to backward
     * @function backward
     * @memberof stepBufferList
     * @example
     *     example: stepBufferList.backward();
     */
    backward: function () {
      while (--curIndex >= 0) {
        var node = stepList[curIndex];
        if (node.videoInfo.frameType === "I" || node.streamData.codecType === "MJPEG") {
          return node;
        }
      }
      clear();
      return null;
    },
    /**
     * This function is to set maximum buffer list size.
     * @function searchTimestamp
     * @memberof stepBufferList
     * @param {number} length list size
     * @example
     *     example: stepBufferList.searchTimestamp(number);
     */
    searchTimestamp: function (frameTimestamp) {
      for (var i = 0; i < listLength; i++) {
        var node = stepList[i];
        if ((node.streamData.timeStamp.timestamp === frameTimestamp.timestamp) &&
          (node.streamData.timeStamp.timestamp_usec === frameTimestamp.timestamp_usec)) {
          curIndex = i;
          break;
        } else if (node.streamData.timeStamp.timestamp > frameTimestamp.timestamp) {
          curIndex = i;
          break;
        }
      }
    },
    /**
     * This function is to find I-frame which near current time stamp.
     * @function findIFrame
     * @memberof stepBufferList
     * @param {number} cmd "forward" or "backward"
     * @example
     *     example: stepBufferList.findIFrame(cmd);
     */
    findIFrame: function (cmd) {
      while(curIndex < stepList.length && curIndex >=0) {
        if( cmd === 'forward') {
          curIndex++;
        } else {
          curIndex--;
        }
        if (curIndex < 0) {
          curIndex = 0;
        }
        if (stepList[curIndex].videoInfo.frameType === "I") {
          return stepList[curIndex];
        }
      }
    },
    /**
     * This function is to set buffering length.
     * @function setBufferingLength
     * @memberof stepBufferList
     * @param {number} length length num.
     * @example
     *     example: stepBufferList.setBufferingLength(length);
     */
    setBufferingLength: function (length) {
      BUFFERING_LENGTH = length;
      if (BUFFERING_LENGTH > 240 ) {
        BUFFERING_LENGTH = 240;
      } else if ( BUFFERING_LENGTH < 6) {
        BUFFERING_LENGTH = 6;
      }
    },
    bufferClear : function() {
      clear();
    }
  });

  return new Constructor();
};
/*
 * This file wraps several WebGL constructs and provides a simple, single texture based WebGLCanvas as well as a
 * specialized YUVWebGLCanvas that can handle YUV->RGB conversion.
 */

/**
 * Represents a WebGL shader script.
 */
var Script = (function script() {
  "use strict";

  function Constructor() {}

  Constructor.createFromElementId = function (id) {
    var script = document.getElementById(id);

    // Didn't find an element with the specified ID, abort.
    assert(script, "Could not find shader with ID: " + id);

    // Walk through the source element's children, building the shader source string.
    var source = "";
    var currentChild = script.firstChild;
    while (currentChild) {
      if (currentChild.nodeType === 3) {
        source += currentChild.textContent;
      }
      currentChild = currentChild.nextSibling;
    }

    var res = new Constructor();
    res.type = script.type;
    res.source = source;
    return res;
  };

  Constructor.createFromSource = function (type, source) {
    var res = new Constructor();
    res.type = type;
    res.source = source;
    return res;
  };
  return Constructor;
})();

/**
 * Represents a WebGL shader object and provides a mechanism to load shaders from HTML
 * script tags.
 */
var Shader = (function shader() {
  function Constructor(gl, script) {
    this.gl = gl;
  // Now figure out what type of shader script we have, based on its MIME type.
    if (script.type === "x-shader/x-fragment") {
      this.shader = gl.createShader(gl.FRAGMENT_SHADER);
    } else if (script.type === "x-shader/x-vertex") {
      this.shader = gl.createShader(gl.VERTEX_SHADER);
    } else {
      error("Unknown shader type: " + script.type);
      return;
    }

    // Send the source to the shader object.
    gl.shaderSource(this.shader, script.source);
    // Compile the shader program.
    gl.compileShader(this.shader);
    // See if it compiled successfully.
    if (!gl.getShaderParameter(this.shader, gl.COMPILE_STATUS)) {
      error("An error occurred compiling the shaders: " + gl.getShaderInfoLog(this.shader));
      return;
    }
  }
  Constructor.prototype = {
    destroy : function() {
      this.gl.deleteShader(this.shader);
    }
  };
  return Constructor;
})();

var Program = (function () {
  function Constructor(gl) {
    this.gl = gl;
    this.program = this.gl.createProgram();
  }
  Constructor.prototype = {
    attach: function (shader) {
      this.gl.attachShader(this.program, shader.shader);
    },
    link: function () {
      this.gl.linkProgram(this.program);
      // If creating the shader program failed, alert.
      assert(this.gl.getProgramParameter(this.program, this.gl.LINK_STATUS),
        "Unable to initialize the shader program.");
    },
    use: function () {
      this.gl.useProgram(this.program);
    },
    getAttributeLocation: function (name) {
      return this.gl.getAttribLocation(this.program, name);
    },
    setMatrixUniform: function (name, array) {
      var uniform = this.gl.getUniformLocation(this.program, name);
      this.gl.uniformMatrix4fv(uniform, false, array);
    },
    destroy : function() {
      this.gl.deleteProgram(this.program);
    }
  };
  return Constructor;
})();

/**
 * Represents a WebGL texture object.
 */
var Texture = (function texture() {
  var textureIDs = null;

  function Constructor(gl, size, format) {
    this.gl = gl;
    this.size = size;
    this.texture = gl.createTexture();
    gl.bindTexture(gl.TEXTURE_2D, this.texture);
    this.format = format ? format : gl.LUMINANCE;
    gl.texImage2D(gl.TEXTURE_2D, 0, this.format, size.w, size.h, 0, this.format, gl.UNSIGNED_BYTE, null);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
  }

  Constructor.prototype = {
    fill: function (textureData, useTexSubImage2D) {
      var gl = this.gl;
      assert(textureData.length >= this.size.w * this.size.h,
        "Texture size mismatch, data:" + textureData.length + ", texture: " + this.size.w * this.size.h);
      gl.bindTexture(gl.TEXTURE_2D, this.texture);
      if (useTexSubImage2D) {
        gl.texSubImage2D(gl.TEXTURE_2D, 0, 0, 0, this.size.w, this.size.h, this.format, gl.UNSIGNED_BYTE, textureData);
      } else {
        // texImage2D seems to be faster, thus keeping it as the default
        gl.texImage2D(gl.TEXTURE_2D, 0, this.format, this.size.w, this.size.h, 0, this.format, gl.UNSIGNED_BYTE, textureData);
      }
    },
    bind: function (n, program, name) {
      var gl = this.gl;
      if (!textureIDs) {
        textureIDs = [gl.TEXTURE0, gl.TEXTURE1, gl.TEXTURE2];
      }
      gl.activeTexture(textureIDs[n]);
      gl.bindTexture(gl.TEXTURE_2D, this.texture);
      gl.uniform1i(gl.getUniformLocation(program.program, name), n);
    },
    destroy : function() {
      this.gl.deleteTexture(this.texture);
    }
  };
  return Constructor;
})();

/**
 * Represents a WebGL texture object for image element.
 */
var ImageTexture = (function () {
  function Constructor(gl, size, format) {
    Texture.call(this, gl, size, format);
  }
  Constructor.prototype = inherit(Texture, {
    fill: function (textureData, useTexSubImage2D) {
      var gl = this.gl;
      gl.bindTexture(gl.TEXTURE_2D, this.texture);
      if (useTexSubImage2D) {
        gl.texSubImage2D(gl.TEXTURE_2D, 0, 0, 0, this.size.w, this.size.h, this.format, gl.UNSIGNED_BYTE, textureData);
      } else {
        // texImage2D seems to be faster, thus keeping it as the default
        gl.texImage2D(gl.TEXTURE_2D, 0, this.format, this.format, gl.UNSIGNED_BYTE, textureData);
        //console.log('fill ! ' + this.format);
      }
    }
  });
  return Constructor;
})();

/**
 * Generic WebGL backed canvas that sets up: a quad to paint a texture on, appropriate vertex/fragment shaders,
 * scene parameters and other things. Specialized versions of this class can be created by overriding several
 * initialization methods.
 *
 * <code>
 * var canvas = new WebGLCanvas(document.getElementById('canvas'), new Size(512, 512);
 * canvas.texture.fill(data);
 * canvas.drawScene();
 * </code>
 */
var WebGLCanvas = (function () {
  var vertexShaderScript = Script.createFromSource("x-shader/x-vertex", text([
    "attribute vec3 aVertexPosition;",
    "attribute vec2 aTextureCoord;",
    "uniform mat4 uMVMatrix;",
    // "uniform mat4 uPMatrix;",
    "varying highp vec2 vTextureCoord;",
    "void main(void) {",
    // "  gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);",
    "  gl_Position = uMVMatrix * vec4(aVertexPosition, 1.0);",
    "  vTextureCoord = aTextureCoord;",
    "}"
    ]));
  var fragmentShaderScript = Script.createFromSource("x-shader/x-fragment", text([
    "precision highp float;",
    "varying highp vec2 vTextureCoord;",
    "uniform sampler2D texture;",
    "void main(void) {",
    "  gl_FragColor = texture2D(texture, vTextureCoord);",
    "}"
    ]));

  var specialWidth = [192,368,608,1088,1472,1952,3008];
  var BROWSERTYPE = BrowserDetect(); //ie, safari, chrome, firefox  

  function Constructor(canvas, gl, size, useFrameBuffer) {
    this.canvas = canvas;
    this.size = size;
    this.gl = gl;
        
    var isDevideBy16 = true;
    for(var i in specialWidth){
      if(size.w === specialWidth[i])
        isDevideBy16 = false;
    }

    if(!isDevideBy16){   //when resolution width is not devided by 16, crop width 8px
      if(size.w === 192){
        this.canvas.width = (typeof size.viewWidth !== 'undefined'? size.viewWidth :
                          size.w - 12 );  
      }else{
        this.canvas.width = typeof size.viewWidth !== 'undefined'? size.viewWidth : size.w - 8;  
      }
    }
    else{
      this.canvas.width = typeof size.viewWidth !== 'undefined'? size.viewWidth : size.w;
    }

    this.canvas.height = typeof size.viewHeight !== 'undefined'? size.viewHeight : size.h;
    this.onInitWebGL();
    this.onInitShaders();
    initBuffers.call(this);
    if (useFrameBuffer) {
      initFramebuffer.call(this);
    }
    this.onInitTextures();
    initScene.call(this);
  }

  /**
   * Initialize a frame buffer so that we can render off-screen.
   */
  function initFramebuffer() {
    var gl = this.gl;
    // Create framebuffer object and texture.
    this.framebuffer = gl.createFramebuffer();
    gl.bindFramebuffer(gl.FRAMEBUFFER, this.framebuffer);
    this.framebufferTexture = new Texture(this.gl, this.size, gl.RGBA);
    // Create and allocate renderbuffer for depth data.
    this.renderbuffer = gl.createRenderbuffer();
    gl.bindRenderbuffer(gl.RENDERBUFFER, this.renderbuffer);
    gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_COMPONENT16, 
                          typeof this.size.viewWidth !== 'undefined' ? this.size.viewWidth : this.size.w,
                          typeof this.size.viewHeight !== 'undefined' ? this.size.viewHeight : this.size.h);
    // Attach texture and renderbuffer to the framebuffer.
    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, this.framebufferTexture.texture, 0);
    gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.RENDERBUFFER, this.renderbuffer);
  }

  /**
   * Initialize vertex and texture coordinate buffers for a plane.
   */
  function initBuffers() {
    var tmp;
    var gl = this.gl;
    // Create vertex position buffer.
    this.quadVPBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, this.quadVPBuffer);
    tmp = [
      1.0, 1.0, 0.0,
     -1.0, 1.0, 0.0,
      1.0, -1.0, 0.0,
     -1.0, -1.0, 0.0];

    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(tmp), gl.STATIC_DRAW);
    this.quadVPBuffer.itemSize = 3;
    this.quadVPBuffer.numItems = 4;

    /*
     +--------------------+ 
     | -1,1 (1)           | 1,1 (0)
     |                    |
     |                    |
     |                    |
     |                    |
     |                    |
     | -1,-1 (3)          | 1,-1 (2)
     +--------------------+
     */
    var scaleX = 1.0;
    //To avoid gray line of image when width is not devied 16 for Edge browser
    if(BROWSERTYPE === 'edge' && (this.canvas.width !== this.size.w)){
      scaleX = this.canvas.width/this.size.w;
    }
    
    var scaleY = 1.0;
    // Create vertex texture coordinate buffer.
    this.quadVTCBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, this.quadVTCBuffer);
    tmp = [
      scaleX, 0.0,
      0.0, 0.0,
      scaleX, scaleY,
      0.0, scaleY
    ];
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(tmp), gl.STATIC_DRAW);
  }

  function mvIdentity() {
    this.mvMatrix = Matrix.I(4);
  }

  // function mvMultiply(m) {
  //   this.mvMatrix = this.mvMatrix.x(m);
  // }

  // function mvTranslate(m) {
  //   mvMultiply.call(this, Matrix.Translation($V([m[0], m[1], m[2]])).ensure4x4());
  // }

  function setMatrixUniforms() {
    // this.program.setMatrixUniform("uPMatrix", new Float32Array(this.perspectiveMatrix.flatten()));
    this.program.setMatrixUniform("uMVMatrix", new Float32Array(this.mvMatrix.flatten()));
  }

  function initScene() {
    var gl = this.gl;
    // Establish the perspective with which we want to view the
    // scene. Our field of view is 45 degrees, with a width/height
    // ratio of 640:480, and we only want to see objects between 0.1 units
    // and 100 units away from the camera.
    // this.perspectiveMatrix = makePerspective(45, 1, 0.1, 100.0);
    // Set the drawing position to the "identity" point, which is
    // the center of the scene.
    mvIdentity.call(this);
    // Now move the drawing position a bit to where we want to start
    // drawing the square.
    // mvTranslate.call(this, [0.0, 0.0, -2.415]);
    // Draw the cube by binding the array buffer to the cube's vertices
    // array, setting attributes, and pushing it to GL.
    gl.bindBuffer(gl.ARRAY_BUFFER, this.quadVPBuffer);
    gl.vertexAttribPointer(this.vertexPositionAttribute, 3, gl.FLOAT, false, 0, 0);
    // Set the texture coordinates attribute for the vertices.
    gl.bindBuffer(gl.ARRAY_BUFFER, this.quadVTCBuffer);
    gl.vertexAttribPointer(this.textureCoordAttribute, 2, gl.FLOAT, false, 0, 0);
    this.onInitSceneTextures();
    setMatrixUniforms.call(this);

    if (this.framebuffer) {
      // console.log("Bound Frame Buffer");
      gl.bindFramebuffer(gl.FRAMEBUFFER, this.framebuffer);
    }
  }

  Constructor.prototype = {
    toString: function () {
      return "WebGLCanvas Size: " + this.size;
    },
    checkLastError: function (operation) {
      var err = this.gl.getError();
      if (err !== this.gl.NO_ERROR) {
        var name = this.glNames[err];
        name = (name !== undefined) ? name + "(" + err + ")" :
        ("Unknown WebGL ENUM (0x" + value.toString(16) + ")");
        if (operation) {
          console.log("WebGL Error: %s, %s", operation, name);
        } else {
          console.log("WebGL Error: %s", name);
        }
        console.trace();
      }
    },
    onInitWebGL: function () {
      
      if (!this.gl) {
        error("Unable to initialize WebGL. Your browser may not support it.");
      }
      if (this.glNames) {
        return;
      }
      this.glNames = {};
      for (var propertyName in this.gl) {
        if (typeof this.gl[propertyName] === 'number') {
          this.glNames[this.gl[propertyName]] = propertyName;
        }
      }
    },
    onInitShaders: function () {
      this.program = new Program(this.gl);
      this.vertexShader = new Shader(this.gl, vertexShaderScript);
      this.fragmentShader = new Shader(this.gl, fragmentShaderScript);
      this.program.attach(this.vertexShader);
      this.program.attach(this.fragmentShader);
      this.program.link();
      this.program.use();
      this.vertexPositionAttribute = this.program.getAttributeLocation("aVertexPosition");
      this.gl.enableVertexAttribArray(this.vertexPositionAttribute);
      this.textureCoordAttribute = this.program.getAttributeLocation("aTextureCoord");
      this.gl.enableVertexAttribArray(this.textureCoordAttribute);
    },
    onInitTextures: function () {
      var gl = this.gl;
      gl.viewport(0, 0, this.canvas.width, this.canvas.height);
      this.texture = new Texture(gl, this.size, gl.RGBA);
    },
    onInitSceneTextures: function () {
      this.texture.bind(0, this.program, "texture");
    },
    drawScene: function () {
      this.gl.drawArrays(this.gl.TRIANGLE_STRIP, 0, 4);
      //      var curTime = new Date().getTime();
      //      var ms = parseInt(curTime%1000);
      //      var s = parseInt(((curTime/1000)%60));
      //      var m = parseInt(((curTime/1000/60)%60));
      //      console.log('Time : ' + String(" " + m).slice(-2) + 'm ' + String(" " + s).slice(-2) + 's ' + String(" " + ms).slice(-3) + 'ms' + '   after decode');
      //console.log('drawScene ! ' + this.size);
    },
    // updateVertexArray: function(vertexArray) { //wjuncho
    //   this.zoomScene(vertexArray);
    // },
    readPixels: function (buffer) {
      var gl = this.gl;
      gl.readPixels(0, 0, this.size.w, this.size.h, gl.RGBA, gl.UNSIGNED_BYTE, buffer);
    },
    // zoomScene: function (data) {
    //   mvIdentity.call(this);
    //   mvTranslate.call(this, [data[0], data[1], data[2]]);
    //   setMatrixUniforms.call(this);
    //   this.drawScene();
    // },
    destroy : function() {
      var gl = this.gl;
      
      gl.deleteFramebuffer(this.framebuffer);
      this.framebuffer = null;
      gl.deleteRenderbuffer(this.renderbuffer);
      gl.deleteBuffer(this.quadVPBuffer);
      gl.deleteBuffer(this.quadVTCBuffer);
      if (typeof this.vertexShader !== 'undefined') {
        this.vertexShader.destroy();
      }
      if (typeof this.fragmentShader !== 'undefined') {
        this.fragmentShader.destroy();
      }
      if (typeof this.framebufferTexture !== 'undefined') {
        this.framebufferTexture.destroy();
      }
      if (typeof this.YTexture !== 'undefined') {
        this.YTexture.destroy();
      }
      if (typeof this.UTexture !== 'undefined') {
        this.UTexture.destroy();
      }
      if (typeof this.VTexture !== 'undefined') {
        this.VTexture.destroy();
      }

      if (typeof this.texture !== 'undefined') {
        this.texture.destroy();
      }
      if (typeof this.program !== 'undefined') {
        this.program.destroy();
      }
      gl.canvas.width = 1;
      gl.canvas.height = 1;
      
      this.renderbuffer = null;
      this.quadVPBuffer = null;
      this.quadVTCBuffer = null;
      this.vertexShader = null;
      this.fragmentShader = null;
      this.texture = null;
      this.program = null;
      this.gl = null;
      this.canvas = null;
    }
  };
  return Constructor;
})();

var YUVWebGLCanvas = (function () {
  var vertexShaderScript = Script.createFromSource("x-shader/x-vertex", text([
    "attribute vec3 aVertexPosition;",
    "attribute vec2 aTextureCoord;",
    "uniform mat4 uMVMatrix;",
    // "uniform mat4 uPMatrix;",
    "varying highp vec2 vTextureCoord;",
    "void main(void) {",
    // "  gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);",
    "  gl_Position = uMVMatrix * vec4(aVertexPosition, 1.0);",
    "  vTextureCoord = aTextureCoord;",
    "}"
  ]));

  // var fragmentShaderScriptOld = Script.createFromSource("x-shader/x-fragment", text([
  //   "precision highp float;",
  //   "varying highp vec2 vTextureCoord;",
  //   "uniform sampler2D YTexture;",
  //   "uniform sampler2D UTexture;",
  //   "uniform sampler2D VTexture;",

  //   "void main(void) {",
  //   "  vec3 YUV = vec3",
  //   "  (",
  //   "    texture2D(YTexture, vTextureCoord).x * 1.1643828125,   // premultiply Y",
  //   "    texture2D(UTexture, vTextureCoord).x,",
  //   "    texture2D(VTexture, vTextureCoord).x",
  //   "  );",
  //   "  gl_FragColor = vec4",
  //   "  (",
  //   "    YUV.x + 1.59602734375 * YUV.z - 0.87078515625,",
  //   "    YUV.x - 0.39176171875 * YUV.y - 0.81296875 * YUV.z + 0.52959375,",
  //   "    YUV.x + 2.017234375   * YUV.y - 1.081390625,",
  //   "    1",
  //   "  );",
  //   "}"
  // ]));

  // var fragmentShaderScriptSimple = Script.createFromSource("x-shader/x-fragment", text([
  //   "precision highp float;",
  //   "varying highp vec2 vTextureCoord;",
  //   "uniform sampler2D YTexture;",
  //   "uniform sampler2D UTexture;",
  //   "uniform sampler2D VTexture;",

  //   "void main(void) {",
  //   "  gl_FragColor = texture2D(YTexture, vTextureCoord);",
  //   "}"
  // ]));

  var fragmentShaderScript = Script.createFromSource("x-shader/x-fragment", text([
    "precision highp float;",
    "varying highp vec2 vTextureCoord;",
    "uniform sampler2D YTexture;",
    "uniform sampler2D UTexture;",
    "uniform sampler2D VTexture;",
    "const mat4 YUV2RGB = mat4",
    "(",
    " 1.16438, 0.00000, 1.59603, -.87079,",
    " 1.16438, -.39176, -.81297, .52959,",
    " 1.16438, 2.01723, 0, -1.08139,",
    " 0, 0, 0, 1",
    ");",
    "void main(void) {",
    " gl_FragColor = vec4( texture2D(YTexture,  vTextureCoord).x, texture2D(UTexture, vTextureCoord).x, texture2D(VTexture, vTextureCoord).x, 1) * YUV2RGB;",
    "}"
  ]));

  function Constructor(canvas, gl, size) {
    WebGLCanvas.call(this, canvas, gl, size);
  }

  Constructor.prototype = inherit(WebGLCanvas, {
    onInitShaders: function () {
      this.program = new Program(this.gl);
      this.vertexShader = new Shader(this.gl, vertexShaderScript);
      this.fragmentShader = new Shader(this.gl, fragmentShaderScript);
      this.program.attach(this.vertexShader);
      this.program.attach(this.fragmentShader);
      this.program.link();
      this.program.use();
      this.vertexPositionAttribute = this.program.getAttributeLocation("aVertexPosition");
      this.gl.enableVertexAttribArray(this.vertexPositionAttribute);
      this.textureCoordAttribute = this.program.getAttributeLocation("aTextureCoord");
      this.gl.enableVertexAttribArray(this.textureCoordAttribute);
    },
    onInitTextures: function () {
     this.gl.viewport(0, 0, typeof this.size.viewWidth !== 'undefined' ? this.size.viewWidth : this.size.w,
                        typeof this.size.viewHeight !== 'undefined' ? this.size.viewHeight : this.size.h);
      this.YTexture = new Texture(this.gl, this.size);
      this.UTexture = new Texture(this.gl, this.size.getHalfSize());
      this.VTexture = new Texture(this.gl, this.size.getHalfSize());
    },
    onInitSceneTextures: function () {
      this.YTexture.bind(0, this.program, "YTexture");
      this.UTexture.bind(1, this.program, "UTexture");
      this.VTexture.bind(2, this.program, "VTexture");
    },
    fillYUVTextures: function (y, u, v) {
      this.YTexture.fill(y);
      this.UTexture.fill(u);
      this.VTexture.fill(v);
    },
    drawCanvas: function (bufferData) {
      var lumaSize = this.size.w * this.size.h;
      var chromaSize = lumaSize >> 2;
      this.YTexture.fill(bufferData.subarray(0, lumaSize));
      this.UTexture.fill(bufferData.subarray(lumaSize, lumaSize + chromaSize));
      this.VTexture.fill(bufferData.subarray(lumaSize + chromaSize, lumaSize + 2 * chromaSize));
      this.drawScene();
    },
    // updateVertexArray: function(vertexArray) { //wjuncho
    //   this.zoomScene(vertexArray);
    // },
    toString: function () {
      return "YUVCanvas Size: " + this.size;
    },
    initCanvas: function () {
      this.gl.clear(this.gl.DEPTH_BUFFER_BIT | this.gl.COLOR_BUFFER_BIT);
    }
  });

  return Constructor;
})();

function VideoMediaSource(workerMng) {
  var version = '1.0.0';
  var videotag_log = log4javascript.getLogger('player');

  var initSegmentFunc = null;
  var mediaSegmentFunc = null;


  var playbackTimeStamp = null;
  var timeStampCallback = null;
  var videoSizeCallback = null;

  var speedValue = 1;
  var receiveTimeStamp = {timestamp:0, timestamp_usec:0, timezone:0};
  var firstTimeStamp = {timestamp:0, timestamp_usec:0, timezone:0};

  var preVideoTimeStamp = null;
  var playbackFlag = false;


  var audioStartNum = 0;

  var workerManager = workerMng;

  function Constructor() {
  }

  function onSourceOpen(videoTag, e) {
    mediaSource = e.target;
    appendInitSegment();
  }

  function appendInitSegment() {
    videotag_log.info("videoMediaSource::appendInitSegment start");
    if (mediaSource.sourceBuffers.length === 0) {
      mediaSource.duration = 0;

      var codecs = "video/mp4;codecs=\"avc1." + codecInfo + "\"";
      sourceBuffer = mediaSource.addSourceBuffer(codecs);
      
      AddBufferEventListener(sourceBuffer);
    }

    var initSegment = initSegmentFunc();

    if (initSegment === null) {
      mediaSource.endOfStream("network");
      return;
    }

    sourceBuffer.appendBuffer(initSegment);
    videotag_log.info("videoMediaSource::appendInitSegment end, codecInfo = " + codecInfo);
  }

  function appendNextMediaSegment(mediaData) {
    if (sourceBuffer === null) return;
    if (mediaSource.readyState == "closed" || mediaSource.readyState == "ended" || sourceBuffer.updating) return;
      
      try {
        sourceBuffer.appendBuffer(mediaData);
      } catch(error) {
        videotag_log.error("videoMediaSource::appendNextMediaSegment error >> initVideo");
        workerManager.initVideo(false);
      }
  }

  function videoPlay() {
    if (videoElement.paused) {
      videoSizeCallback();
      if (!isPlaying) {
        videoElement.play();
      }
    }
  }

  function videoPause() {
    if (!videoElement.paused) {
      if (!isPause) {
        videoElement.pause();
      }
    }
  }

  function checkBufferSize() {
    var startTime = sourceBuffer.buffered.start(sourceBuffer.buffered.length - 1) * 1;
    var endTime = sourceBuffer.buffered.end(sourceBuffer.buffered.length - 1) * 1;
    if ((endTime - startTime) > 60) {
      sourceBuffer.remove(startTime, (endTime - 10));
    }
  }

  function videoUpdating_ex() {
    if (mediaSource === null) return;

    if (sourceBuffer.buffered.length > 0) {
      checkBufferSize();
      var startTime = sourceBuffer.buffered.start(sourceBuffer.buffered.length - 1) * 1;
      var endTime = sourceBuffer.buffered.end(sourceBuffer.buffered.length - 1) * 1;
      var diffTime = 0;
      var delay = 0;
      if (playbackFlag === true) {
        delay = 1.5;
      } else {
        delay = 0.5;
      }

      diffTime = (videoElement.currentTime === 0 ? endTime - startTime : endTime - (videoElement.currentTime + delay));

      if (diffTime > delay) {
        var tempCurrentTime = endTime - delay;
        videotag_log.debug("startTime, endTime, videoElement.currentTime, tempCurrentTime, diffTime = ", startTime, endTime, videoElement.currentTime, tempCurrentTime, diffTime);
        if (tempCurrentTime > startTime && tempCurrentTime < endTime) {
          if (diffTime > (delay + 1)) {
            videoElement.currentTime = tempCurrentTime;
          }
        }
      }
    }
  }

  function onWaiting(e) {
    if (mediaSource !== null) {
      videoPause();
    }
  }
  function onTimeupdate(e) {
    var duration = parseInt(mediaSource.duration, 10);
    var currentTime =  parseInt(videoElement.currentTime, 10);
    var calcTimeStamp = receiveTimeStamp.timestamp - (speedValue * (duration - currentTime + (speedValue !== 1 ? 1 : 0)));
    var sendTimeStamp = {timestamp:calcTimeStamp, timestamp_usec:0, timezone:receiveTimeStamp.timezone};

    if (currentTime === 0 || isNaN(duration)) return;
    if (Math.abs(duration - currentTime) > 4) return;

    if (!videoElement.paused) {
      if (preVideoTimeStamp === null) {
        preVideoTimeStamp = sendTimeStamp;
      } else if ((preVideoTimeStamp.timestamp <= sendTimeStamp.timestamp && speedValue >= 1) ||
          (preVideoTimeStamp.timestamp > sendTimeStamp.timestamp && speedValue < 1)) {
        if(playbackFlag){
          workerManager.timeStamp(sendTimeStamp);
        }
        preVideoTimeStamp = sendTimeStamp;
        audioStartNum++;

        if (audioStartNum > 4) {
          startAudioCallback(sendTimeStamp.timestamp, "currentTime");
        }
      }
    }
  }
  function onDurationchange(mediaSource, e) {
    videoUpdating_ex();
  }
  function onResize(mediaSource, e) {
    videoSizeCallback();
  }
  function onSeeked(mediaSource, e) {
    videoPlay();
  }

  Constructor.prototype = {
    init: function(element) {
      browserType = BrowserDetect();
      videotag_log.info("videoMediaSource::init browserType = " + browserType);
      videoElement = element;

      var img = './base/images/loading.gif';
      if (window.jQuery) {
        if ($("channel_player.full-screen").length || $("#channellist-containner").length) {
          img = './base/images/loading_b.gif';
        }
      }

      videoElement.controls = false;
      videoElement.preload = "auto";

      videoElement.autoplay = true;
      videoElement.muted = false;

      videoElement.poster = "./base/images/video_poster.png";
      videoElement.style.background = "url("+img+") no-repeat center center" + videoElement.style.background;
      videoElement.style.backgroundSize = "48px 48px";
      videoDigitalPtz.setVideoElement(videoElement);
      AddVideoEventListener(videoElement);
      appendInitSegment();
    },
    setInitSegmentFunc: function(func) {
      initSegmentFunc = func;
    },
    getVideoElement: function() {
      return videoElement;
    },
    setCodecInfo: function(info) {
      codecInfo = info;
    },
    setMediaSegment: function(mediaSegment) {
      appendNextMediaSegment(mediaSegment);
    },
    capture: function(fileName) {
      var canvas = document.createElement("canvas");
      canvas.width = videoElement.videoWidth;
      canvas.height = videoElement.videoHeight;
      canvas.getContext('2d')
            .drawImage(videoElement, 0, 0, canvas.width, canvas.height);
      doCapture(canvas.toDataURL(), fileName);
    },
    setInitSegment: function() {
      appendInitSegment();
    },
    setTimeStamp: function(timeStamp, callback) {
      playbackTimeStamp = timeStamp;
      timeStampCallback = callback;
    },
    setVideoSizeCallback: function(func) {
      videoSizeCallback = func;
    },
    setAudioStartCallback: function(func) {
      startAudioCallback = func;
    },
    getPlaybackTimeStamp: function() {
      return playbackTimeStamp;
    },
    setSpeedPlay: function(value) {
      speedValue = value;
    },
    setvideoTimeStamp: function(timestamp) {
      var seekCheck = (Math.abs(receiveTimeStamp.timestamp - timestamp.timestamp) > 3 ? true : false);
      if (seekCheck === true) {
        audioStartNum = 0;
        firstTimeStamp = timestamp;
        startAudioCallback(firstTimeStamp.timestamp, "init");
      }
      receiveTimeStamp = timestamp;
    },
    pause: function() {
      videoPause();
    },
    play: function() {
      videoPlay();
    },
    setPlaybackFlag: function(value) {
      playbackFlag = value;
    },
    setTimeStampInit: function() {
      preVideoTimeStamp = null;
      firstTimeStamp = {timestamp:0, timestamp_usec:0, timezone:0};
    },
    setBoxSize: function(size) {
      boxSize = size;
    },    
    close: function() {
      removeEventListener();
      videoPause();
    }
  };

  return new Constructor();
}
/* global Uint8Array, initSegment, doCapture, inheritObject, VideoPlayer, mediaSegment */

/**
 * VideoTagPlayer
 * @class VideoTagPlayer
 */
function VideoTagPlayer() {
  "use strict";

  var version = '1.0.0';
  var videotag_log = log4javascript.getLogger('player:video');

  //common variables
  var theInterval,
    oneSecondInterval,
    curTime,
    nCurrentFrame = 0,
    nPreviousFrame = 0,
    defaultDelay = 0.3,
    averageFPS = 0,
    playbackFlag = false,
    deviceType = null,
    prefixSize = 4,
    preFrameData = null,
    videoElement = null,
    videoTagPromise = null,
    codecInfo = null,
    delay = defaultDelay,
    prevEndTime = 0,
    minimapInfo = {
      isUpdate : false,
      element : null
    };

  //callback variables
  var videoSizeCallback = null;
  var errorCallback = null;
  var timeStampCallback = null;

  //event variables
  var videoEventListenerArray = null;
  var bufferEventListenerArray = null;
  var mediaSourceEventListenerArray = null;

  //status variables
  var isPlaying = false;
  var isPause = true;
  var speedValue = 1;

  //timeStamp variables
  var receiveTimeStamp = {
    timestamp: 0,
    timestamp_usec: 0,
    timezone: 0,
    channelId: 0
  };
  var requestTime = null;

  //buffer variables
  var sourceBuffer = null;
  var mediaSource = null;

  //container variables
  var timeScale = 10000;
  var segmentArray = [];
  var sequenseNum = 1;
  var samples = [];
  var sumDuration = 0;
  var baseMediaTime = 0;
  var boxStartTime = [];
  var lastBoxSize = 0;
  var TEN = 10;
  var TWO = 2;
  var fileName = '';
  var captureFlag = false;
  var _self;
  var targetTextTrackId = -1;
  window.VTTCue = window.VTTCue || window.TextTrackCue;

  function Constructor() {
    _self = this;
  }

  function AddVideoEventListener() {
    videoEventListenerArray = [
      'durationchange', 'playing', 'error', 'pause', 'timeupdate', 'resize', 'seeked',
      'progress', 'seeking', 'loadstart', 'abort', 'emptied', 'stalled', 'loadedmetadata', 'loadeddata', 'canplay',
      'canplaythrough', 'waiting', 'ended', 'play', 'ratechange', 'volumechange', 'addtrack', 'removetrack'
    ];

    for (var i = 0; i < videoEventListenerArray.length; i++) {
      videoElement.addEventListener(videoEventListenerArray[i], videoElementEventListener);
    }
  }

  function AddBufferEventListener() {
    bufferEventListenerArray = [
      'error', 'abort',
      'updatestart', 'update', 'updateend', 'updating'
    ];

    for (var i = 0; i < bufferEventListenerArray.length; i++) {
      sourceBuffer.addEventListener(bufferEventListenerArray[i], sourceBufferEventListener);
    }
  }

  function AddMediaSourceEventListener() {
    mediaSourceEventListenerArray = [
      'sourceopen', 'error',
      'sourceended', 'sourceclose',
    ];

    for (var i = 0; i < mediaSourceEventListenerArray.length; i++) {
      mediaSource.addEventListener(mediaSourceEventListenerArray[i], mediaSourceEventListener);
    }
  }
  /**
   *
   * @param  {any} event
   * @return {void}
   */
  function mediaSourceEventListener(event) {
    switch (event.type) {
      case 'sourceopen':
        videotag_log.debug("ch: " + _self.channelId + "', readyState: " + mediaSource.readyState + ", mediaSourceEventListener::error = " + JSON.stringify(event, ['type', 'timeStamp']));
        mediaSource = event.target;
        setSourceBuffer();
        appendSegmentToSourceBuffer();
        break;
      case 'error':
      case 'abort':
        videotag_log.debug("ch: " + _self.channelId + ", readyState: " + mediaSource.readyState + ", mediaSourceEventListener::error,abort = " + JSON.stringify(event, ['type', 'timeStamp']));
        break;
      case 'sourceended':
      case 'sourceclose':
        videotag_log.debug("ch: " + _self.channelId + ", readyState: " + mediaSource.readyState + ", mediaSourceEventListener::event type = " + JSON.stringify(event, ['type', 'timeStamp']));
        break;
      default:
        videotag_log.debug("ch: " + _self.channelId + ", readyState: " + mediaSource.readyState + ", mediaSourceEventListener::event unknown type = " + JSON.stringify(event, ['type', 'timeStamp']));
        break;
    }
  }
  /**
   *
   * @param  {any} event
   * @return {void}
   */
   function sourceBufferEventListener(event) {
     switch (event.type) {
       case 'error':
       case 'abort':
         videotag_log.debug("ch: " + _self.channelId + ", readyState: " + mediaSource.readyState + ", sourceBufferEventListener::error,abort = " + JSON.stringify(event, ['type', 'timeStamp']));
         break;
       case 'updatestart':
         videotag_log.debug("ch: " + _self.channelId + ", readyState: " + mediaSource.readyState + ", sourceBufferEventListener::updatestart = " + JSON.stringify(event, ['type', 'timeStamp']));
         break;
       case 'update':
         videotag_log.debug("ch: " + _self.channelId + ", readyState: " + mediaSource.readyState + ", sourceBufferEventListener::update = " + JSON.stringify(event, ['type', 'timeStamp']));
         break;
       case 'updateend':
         appendSegmentToSourceBuffer();
         videotag_log.debug("ch: " + _self.channelId + ", readyState: " + mediaSource.readyState + ", sourceBufferEventListener::event type = " + JSON.stringify(event, ['type', 'timeStamp']));
         break;
       case 'updating':
         videotag_log.debug("ch: " + _self.channelId + ", readyState: " + mediaSource.readyState + ", sourceBufferEventListener::event type = " + JSON.stringify(event, ['type', 'timeStamp']));
         break;
       default:
         videotag_log.debug("ch: " + _self.channelId + ", readyState: " + mediaSource.readyState + ", sourceBufferEventListener::event unknown type = " + JSON.stringify(event, ['type', 'timeStamp']));
         break;
     }
   }
  /**
   *
   * @param  {any} event
   * @return {void}
   */
  function videoElementEventListener(event) {
    switch (event.type) {
      case 'playing':
        // $(window).trigger('resize');
        isPlaying = true;
        isPause = false;
        break;
      case 'pause':
        videotag_log.debug("ch: ", _self.channelId, "videoElementEventListener pause event = ", JSON.stringify(event, ['type', 'timeStamp']));
        isPlaying = false;
        isPause = true;
        break;
      case 'error':
        videotag_log.debug("ch: ", _self.channelId, "videoElementEventListener error event = ", JSON.stringify(event, ['type', 'timeStamp']));
        //errorCallback();
        break;
      case 'waiting':
        videotag_log.debug("ch: ", _self.channelId, "videoElementEventListener waiting event = ", JSON.stringify(event, ['type', 'timeStamp']));
        // if (mediaSource !== null) {
        //   videoPause();
        // }
        break;
      case 'timeupdate':
        videotag_log.debug("ch: ", _self.channelId, "videoElementEventListener timeupdate event = ", JSON.stringify(event, ['type', 'timeStamp']));
        if (captureFlag === true) {
          download(videoElement);
        }
        break;
      case 'resize':
        videotag_log.debug("ch: ", _self.channelId, "videoElementEventListener resize event = ", JSON.stringify(event, ['type', 'timeStamp']));
        if (window.jQuery) {
          videotag_log.info("jquery $(window).trigger('resize')");
          $(window).trigger('resize');
        } else {
          videotag_log.info("windows.dispatchEvent('resizeEvent')");
          var evt = document.createEvent("HTMLEvents");
          evt.initEvent('resize', true, false);
          window.dispatchEvent(evt);
        }
        //videoSizeCallback(this.channelId, "video", videoElement.videoWidth, videoElement.videoHeight);
        break;
      case 'seeked':
        videotag_log.debug("ch: ", _self.channelId, "videoElementEventListener seeked event = ", JSON.stringify(event, ['type', 'timeStamp']));
        if(!_self.instantplayback) {
          videoPlay();
        }
        break;
      case 'progress':
      case 'seeking':
      case 'loadstart':
      case 'abort':
      case 'emptied':
      case 'stalled':
      case 'loadedmetadata':
      case 'loadeddata':
      case 'canplay':
      case 'canplaythrough':
      case 'ended':
      case 'play':
      case 'ratechange':
      case 'volumechange':
      case 'addtrack':
      case 'removetrack':
        videotag_log.debug("ch: ", _self.channelId, "videoElementEventListener event = ", JSON.stringify(event, ['type', 'timeStamp']));
        break;
      default:
        videotag_log.debug("ch: " + _self.channelId + ", videoElementEventListener::event unknown = " + JSON.stringify(event, ['type', 'timeStamp']));
        break;
    }
  }

  function removeEventListener() {
    var i = 0;
    if (sourceBuffer !== null && bufferEventListenerArray !== null) {
      for (i = 0; i < bufferEventListenerArray.length; i++) {
        sourceBuffer.removeEventListener(bufferEventListenerArray[i], sourceBufferEventListener);
      }
      sourceBuffer = null;
    }
    if (mediaSource !== null && mediaSourceEventListenerArray !== null) {
      for (i = 0; i < mediaSourceEventListenerArray.length; i++) {
        mediaSource.removeEventListener(mediaSourceEventListenerArray[i], mediaSourceEventListener);
      }
      mediaSource = null;
    }
    if (videoEventListenerArray !== null) {
      for (i = 0; i < videoEventListenerArray.length; i++) {
        videoElement.removeEventListener(videoEventListenerArray[i], videoElementEventListener);
      }
    }
    if (typeof document.webkitHidden !== "undefined") {
      document.removeEventListener("visibilitychange", onVisibilityChange);
    }
  }

  function createMediaSource() {
    if (mediaSource === null || mediaSource.readyState === "ended") {
      mediaSource = new MediaSource();
      AddMediaSourceEventListener();
      videoElement.src = window.URL.createObjectURL(mediaSource);
      videotag_log.info("videoTagPlayer::create MediaSource");
    } else {
      videotag_log.warn("videoTagPlayer:: MediaSource is already create. status = " + mediaSource.readyState);
    }
  }

  function onCueChange() {
    if (this.activeCues !== null && typeof this.activeCues[0] !== 'undefined' &&
      this.activeCues[0] !== null) {
      try {
        var cueText = this.activeCues[0].text;
        this.removeCue(this.activeCues[0]);
        var timeStamp = JSON.parse(cueText);
        timeStamp.channelId = _self.channelId;
        timeStampCallback(timeStamp);
      } catch (error) {
        throw new umpError({
          channelId: _self.channelId,
          errorCode: error.code,
          place: 'videoTagPlayer.js:296',
          message: error.message
        });
      }
    }
  }

  function elementSetting(channelid) {
    var img = './base/images/loading.gif';
    if (window.jQuery) {
      if ($("channel_player.full-screen").length || $("#channellist-containner").length) {
        img = './base/images/loading_b.gif';
      }
    }

    videoElement.controls = false;
    videoElement.preload = "auto";

    // Indicates that the audio/video should start playing as soon as it is loaded
    videoElement.autoplay = false;
    videoElement.muted = true;

    videoElement.style.background = "url(" + img + ") no-repeat center center" + videoElement.style.background;
    videoElement.style.backgroundSize = "48px 48px";
    // reference from
    // https://codepen.io/Yuschick/post/html5-currenttime-and-frame-numbers
    videoElement.onplaying = onPlaying;
    videoElement.onpause = onPause;
    videoElement.onclose = onClose;
    videoElement.oncanplay = onCanPlay;
    videoElement.onwaiting = onWaiting;
    videoElement.ondurationchange = onDurationChange;
    videoElement.onloadeddata  = onLoadedData;
    videoElement.onprogress   = onProgress;
    videoElement.onseeking   = onSeeking;

    var textTrack = videoElement.addTextTrack("captions", "English", "en");
    targetTextTrackId = videoElement.textTracks.length-1;
    textTrack.mode = "hidden";
    textTrack.oncuechange = onCueChange;

    AddVideoEventListener();
    if (typeof document.webkitHidden !== "undefined") {
      document.addEventListener("visibilitychange", onVisibilityChange);
    }
  }

  function getCurrentVideoFrame() {
    /**
     * Gets the current time, multiplies by the framerate to find current frame
     */

    curTime = videoElement.currentTime;
    nCurrentFrame = Math.floor(curTime * _self.getFrameRate());

    videotag_log.debug("ch: " + _self.channelId + ", Current Time: " + curTime + ", the Current fps: " + (nCurrentFrame));

    if (typeof _self.eventStatisticsCallback !== 'undefined' && _self.eventStatisticsCallback !== null) {
      var data = {
        type: 'fps',
        channelId: _self.channelId,
        fps: (nCurrentFrame - nPreviousFrame),
        // TODO: change bps calcuation mathmatics
        bps: (((videoElement.videoWidth * videoElement.videoHeight) * (nCurrentFrame - nPreviousFrame) * 0.07) / (1024 * 1024)).toFixed(2)
      };
      _self.eventStatisticsCallback(data);
    }

    nPreviousFrame = nCurrentFrame;
  }

  function changeCurrentTime() {
    if (isPause) {
      return;
    }
    var boxTimeIndex = lastBoxSize <= 4 ? 2 : 1;
    if (boxTimeIndex < boxStartTime.length) {
      var lastBoxTime = boxStartTime[boxStartTime.length - 1 - boxTimeIndex];
      if (videoElement.currentTime < lastBoxTime) {
        videoElement.currentTime = lastBoxTime;
      }
    }
  }

  function onVisibilityChange() {
    if (!playbackFlag || document.visibilityState !== "visible") {
      return;
    }

    changeCurrentTime();
  }

  function onPlaying() {
    videotag_log.info("ch: ", _self.channelId, "videoTagPlayer::onPlaying: video element play started");
    // if(typeof theInterval === 'undefined') {
    //   console.log("onPlaying: start timer");
    //   theInterval = setInterval(function() {
    //     getCurrentVideoFrame();
    //   }, 1000 /*(1000 / _self.getFrameRate())*/);
    // }

    if (typeof oneSecondInterval === 'undefined') {
      videotag_log.info("videoTagPlayer::onPlaying message what start timer" + _self.channelId);
      oneSecondInterval = setInterval(function () {
        getCurrentVideoFrame();
      }, 1000);
    }
  }

  function onCanPlay(evt) {
    videotag_log.info("ch: ", _self.channelId, "videoTagPlayer::onCanPlay", JSON.stringify(evt));
    if ( !isPlaying) {
      if(!_self.instantplayback) {
        videoPlay();
      } else {
        videotag_log.info("ch: ", _self.channelId, "videoTagPlayer::onCanPlay: this is instant playback mode");
      }
    }
  }

  function onClose() {
    videotag_log.info("ch: ", _self.channelId, "videoTagPlayer::onClose: video element closed");
    nPreviousFrame = nCurrentFrame = 0;
    if (oneSecondInterval !== undefined && oneSecondInterval !== null) {
      clearInterval(oneSecondInterval);
    }
    if (theInterval !== undefined && theInterval !== null) {
      clearInterval(theInterval);
    }
  }

  function onPause() {
    videotag_log.info("ch: ", _self.channelId, "videoTagPlayer::onPause: video element paused");

    if(_self.instantplayback) {
      var startTime = sourceBuffer.buffered.start(sourceBuffer.buffered.length - 1) * 1;
      var endTime = sourceBuffer.buffered.end(sourceBuffer.buffered.length - 1) * 1;

      videotag_log.info("ch: ", _self.channelId, "available instant playback, start time = ", startTime, ", end time = ", endTime);
      var data = {
        channelId: _self.channelId,
        errorCode: fromHex('0x1100'),
        timeline: {
          start: startTime,
          end: endTime
        }
      }

      if(typeof _self.eventInstantPlaybackCallback !== 'undefined' &&
         _self.eventInstantPlaybackCallback !== null) {
        _self.eventInstantPlaybackCallback(data);
      }
    }
  }

  function onWaiting() {
    videotag_log.info("ch: ", _self.channelId, "videoTagPlayer::onWaiting: video element on waiting");

    if(_self.instantplayback) {
      videotag_log.info("ch: ", _self.channelId, "videoTagPlayer::onWaiting: this is instant playback mode");

      var startTime = sourceBuffer.buffered.start(sourceBuffer.buffered.length - 1) * 1;
      var endTime = sourceBuffer.buffered.end(sourceBuffer.buffered.length - 1) * 1;

      videotag_log.info("current time = ", videoElement.currentTime, ", start time = ", startTime, ", endtime = ", endTime);
      videoPause();
    }
  }

  function onDurationChange() {
    videotag_log.debug("ch: ", _self.channelId, "videoTagPlayer::onDurationChange: The video duration has changed");
    videoUpdating();
  }

  function onLoadedData() {
    videotag_log.debug("ch: ", _self.channelId, "videoTagPlayer::onLoadedData: Alert that data for the current frame is available");
  }

  function onProgress(event) {
    videotag_log.debug("ch: ", _self.channelId, "videoTagPlayer::onLoadedData: Alert that the video is downloading", JSON.stringify(event));
  }

  function onSeeking(event) {
    videotag_log.debug("ch: ", _self.channelId, ", seeking event = ", JSON.stringify(event), ", current time = ",  videoElement.currentTime);
    if(_self.instantplayback) {
      if ( !isPlaying ) {
        //videoPlay();
        //videoElement.play();
      }
    }
  }

  var maxPlaybackDiff = 1500;

  function updateTimestamp(boxSamples) {
    var length = boxSamples.length;
    var lastTimeStamp = null, startTime = null, endTime = null, cueList = [];
    for (var i = 0; i < length; i += 1) {
      var diff = null;
      if (i < length - 1) {
        diff = Math.abs(boxSamples[i + 1].rtpTimestamp - boxSamples[i].rtpTimestamp);
      } else if (samples.length > 0) {
        diff = Math.abs(samples[0].rtpTimestamp - boxSamples[i].rtpTimestamp);
      }
      if (diff === null || diff > maxPlaybackDiff) {
        diff = Math.floor(500 / length);
      }

      boxSamples[i].frameDuration = diff * TEN;

      if (startTime === null) {
        startTime = baseMediaTime / timeScale;
      }
      baseMediaTime += boxSamples[i].frameDuration;
      if (lastTimeStamp === null) {
        lastTimeStamp = boxSamples[i].timeStamp;
      } else if (lastTimeStamp.timestamp !== boxSamples[i].timeStamp.timestamp) {
        lastTimeStamp = boxSamples[i].timeStamp;
        endTime = baseMediaTime / timeScale;
        cueList.push([startTime, endTime, JSON.stringify(lastTimeStamp)]);
        startTime = endTime;
      }
    }

    endTime = baseMediaTime / timeScale;
    if (startTime < endTime) {
      cueList.push([startTime, endTime, JSON.stringify(lastTimeStamp)]);
    }

    cueList.forEach(function (cue) {
      videoElement.textTracks[targetTextTrackId].
        addCue(new VTTCue(cue[0], cue[1], cue[2]));
    });
  }

  var createMediaSegmentTimeout = null;

  function createSample(streamData, videoInfo) {
    var sample = {
      size: streamData.frameData.length,
      frameData: createSampleFrameData(streamData.frameData),
    };

    samples.push(sample);
    videotag_log.debug("samples buffered packet count: " + samples.length);

    if (playbackFlag) {
      sample.timeStamp = streamData.timeStamp;
      sample.rtpTimestamp = parseInt(sample.timeStamp.rtpTimestamp, 10);
      if (videoInfo.frameType === "I") {
        if (samples.length > 1) {
          createMediaSegment(samples.length - 1);
        }
        createMediaSegmentTimeout = setTimeout(createMediaSegment, maxPlaybackDiff);
      }
    } else {
      sample.frameDuration = getFrameDuration(streamData, videoInfo);
      if (samples.length >= _self.getBoxSize()) {
        createMediaSegment(_self.getBoxSize());
      }
    }
  }

  function getFrameDuration(streamData, videoInfo) {
    var frameDuration = 0;
    if (preFrameData === null) {
      preFrameData = {
        streamData: streamData,
        videoInfo: videoInfo
      };
      return frameDuration;
    } else {
      var preFrameTimeStamp = parseInt(preFrameData.streamData.timeStamp.rtpTimestamp, 10);
      var curFrameTimeStamp = parseInt(streamData.timeStamp.rtpTimestamp, 10);

     videotag_log.debug("preFrameTimeStamp : " + preFrameTimeStamp + " Frame Time Stamp : " + curFrameTimeStamp);

      // if(curFrameTimeStamp - preFrameTimeStamp === 0) {
      //   // if time stampe is equal between current timestamp  and previous timestamp
      //   // I this this is device bug
      //   throw new umpError({
      //     channelId: _self.channelId,
      //     errorCode: fromHex('0x0106'),
      //     place: 'videoTagPlayer.js:412',
      //     message: "Check your device recording timestamp. rtp time stamp could not same value between current frame and previous frame."
      //   });
      // }

      if (speedValue === 1) {
        frameDuration = Math.abs(curFrameTimeStamp - preFrameTimeStamp) * TEN;
      } else {
        frameDuration = timeScale / Math.abs(speedValue);
      }

      var frameDurationCheckTime = 15000;
      if (frameDuration > frameDurationCheckTime) {
        frameDuration = frameDurationCheckTime;
      }

      preFrameData = {
        streamData: streamData,
        videoInfo: videoInfo
      };
    }

    averageFPS = (averageFPS + (timeScale / frameDuration)) / TWO;
    // check divide not zero
    if (averageFPS === 0 ||
      isNaN(averageFPS) ||
      typeof averageFPS === "undefined" ||
      averageFPS === null) {
      averageFPS = 1;
    }
    var delayCheckTime = (_self.getBoxSize() / averageFPS) * (playbackFlag ? 1 : TEN);

    //videotag_log.debug("averageFPS = " + averageFPS + ", timeScale = " + timeScale + ", frameDuration = " + frameDuration);
    // videotag_log.info("ch: " + _self.getChannel() + ", current delay: " + delay + ", calculate delay time: " + Math.abs(delayCheckTime - delay) + ", defaultDelayTime:" + defaultDelay + ", delayCheckTime = " + delayCheckTime + ", current time: " + videoElement.currentTime);

    if (Math.abs(delayCheckTime - delay) > defaultDelay) {
      delay = delayCheckTime + defaultDelay;
      videotag_log.debug("check delay ch: " + _self.channelId + ", averageFPS = " + averageFPS + ", delayCheckTime = " + delayCheckTime + ", delay = " + delay);
    }

    sumDuration += frameDuration;
    return frameDuration;
  }

  function setNalLength(index, size, array) {
    array[index + 0] = (size & 0xFF000000) >> 24;
    array[index + 1] = (size & 0xFF0000) >> 16;
    array[index + 2] = (size & 0xFF00) >> 8;
    array[index + 3] = (size & 0xFF);
  }

  function createSampleFrameData(frameData) {
    var length = frameData.byteLength;
    var nalUnitIndex = 0, i = 0;

    while (i + 4 < length) {
      if (frameData[i + 0] === 0x00 &&
        frameData[i + 1] === 0x00 &&
        frameData[i + 2] === 0x00 &&
        frameData[i + 3] === 0x01) {
        if (i > 0) {
          setNalLength(nalUnitIndex, i - nalUnitIndex - prefixSize, frameData);
        }
        nalUnitIndex = i;
        i += prefixSize;
      } else {
        i += 1;
      }
    }

    setNalLength(nalUnitIndex, length - nalUnitIndex - prefixSize, frameData);

    return new Uint8Array(frameData);
  }

  function createInitSegment(videoInfo, codecType) {

    var specialWidth = [192, 368, 608, 1088, 1472, 1952, 3008];

    for (var i in specialWidth) {
      if (videoInfo.width === specialWidth[i]) {
        videoInfo.width -= 8;
        break;
      }
    }

    var info = {
      id: 1,
      width: videoInfo.width,
      height: videoInfo.height,
      type: 'video',
      codecType: codecType,
      sps: [videoInfo.spsPayload],
      pps: [videoInfo.ppsPayload]
    };

    if (codecType === "H264") {
      info.profileIdc = videoInfo.profileIdc;
      info.profileCompatibility = 0;
      info.levelIdc = videoInfo.levelIdc;
    } else if (codecType === "H265") {
      info.profileTierLevel = videoInfo.profileTierLevel;
      info.vps = [videoInfo.vpsPayload];
    }

    segmentArray.push(initSegment([info]));
  }

  function createFrameDataBuffer(samples) {
    if (samples.length === 1) {
      return samples[0].frameData;
    }

    var bufferSize = samples.reduce(function (acc, sample) {
      return acc + sample.size;
    }, 0);

    var buffer = new Uint8Array(bufferSize), bufferIndex = 0;

    samples.forEach(function (sample) {
      buffer.set(sample.frameData, bufferIndex);
      bufferIndex += sample.size;
    });

    return buffer;
  }

  function createMediaSegment(boxSize) {
    if (createMediaSegmentTimeout) {
      clearTimeout(createMediaSegmentTimeout);
      createMediaSegmentTimeout = null;
    }

    var boxInfo = {
      id: 1,
      samples: boxSize ? samples.splice(0, boxSize) : samples.splice(0),
      baseMediaDecodeTime: baseMediaTime,
    };
    var frameDataBuffer = createFrameDataBuffer(boxInfo.samples);
    boxStartTime.push(boxInfo.baseMediaDecodeTime / timeScale);
    lastBoxSize = boxInfo.samples.length;

    if (playbackFlag) {
      updateTimestamp(boxInfo.samples);
    } else {
      baseMediaTime = boxInfo.baseMediaDecodeTime + sumDuration;
      sumDuration = 0;
    }

    segmentArray.push(mediaSegment(sequenseNum, [boxInfo], frameDataBuffer));
    sequenseNum++;

    appendSegmentToSourceBuffer();
  }

  function appendSegmentToSourceBuffer() {
    if (sourceBuffer === null || sourceBuffer.updating) {
      return;
    }
    
    if (segmentArray.length === 0) {
      if (samples.length === 0 && mediaSource && mediaSource.willEnd) {
        mediaSource.endOfStream();
      }
      return;
    }

    var segment = segmentArray.shift();

    if (segment) {
      sourceBuffer.appendBuffer(segment);
    } else {
      mediaSource.endOfStream("network");
    }
  }

  function setSourceBuffer() {
    videotag_log.info("videoTagPlayer::appendInitSegment codecInfo = " + codecInfo);
    if (mediaSource.sourceBuffers.length === 0) {
      mediaSource.duration = 0;

      try {
        var mimeCodec = 'video/mp4;codecs="' + codecInfo + '"';
        sourceBuffer = mediaSource.addSourceBuffer(mimeCodec);
      } catch (error) {
        throw new umpError({
          channelId: _self.channelId,
          errorCode: error.code,
          place: 'videoTagPlayer.js:511',
          message: error.message
        });
      }

      AddBufferEventListener();
    }
  }

  function videoPlay() {
    // var isPlaying = videoElement.currentTime > 0 && !videoElement.paused && !videoElement.ended && videoElement.readyState > 2;
    // if (!isPlaying) {
    //   videoElement.play();
    // }
    if (videoElement !== undefined && (videoElement.paused || !isPlaying)) {
      //videoSizeCallback(this.channelId, "video", videoElement.videoWidth, videoElement.videoHeight);
      videoTagPromise = videoElement.play();
      if (typeof videoTagPromise !== "undefined") {
        videoTagPromise.then(function(){
          // AutoPlay Started
          videoElement.play();
        }).catch(function(err){
          // AutoPlay was prevented
          videoElement.pause();
        });
      }
      if (mediaSource) {
        videotag_log.info("mediaSource.readyState: " + mediaSource.readyState);
      }
    }
  }

  function videoPause() {
    // var isPlaying = videoElement.currentTime > 0 && !videoElement.paused && !videoElement.ended && videoElement.readyState > 2;
    // if (isPlaying) {
    //   videoElement.pause();
    // }
    if (videoElement !== undefined && videoElement !== null && (!videoElement.paused || isPlaying)) {
      videoElement.pause();
      if(!_self.instantplayback ) {
        videoElement.currentTime = 0;
      }
      videotag_log.info("mediaSource.readyState: " + mediaSource.readyState);
    }
  }

  function checkBufferSize() {
    var startTime = sourceBuffer.buffered.start(sourceBuffer.buffered.length - 1) * 1;
    var endTime = sourceBuffer.buffered.end(sourceBuffer.buffered.length - 1) * 1;
    try {
      if (Math.abs(endTime - prevEndTime) > _self.getBufferClearInterval() && (endTime - (_self.getMaxInstantPlayback() + _self.getBufferClearInterval())) > 0) {
        /*         videotag_log.debug("Channel: " + ("00" + _self.channelId).slice(-2) +
                ", Start time: " + (startTime).toFixed(5) +
                ", End Time: " + (endTime).toFixed(5) +
                ", Remaining time: " + Math.abs(endTime - _self.getMaxInstantPlayback()).toFixed(8) );
         */
        // reference from https://github.com/Streamedian/html5_rtsp_player/issues/60
        if (!sourceBuffer.updating) {
          endTime = Math.min(endTime, videoElement.currentTime);
          sourceBuffer.remove(0, Math.abs(endTime - _self.getMaxInstantPlayback()));
          prevEndTime = endTime;
        }
      }
    } catch (error) {
      videotag_log.error("checkBufferSize::invalid remove scope from channel: " + _self.channelId + ", error message: " + error.message);
    }
  }

  function videoUpdating() {
    try {
      if (mediaSource === null || typeof sourceBuffer.buffered === "undefined") {
        return;
      }
    } catch (e) {
      return;
    }

    if (sourceBuffer.buffered.length > 0) {
      checkBufferSize();

      if (playbackFlag) {
        return;
      }

      var startTime = sourceBuffer.buffered.start(sourceBuffer.buffered.length - 1) * 1;
      var endTime = sourceBuffer.buffered.end(sourceBuffer.buffered.length - 1) * 1;
      var diffTime = 0;

      diffTime = (videoElement.currentTime === 0 ? endTime - startTime :
        endTime - (videoElement.currentTime + delay));
      videotag_log.debug("diff time = ", diffTime, ", current latency = ", delay, ", current time = ", videoElement.currentTime, ", end time = ", endTime, ", offset time = ", (videoElement.currentTime + delay));

      if (diffTime > delay) {
        var tempCurrentTime = endTime - delay;
        if (tempCurrentTime > startTime && tempCurrentTime < endTime) {
          videotag_log.debug("target current time: " + tempCurrentTime);
          videoElement.currentTime = tempCurrentTime;
          if (isPlaying === false) {
            videoPlay();
          }
        }
      }
    }
  }

  function pad(number) {
    if (number < 10) {
      return '0' + number;
    }
    return number;
  }

  function convertTimeString(seconds) {
    if (moment) {
      return moment(seconds * 1000).format("YYYYMMDDHHmmss");
    } else {
      var date = new Date(seconds * 1000);
      return date.getUTCFullYear() + pad(date.getUTCMonth() + 1) + pad(date.getUTCDate()) +
        pad(date.getUTCHours()) + pad(date.getUTCMinutes()) + pad(date.getUTCSeconds());
    }
  }

  function checkPlaybackEnd(streamTimeStamp) {
    if (receiveTimeStamp.timestamp === streamTimeStamp.timestamp ||
      !requestTime || !requestTime.endTime ||
      typeof streamTimeStamp.timezone === "undefined" || streamTimeStamp.timezone === null) {
      return;
    }

    var seconds = streamTimeStamp.timestamp + streamTimeStamp.timezone * 60;
    var timeString = convertTimeString(seconds);

    if (timeString >= requestTime.endTime) {
      setTimeout(function () {
        if (mediaSource) {
          mediaSource.willEnd = true;
        }
      }, maxPlaybackDiff);
    }
  }

  function download(videoElem) {
    var canvas = document.createElement("canvas");
    canvas.width = videoElem.videoWidth;
    canvas.height = videoElem.videoHeight;
    var ctx = canvas.getContext('2d');
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    try {
      ctx.restore();
      ctx.save();
      ctx.drawImage(videoElem, 0, 0, canvas.width, canvas.height);
    } catch (e) {
      console.log(e);
    }

    captureFlag = false;
    canvas.toBlob(function (blob) {
      if(fileName !== null && fileName !== undefined) {
        saveAs(blob, fileName + '.png');
      } else {
        if(_self.eventCaptureCallback !== null && _self.eventCaptureCallback !== undefined) {
          var data = {
            channelId: _self.channelId,
            blob: blob
          };
          _self.eventCaptureCallback(data);
        } else {
          throw new umpError({
            channelId: _self.channelId,
            errorCode: fromHex('0x0909'),
            place: 'canvasRenderer.js:53',
            message: "can not return capture blob"
          });
        }
      }
    });
  }

  Constructor.prototype = inheritObject(new VideoPlayer(), {
    /**
     * This function is initialize VideoTagPlayer.
     * @function init
     * @memberof VideoTagPlayer
     * @example
     *     example: VideoTagPlayer.init(element);
     */
    init: function (element) {
      videotag_log.info("VideoTagPlayer::init");
      videoElement = element;

      elementSetting();
      createMediaSource();
      this.instantplayback = false;
    },
    /**
     * This function is receive video data.
     * @function onVideoData
     * @memberof VideoTagPlayer
     * @param {string} playMode "Live" or "Playback"
     * @param {object} streamData streamData object
     * @param {string} streamData.codecType "MJPEG", "H264", "H265"
     * @param {Uint8Array} streamData.frameData Depacketized frame data
     * @param {object} streamData.timeStamp Timestamp data object
     * @param {number} streamData.timeStamp.rtpTimeStamp RTP timeStamp
     * @param {number} streamData.timeStamp.timestamp Frame timestamp
     * @param {number} streamData.timeStamp.timestamp_usec Frame timestamp millisecond
     * @param {number} streamData.timeStamp.timezone timezone.
     * @param {object} videoInfo videoInfo object
     * @param {string} videoInfo.frameType "I" or "P"
     * @param {number} videoInfo.spsPayload sps
     * @param {number} videoInfo.ppsPayload pps
     * @param {number} videoInfo.framerate frame rate
     * @param {number} videoInfo.codecInfo codecInfo
     * @param {number} videoInfo.width width for mjpeg
     * @param {number} videoInfo.height height for mjpeg
     * @param {number} videoInfo.profileIdc profile idc
     * @param {number} videoInfo.levelIdc level idc
     * @example
     *     example: videoPlayer.onVideoData(playMode, streamData, videoInfo);
     */
    onVideoData: function (playMode, streamData, videoInfo) {
      if (mediaSource !== null && mediaSource.readyState !== "ended") {
        videotag_log.debug("ch: " + this.channelId + "', readyState: " + mediaSource.readyState + ", frame: " + videoInfo.frameType)

        if (playMode === "Playback") {
          playbackFlag = true;
          if (deviceType === "camera") {
            checkPlaybackEnd(streamData.timeStamp);
          }
        }
        if (codecInfo !== videoInfo.codecInfo && videoInfo.frameType === "I") {
          codecInfo = videoInfo.codecInfo;
          createInitSegment(videoInfo, streamData.codecType);
        }
        receiveTimeStamp = streamData.timeStamp;
        createSample(streamData, videoInfo);

        if (minimapInfo.isUpdate &&  minimapInfo.element) {
          minimapInfo.element.getContext('2d').drawImage(videoElement, 0, 0,
            minimapInfo.element.width, minimapInfo.element.height);
          minimapInfo.isUpdate = false;
        }
      }
    },
    /**
     * This function is save image file.
     * @function capture
     * @memberof VideoTagPlayer
     * @example
     *     example: videoPlayer.capture(fileName);
     */
    capture: function (_fileName) {
      captureFlag = true;
      fileName = _fileName;
    },
    /**
     * This function is to set timestamp callback function.
     * @function setTimeStampCallback
     * @memberof VideoTagPlayer
     * @param {function} func timestamp callback function
     * @example
     *     example: VideoTagPlayer.setTimeStampCallback(function);
     */
    setTimeStampCallback: function (func) {
      timeStampCallback = func;
    },
    /**
     * This function is set speed value.
     * @function setSpeedPlay
     * @memberof VideoTagPlayer
     * @example
     *     example: videoPlayer.setSpeedPlay(speed);
     */
    setSpeedPlay: function (speed) {
      speedValue = parseInt(speed, 10);
    },
    /**
     * This function is set resize callback function.
     * @function setResizeCallback
     * @memberof VideoTagPlayer
     * @param {function} func resize callback function
     * @example
     *     example: videoPlayer.setResizeCallback(func);
     */
    setResizeCallback: function (func) {
      videoSizeCallback = func;
    },
    /**
     * This function is set error callback function.
     * @function setErrorCallback
     * @memberof VideoTagPlayer
     * @param {function} func error callback function
     * @example
     *     example: videoPlayer.setErrorCallback(func);
     */
    setErrorCallback: function (func) {
      errorCallback = func;
    },
    setRequestTime: function (data) {
      requestTime = data;
    },
    setDeviceType: function (type) {
      deviceType = type;
    },
    updateMiniMapInfo : function(data) {
      var command = data.mode;
      if ( minimapInfo.element === null && typeof data.target !== 'undefined') {
        minimapInfo.element = data.target;
      }
      if (command === 'on') {
        minimapInfo.element = data.target;
      } else if ( command === 'draw') {
        minimapInfo.isUpdate = true;
      } else {
        minimapInfo = {
          isUpdate : false,
          element : null
        };
      }
    },
    /**
     * This function is play VideoTagPlayer.
     * @function play
     * @memberof VideoTagPlayer
     * @example
     *     example: videoPlayer.play();
     */
    play: function () {
      videotag_log.info("VideoTagPlayer::play");
      videoTagPromise = videoElement.play();
      if (typeof videoTagPromise !== "undefined") {
        videoTagPromise.then(function(){
          // AutoPlay Started
          videoElement.play();
        }).catch(function(err){
          // AutoPlay was prevented
          videoElement.pause();
        });
      }
    },
    /**
     * This function is pause VideoTagPlayer.
     * @function pause
     * @memberof VideoTagPlayer
     * @example
     *     example: VideoTagPlayer.pause();
     */
    pause: function () {
      videotag_log.info("VideoTagPlayer::pause");
      if (!videoElement.paused) {
        videoElement.pause();

        videotag_log.info(this.playmode);
        //_self.setInstantPlaybackMode(true);
        if(this.playmode === 'live') {
          this.instantplayback = true;
          this.toggleControls();
        }
      }
      // else if (videoElement.paused & !isPause) {
      //   videoElement.pause();
      //   this.toggleControls();
      // }
    },
    /**
     * This function is resume VideoTagPlayer.
     * @function resume
     * @memberof VideoTagPlayer
     * @example
     *     example: VideoTagPlayer.resume();
     */
    resume: function() {
      videotag_log.info("VideoTagPlayer::resume");
      // if (videoElement.paused) {
      //   videoElement.pause();
        // recovery instant playback mode to nomal mode
        if(this.playmode === 'live') {
          this.toggleControls();
          this.instantplayback = false;

          var data = {
            channelId: _self.channelId,
            errorCode: fromHex('0x1101')
          }

          if(typeof _self.eventInstantPlaybackCallback !== 'undefined' &&
             _self.eventInstantPlaybackCallback !== null) {
            _self.eventInstantPlaybackCallback(data);
          }
        }
//      }

      if ( !isPlaying) {
        videoPlay();
      }
    },
    /**
     * This function is stop VideoTagPlayer.
     * @function stop
     * @memberof VideoTagPlayer
     * @example
     *     example: VideoTagPlayer.stop();
     */
    stop: function () {
      videotag_log.debug("VideoTagPlayer::stop");
    },
    /**
     * This function is close VideoTagPlayer.
     * @function close
     * @memberof VideoTagPlayer
     * @example
     *     example: VideoTagPlayer.close();
     */
    close: function () {
        videotag_log.info("VideoTagPlayer::close");

        // if (typeof videoElement !== 'undefined' && videoElement !== null) {
        //   videoElement.pause();
        // }
        videoPause();

        //      while(mediaSource.readyState !== 'ended') {
        //      }

        try {
          //console.log("#########################");
          //mediaSource.removeSourceBuffer(sourceBuffer);
          if (mediaSource !== null && mediaSource !== undefined) {
            mediaSource.removeSourceBuffer(mediaSource.sourceBuffers[0]);

            if (mediaSource.readyState !== 'ended') {
              mediaSource.endOfStream();
            }
          }

          nPreviousFrame = nCurrentFrame = 0;
          if (oneSecondInterval !== undefined && oneSecondInterval !== null) {
            clearInterval(oneSecondInterval);
          }
          if (theInterval !== undefined && theInterval !== null) {
            clearInterval(theInterval);
          }
        } catch (error) {
          console.error("Video Tag Player, error code: " + error.code + ", message: " + error.message);
          // throw new umpError({
          //   channelId: this.channelId,
          //   errorCode: error.code,
          //   place: 'videoTagPlayer.js:866',
          //   message: error.message
          // });
        }

      var cueList = videoElement.textTracks[targetTextTrackId].cues;
      videoElement.textTracks[targetTextTrackId].mode = 'disabled';
      if ( cueList !== null) {
        for ( var i=0 ; i< cueList.length ; i++) {
          videoElement.textTracks[targetTextTrackId].removeCue(cueList[i]);
        }
      }
      videoElement.textTracks[targetTextTrackId].oncuechange = null;
      removeEventListener();

      if (typeof videoElement !== 'undefined' && videoElement !== null) {
        videoElement.style.background = '' + videoElement.style.background;
        window.URL.revokeObjectURL(videoElement.src);
      }

    },
       /**
     * This function is forward VideoTagPlayer.
     * @function forward
     * @memberof VideoTagPlayer
     * @example
     *     example: VideoTagPlayer.forward();
     */
    forward: function () {
      videotag_log.info("VideoTagPlayer::forward");
      if (typeof videoElement !== 'undefined' && videoElement !== null) {
       // videoElement.seekToNextFrame();
      }
    },
    /**
     * This function is backward VideoTagPlayer.
     * @function backward
     * @memberof VideoTagPlayer
     * @example
     *     example: VideoTagPlayer.backward();
     */
    backward: function () {
      videotag_log.info("VideoTagPlayer::backward");
    },
    toggleControls: function () {
      if (videoElement.hasAttribute("controls")) {
        videoElement.removeAttribute("controls");
      } else {
        videoElement.setAttribute("controls", "controls");
      }
    },
    /**
     * This function is to clear buffer of VideoPlayer.
     * @function clearBuffer
     * @memberof VideoTagPlayer
     * @example
     *     VideoTagPlayer.clearBuffer();
     */
    clearBuffer: function() {
      videotag_log.info("VideoTagPlayer::clearBuffer");
      var endTime = sourceBuffer.buffered.end(sourceBuffer.buffered.length - 1) * 1;
      try {
          if (!sourceBuffer.updating) {
            sourceBuffer.remove(0, endTime);
            videotag_log.info("VideoTagPlayer::clearBuffer buffer length = ", sourceBuffer.buffered.end(sourceBuffer.buffered.length - 1) * 1);
          }
      } catch (error) {
        videotag_log.error("VideoTagPlayer::clearBuffer remove buffer error from channel: " + this.channelId + ", error message: " + error.message);
        throw new umpError({
          channelId: this.channelId,
          errorCode: fromHex('0x0501'),
          place: 'videoTagPlayer.js:1147',
          message: "error has occured from source buffer of VideoTagPlayer."
        });
      }
    }
  });

  return new Constructor();
}
function VideoPlayer() {
  "use strict";

  var version = '1.0.0';
  var videoplayertag_log = log4javascript.getLogger('player');

  var prevEndTime = 0;
  var _self;

  function Constructor() {
    _self = this;
    Constructor.prototype.frameRate = 30;
    Constructor.prototype.minRemainTime = 30;
    Constructor.prototype.minTimerInterval = 1;
    Constructor.prototype.channelId = 0;
    Constructor.prototype.drop = false;
    Constructor.prototype.boxsize = 4;
    Constructor.prototype.maxdelay = 0.3;
    Constructor.prototype.currentdelay = Constructor.prototype.maxdelay;
  }

  Constructor.prototype = {
    /**
     * This function is initialize videoPlayer.
     * @function init
     * @memberof VideoPlayer
     * @example
     *     example: videoPlayer.init(element);
     */
    init: function (element) {
      videoplayertag_log.info("videoPlayer::init");
    },
    /**
     * This function is receive video data.
     * @function onVideoData
     * @memberof VideoPlayer
     * @param {string} playMode "Live" or "Playback"
     * @param {object} streamData streamData object
     * @param {string} streamData.codecType "MJPEG", "H264", "H265"
     * @param {Uint8Array} streamData.frameData Depacketized frame data
     * @param {object} streamData.timestamp Timestamp data object
     * @param {number} streamData.timestamp.rtpTimeStamp RTP timeStamp
     * @param {number} streamData.timestamp.timestamp Frame timestamp
     * @param {number} streamData.timestamp.timestamp_usec Frame timestamp millisecond
     * @param {number} streamData.timestamp.timezone timezone.
     * @param {object} videoInfo videoInfo object
     * @param {string} videoInfo.frameType "I" or "P"
     * @param {number} videoInfo.sps sps
     * @param {number} videoInfo.pps pps
     * @param {number} videoInfo.framerate frame rate
     * @param {string} codecInfo codecInfo for MediaSource
     * @example
     *     example: videoPlayer.onVideoData(playMode, streamData, videoInfo, codecInfo);
     */
    onVideoData: function (playMode, streamData, videoInfo, codecInfo) {
      videoplayertag_log.info("videoPlayer::onVideoData");
    },
    /**
     * This function is play videoPlayer.
     * @function play
     * @memberof VideoPlayer
     * @example
     *     example: videoPlayer.play();
     */
    play: function () {
      videoplayertag_log.info("videoPlayer::play");
    },
    /**
     * This function is pause videoPlayer.
     * @function pause
     * @memberof VideoPlayer
     * @example
     *     example: videoPlayer.pause();
     */
    pause: function () {
      videoplayertag_log.info("videoPlayer::pause");
    },
    resume: function () {
      videoplayertag_log.info("videoPlayer::resume");
    },
    /**
     * This function is stop videoPlayer.
     * @function stop
     * @memberof VideoPlayer
     * @example
     *     videoPlayer.stop();
     */
    stop: function () {
      videoplayertag_log.info("videoPlayer::stop");
    },
    /**
     * This function is close videoPlayer.
     * @function close
     * @memberof VideoPlayer
     * @example
     *     videoPlayer.close();
     */
    close: function () {
      videoplayertag_log.info("videoPlayer::close");
    },
    /**
     * This function clear buffer for video tag.<br>
     * you have to override sub object
     * @function clearBuffer
     * @memberof VideoPlayer
     * @example
     *     videoPlayer.clearBuffer();
     */
    clearBuffer: function () {
      videoplayertag_log.info("videoPlayer::clearBuffer");
    },
    /**
     * This function add event listener on videoPlayer.js
     * @function addEventListener
     * @memberof VideoPlayer
     * @example
     *     videoPlayer.addEventListener('statistics', <callback function>);
     */
    addEventListener: function (event, callback) {
      switch (event) {
        case 'statistics':
          this.eventStatisticsCallback = callback;
          break;
        case 'capture':
          this.eventCaptureCallback = callback;
          break;
        case 'instantplayback':
          this.eventInstantPlaybackCallback = callback;
          break;
      }
    },
    /**
     * This function set frame rate to player
     * @function setFrameRate
     * @param  {number} fps max frame rate
     * @memberof VideoPlayer
     * @example
     *     videoPlayer.setFrameRate();
     */
    setFrameRate: function (fps) {
      Constructor.prototype.frameRate = fps;
    },
    /**
     * This function get frame rate from player
     * @function getFrameRate
     * @return {number} frame rate
     * @memberof VideoPlayer
     * @example
     *     var fpsValue = videoPlayer.getFrameRate();
     */
    getFrameRate: function () {
      return Constructor.prototype.frameRate;
    },
    /**
     * This function set max instance playback time
     * @function setMaxInstantPlayback
     * @param  {number} thresholdInstantPlaybackTime remain buffer size (second)
     * @memberof VideoPlayer
     * @example
     *     videoPlayer.setMaxInstantPlayback(10);
     */
    setMaxInstantPlayback: function (thresholdInstantPlaybackTime) {
      Constructor.prototype.minRemainTime = thresholdInstantPlaybackTime;
    },
    /**
     * This function get max instance playback time
     * @function setMaxInstantPlayback
     * @return  {number} remain buffer size (second)
     * @memberof VideoPlayer
     * @example
     *     var instantplaybacktime = videoPlayer.getMaxInstantPlayback();
     */
    getMaxInstantPlayback: function () {
      return Constructor.prototype.minRemainTime;
    },
    /**
     * This function get max instance playback time
     * @function setBufferClearInterval
     * @param  {number} interval clear interval (second)
     * @memberof VideoPlayer
     * @example
     *     videoPlayer.setBufferClearInterval(5);
     */
    setBufferClearInterval: function (interval) {
      Constructor.prototype.minTimerInterval = interval;
    },
    /**
     * This function get buffer clear interval instance playback time
     * @function getBufferClearInterval
     * @return  {number} interval clear interval (second)
     * @memberof VideoPlayer
     * @example
     *     var interval = videoPlayer.getBufferClearInterval();
     */
    getBufferClearInterval: function () {
      return Constructor.prototype.minTimerInterval;
    },
    /**
     * This function get max instance playback time
     * @function useDropPacket
     * @param  {boolean} useDropPacket drop packet flags
     * @memberof VideoPlayer
     * @example
     *     videoPlayer.useDropPacket(true);
     */
    useDropPacket: function (useDropPacket) {
      Constructor.prototype.drop = useDropPacket;
    },
    /**
     * This function get max instance playback time
     * @function isDropPacket
     * @return  {boolean} return drop packet flags
     * @memberof VideoPlayer
     * @example
     *     var useDropPacket = videoPlayer.isDropPacket();
     */
    isDropPacket: function () {
      return Constructor.prototype.drop;
    },
    /**
     * This function updateMiniMapInfo
     * @function updateMiniMapInfo
     * @memberof VideoPlayer
     * @example
     *     videoPlayer.updateMiniMapInfo();
     */
    updateMiniMapInfo: function (elem) {
      videoplayertag_log.info("videoPlayer::updateMiniMapInfo");
    },
    /**
     * This function setBoxSize
     * @function setBoxSize
     * @memberof VideoPlayer
     * @example
     *     videoPlayer.setBoxSize(1);
     */
    setBoxSize: function (boxsize) {
      videoplayertag_log.info("videoPlayer::setBoxSize: " + boxsize);
      Constructor.prototype.boxsize = boxsize;
    },
    /**
     * This function getBoxSize
     * @function getBoxSize
     * @memberof VideoPlayer
     * @example
     *     videoPlayer.getBoxSize();
     */
    getBoxSize: function () {
      videoplayertag_log.debug("videoPlayer::getBoxSize: " + Constructor.prototype.boxsize);
      return Constructor.prototype.boxsize;
    },
    /**
     * This function is forward VideoPlayer.
     * @function forward
     * @memberof VideoPlayer
     * @example
     *     example: VideoPlayer.forward();
     */
    forward: function () {
      videoplayertag_log.info("videoPlayer::forward");
    },
    /**
     * This function is backward VideoPlayer.
     * @function backward
     * @memberof VideoPlayer
     * @example
     *     example: VideoPlayer.backward();
     */
    backward: function () {
      videoplayertag_log.info("videoPlayer::backward");
    },
    /**
     * This function is to set delay variance of VideoPlayer.
     * @function delay
     * @memberof VideoPlayer
     * @param {Boolean} v  Instance playback mode
     * @example
     *     VideoPlayer.setDelay(0.3);
     */
    setDefaultDelay: function(v) {
      Constructor.prototype.maxdelay  = v;
    },
    /**
     * This function is to get delay variance of VideoPlayer.
     * @function delay
     * @memberof VideoPlayer
     * @param {Boolean} v  Instance playback mode
     * @example
     *     var delay = VideoPlayer.getDelay();
     */
    getDefaultDelay: function() {
      return Constructor.prototype.maxdelay;
    },
    /**
     * This function is to set delay variance of VideoPlayer.
     * @function delay
     * @memberof VideoPlayer
     * @param {Boolean} v  Instance playback mode
     * @example
     *     VideoPlayer.setDelay(0.3);
     */
    setCurrentDelay: function(v) {
      Constructor.prototype.currentdelay  = v;
    },
    /**
     * This function is to get delay variance of VideoPlayer.
     * @function delay
     * @memberof VideoPlayer
     * @param {Boolean} v  Instance playback mode
     * @example
     *     var delay = VideoPlayer.getDelay();
     */
    getCurrentDelay: function() {
      return Constructor.prototype.currentdelay;
    },
  }

  /**
   * This property is channel number.
   * @function channelId
   * @memberof VideoPlayer
   * @example
   *    videoPlayer.channelId = ;
   */
  Object.defineProperty(this, "channelId", {
    get: function() {
        return channel;
    },
    set: function(v) {
      channel = v;
    },
  });

  Object.defineProperty(this, "playmode", {
    get: function() {
        return playmode;
    },
    set: function(v) {
      playmode = v;
    },
  });

  /**
   * This function is to return instant playback state of VideoPlayer.
   * @property instantplayback
   * @memberof VideoPlayer
   * @example
   *     VideoPlayer.instantplayback = true;
   */
  Object.defineProperty(this, "instantplayback", {
    get: function() {
        return instantplayback;
    },
    set: function(v) {
      instantplayback = v;
    },
  });

  return new Constructor();
}